// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: aggregator.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_aggregator_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_aggregator_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_aggregator_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_aggregator_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_aggregator_2eproto;
namespace aggregator {
namespace v1 {
class AggregatorMessage;
struct AggregatorMessageDefaultTypeInternal;
extern AggregatorMessageDefaultTypeInternal _AggregatorMessage_default_instance_;
class CancelRequest;
struct CancelRequestDefaultTypeInternal;
extern CancelRequestDefaultTypeInternal _CancelRequest_default_instance_;
class CancelResponse;
struct CancelResponseDefaultTypeInternal;
extern CancelResponseDefaultTypeInternal _CancelResponse_default_instance_;
class FinalProof;
struct FinalProofDefaultTypeInternal;
extern FinalProofDefaultTypeInternal _FinalProof_default_instance_;
class GenAggregatedProofRequest;
struct GenAggregatedProofRequestDefaultTypeInternal;
extern GenAggregatedProofRequestDefaultTypeInternal _GenAggregatedProofRequest_default_instance_;
class GenAggregatedProofResponse;
struct GenAggregatedProofResponseDefaultTypeInternal;
extern GenAggregatedProofResponseDefaultTypeInternal _GenAggregatedProofResponse_default_instance_;
class GenBatchProofRequest;
struct GenBatchProofRequestDefaultTypeInternal;
extern GenBatchProofRequestDefaultTypeInternal _GenBatchProofRequest_default_instance_;
class GenBatchProofResponse;
struct GenBatchProofResponseDefaultTypeInternal;
extern GenBatchProofResponseDefaultTypeInternal _GenBatchProofResponse_default_instance_;
class GenFinalProofRequest;
struct GenFinalProofRequestDefaultTypeInternal;
extern GenFinalProofRequestDefaultTypeInternal _GenFinalProofRequest_default_instance_;
class GenFinalProofResponse;
struct GenFinalProofResponseDefaultTypeInternal;
extern GenFinalProofResponseDefaultTypeInternal _GenFinalProofResponse_default_instance_;
class GetProofRequest;
struct GetProofRequestDefaultTypeInternal;
extern GetProofRequestDefaultTypeInternal _GetProofRequest_default_instance_;
class GetProofResponse;
struct GetProofResponseDefaultTypeInternal;
extern GetProofResponseDefaultTypeInternal _GetProofResponse_default_instance_;
class GetStatusRequest;
struct GetStatusRequestDefaultTypeInternal;
extern GetStatusRequestDefaultTypeInternal _GetStatusRequest_default_instance_;
class GetStatusResponse;
struct GetStatusResponseDefaultTypeInternal;
extern GetStatusResponseDefaultTypeInternal _GetStatusResponse_default_instance_;
class InputProver;
struct InputProverDefaultTypeInternal;
extern InputProverDefaultTypeInternal _InputProver_default_instance_;
class InputProver_ContractsBytecodeEntry_DoNotUse;
struct InputProver_ContractsBytecodeEntry_DoNotUseDefaultTypeInternal;
extern InputProver_ContractsBytecodeEntry_DoNotUseDefaultTypeInternal _InputProver_ContractsBytecodeEntry_DoNotUse_default_instance_;
class InputProver_DbEntry_DoNotUse;
struct InputProver_DbEntry_DoNotUseDefaultTypeInternal;
extern InputProver_DbEntry_DoNotUseDefaultTypeInternal _InputProver_DbEntry_DoNotUse_default_instance_;
class ProverMessage;
struct ProverMessageDefaultTypeInternal;
extern ProverMessageDefaultTypeInternal _ProverMessage_default_instance_;
class PublicInputs;
struct PublicInputsDefaultTypeInternal;
extern PublicInputsDefaultTypeInternal _PublicInputs_default_instance_;
class PublicInputsExtended;
struct PublicInputsExtendedDefaultTypeInternal;
extern PublicInputsExtendedDefaultTypeInternal _PublicInputsExtended_default_instance_;
class Version;
struct VersionDefaultTypeInternal;
extern VersionDefaultTypeInternal _Version_default_instance_;
}  // namespace v1
}  // namespace aggregator
PROTOBUF_NAMESPACE_OPEN
template<> ::aggregator::v1::AggregatorMessage* Arena::CreateMaybeMessage<::aggregator::v1::AggregatorMessage>(Arena*);
template<> ::aggregator::v1::CancelRequest* Arena::CreateMaybeMessage<::aggregator::v1::CancelRequest>(Arena*);
template<> ::aggregator::v1::CancelResponse* Arena::CreateMaybeMessage<::aggregator::v1::CancelResponse>(Arena*);
template<> ::aggregator::v1::FinalProof* Arena::CreateMaybeMessage<::aggregator::v1::FinalProof>(Arena*);
template<> ::aggregator::v1::GenAggregatedProofRequest* Arena::CreateMaybeMessage<::aggregator::v1::GenAggregatedProofRequest>(Arena*);
template<> ::aggregator::v1::GenAggregatedProofResponse* Arena::CreateMaybeMessage<::aggregator::v1::GenAggregatedProofResponse>(Arena*);
template<> ::aggregator::v1::GenBatchProofRequest* Arena::CreateMaybeMessage<::aggregator::v1::GenBatchProofRequest>(Arena*);
template<> ::aggregator::v1::GenBatchProofResponse* Arena::CreateMaybeMessage<::aggregator::v1::GenBatchProofResponse>(Arena*);
template<> ::aggregator::v1::GenFinalProofRequest* Arena::CreateMaybeMessage<::aggregator::v1::GenFinalProofRequest>(Arena*);
template<> ::aggregator::v1::GenFinalProofResponse* Arena::CreateMaybeMessage<::aggregator::v1::GenFinalProofResponse>(Arena*);
template<> ::aggregator::v1::GetProofRequest* Arena::CreateMaybeMessage<::aggregator::v1::GetProofRequest>(Arena*);
template<> ::aggregator::v1::GetProofResponse* Arena::CreateMaybeMessage<::aggregator::v1::GetProofResponse>(Arena*);
template<> ::aggregator::v1::GetStatusRequest* Arena::CreateMaybeMessage<::aggregator::v1::GetStatusRequest>(Arena*);
template<> ::aggregator::v1::GetStatusResponse* Arena::CreateMaybeMessage<::aggregator::v1::GetStatusResponse>(Arena*);
template<> ::aggregator::v1::InputProver* Arena::CreateMaybeMessage<::aggregator::v1::InputProver>(Arena*);
template<> ::aggregator::v1::InputProver_ContractsBytecodeEntry_DoNotUse* Arena::CreateMaybeMessage<::aggregator::v1::InputProver_ContractsBytecodeEntry_DoNotUse>(Arena*);
template<> ::aggregator::v1::InputProver_DbEntry_DoNotUse* Arena::CreateMaybeMessage<::aggregator::v1::InputProver_DbEntry_DoNotUse>(Arena*);
template<> ::aggregator::v1::ProverMessage* Arena::CreateMaybeMessage<::aggregator::v1::ProverMessage>(Arena*);
template<> ::aggregator::v1::PublicInputs* Arena::CreateMaybeMessage<::aggregator::v1::PublicInputs>(Arena*);
template<> ::aggregator::v1::PublicInputsExtended* Arena::CreateMaybeMessage<::aggregator::v1::PublicInputsExtended>(Arena*);
template<> ::aggregator::v1::Version* Arena::CreateMaybeMessage<::aggregator::v1::Version>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace aggregator {
namespace v1 {

enum GetStatusResponse_Status : int {
  GetStatusResponse_Status_STATUS_UNSPECIFIED = 0,
  GetStatusResponse_Status_STATUS_BOOTING = 1,
  GetStatusResponse_Status_STATUS_COMPUTING = 2,
  GetStatusResponse_Status_STATUS_IDLE = 3,
  GetStatusResponse_Status_STATUS_HALT = 4,
  GetStatusResponse_Status_GetStatusResponse_Status_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  GetStatusResponse_Status_GetStatusResponse_Status_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool GetStatusResponse_Status_IsValid(int value);
constexpr GetStatusResponse_Status GetStatusResponse_Status_Status_MIN = GetStatusResponse_Status_STATUS_UNSPECIFIED;
constexpr GetStatusResponse_Status GetStatusResponse_Status_Status_MAX = GetStatusResponse_Status_STATUS_HALT;
constexpr int GetStatusResponse_Status_Status_ARRAYSIZE = GetStatusResponse_Status_Status_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* GetStatusResponse_Status_descriptor();
template<typename T>
inline const std::string& GetStatusResponse_Status_Name(T enum_t_value) {
  static_assert(::std::is_same<T, GetStatusResponse_Status>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function GetStatusResponse_Status_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    GetStatusResponse_Status_descriptor(), enum_t_value);
}
inline bool GetStatusResponse_Status_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, GetStatusResponse_Status* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<GetStatusResponse_Status>(
    GetStatusResponse_Status_descriptor(), name, value);
}
enum GetProofResponse_Result : int {
  GetProofResponse_Result_RESULT_UNSPECIFIED = 0,
  GetProofResponse_Result_RESULT_COMPLETED_OK = 1,
  GetProofResponse_Result_RESULT_ERROR = 2,
  GetProofResponse_Result_RESULT_COMPLETED_ERROR = 3,
  GetProofResponse_Result_RESULT_PENDING = 4,
  GetProofResponse_Result_RESULT_INTERNAL_ERROR = 5,
  GetProofResponse_Result_RESULT_CANCEL = 6,
  GetProofResponse_Result_GetProofResponse_Result_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  GetProofResponse_Result_GetProofResponse_Result_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool GetProofResponse_Result_IsValid(int value);
constexpr GetProofResponse_Result GetProofResponse_Result_Result_MIN = GetProofResponse_Result_RESULT_UNSPECIFIED;
constexpr GetProofResponse_Result GetProofResponse_Result_Result_MAX = GetProofResponse_Result_RESULT_CANCEL;
constexpr int GetProofResponse_Result_Result_ARRAYSIZE = GetProofResponse_Result_Result_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* GetProofResponse_Result_descriptor();
template<typename T>
inline const std::string& GetProofResponse_Result_Name(T enum_t_value) {
  static_assert(::std::is_same<T, GetProofResponse_Result>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function GetProofResponse_Result_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    GetProofResponse_Result_descriptor(), enum_t_value);
}
inline bool GetProofResponse_Result_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, GetProofResponse_Result* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<GetProofResponse_Result>(
    GetProofResponse_Result_descriptor(), name, value);
}
enum Result : int {
  RESULT_UNSPECIFIED = 0,
  RESULT_OK = 1,
  RESULT_ERROR = 2,
  RESULT_INTERNAL_ERROR = 3,
  Result_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Result_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Result_IsValid(int value);
constexpr Result Result_MIN = RESULT_UNSPECIFIED;
constexpr Result Result_MAX = RESULT_INTERNAL_ERROR;
constexpr int Result_ARRAYSIZE = Result_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Result_descriptor();
template<typename T>
inline const std::string& Result_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Result>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Result_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Result_descriptor(), enum_t_value);
}
inline bool Result_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Result* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Result>(
    Result_descriptor(), name, value);
}
// ===================================================================

class Version final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aggregator.v1.Version) */ {
 public:
  inline Version() : Version(nullptr) {}
  ~Version() override;
  explicit PROTOBUF_CONSTEXPR Version(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Version(const Version& from);
  Version(Version&& from) noexcept
    : Version() {
    *this = ::std::move(from);
  }

  inline Version& operator=(const Version& from) {
    CopyFrom(from);
    return *this;
  }
  inline Version& operator=(Version&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Version& default_instance() {
    return *internal_default_instance();
  }
  static inline const Version* internal_default_instance() {
    return reinterpret_cast<const Version*>(
               &_Version_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Version& a, Version& b) {
    a.Swap(&b);
  }
  inline void Swap(Version* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Version* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Version* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Version>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Version& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Version& from) {
    Version::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Version* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "aggregator.v1.Version";
  }
  protected:
  explicit Version(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kV001FieldNumber = 1,
  };
  // string v0_0_1 = 1;
  void clear_v0_0_1();
  const std::string& v0_0_1() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_v0_0_1(ArgT0&& arg0, ArgT... args);
  std::string* mutable_v0_0_1();
  PROTOBUF_NODISCARD std::string* release_v0_0_1();
  void set_allocated_v0_0_1(std::string* v0_0_1);
  private:
  const std::string& _internal_v0_0_1() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_v0_0_1(const std::string& value);
  std::string* _internal_mutable_v0_0_1();
  public:

  // @@protoc_insertion_point(class_scope:aggregator.v1.Version)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr v0_0_1_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_aggregator_2eproto;
};
// -------------------------------------------------------------------

class AggregatorMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aggregator.v1.AggregatorMessage) */ {
 public:
  inline AggregatorMessage() : AggregatorMessage(nullptr) {}
  ~AggregatorMessage() override;
  explicit PROTOBUF_CONSTEXPR AggregatorMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AggregatorMessage(const AggregatorMessage& from);
  AggregatorMessage(AggregatorMessage&& from) noexcept
    : AggregatorMessage() {
    *this = ::std::move(from);
  }

  inline AggregatorMessage& operator=(const AggregatorMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline AggregatorMessage& operator=(AggregatorMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AggregatorMessage& default_instance() {
    return *internal_default_instance();
  }
  enum RequestCase {
    kGetStatusRequest = 2,
    kGenBatchProofRequest = 3,
    kGenAggregatedProofRequest = 4,
    kGenFinalProofRequest = 5,
    kCancelRequest = 6,
    kGetProofRequest = 7,
    REQUEST_NOT_SET = 0,
  };

  static inline const AggregatorMessage* internal_default_instance() {
    return reinterpret_cast<const AggregatorMessage*>(
               &_AggregatorMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(AggregatorMessage& a, AggregatorMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(AggregatorMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AggregatorMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AggregatorMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AggregatorMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AggregatorMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AggregatorMessage& from) {
    AggregatorMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AggregatorMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "aggregator.v1.AggregatorMessage";
  }
  protected:
  explicit AggregatorMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kGetStatusRequestFieldNumber = 2,
    kGenBatchProofRequestFieldNumber = 3,
    kGenAggregatedProofRequestFieldNumber = 4,
    kGenFinalProofRequestFieldNumber = 5,
    kCancelRequestFieldNumber = 6,
    kGetProofRequestFieldNumber = 7,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // .aggregator.v1.GetStatusRequest get_status_request = 2;
  bool has_get_status_request() const;
  private:
  bool _internal_has_get_status_request() const;
  public:
  void clear_get_status_request();
  const ::aggregator::v1::GetStatusRequest& get_status_request() const;
  PROTOBUF_NODISCARD ::aggregator::v1::GetStatusRequest* release_get_status_request();
  ::aggregator::v1::GetStatusRequest* mutable_get_status_request();
  void set_allocated_get_status_request(::aggregator::v1::GetStatusRequest* get_status_request);
  private:
  const ::aggregator::v1::GetStatusRequest& _internal_get_status_request() const;
  ::aggregator::v1::GetStatusRequest* _internal_mutable_get_status_request();
  public:
  void unsafe_arena_set_allocated_get_status_request(
      ::aggregator::v1::GetStatusRequest* get_status_request);
  ::aggregator::v1::GetStatusRequest* unsafe_arena_release_get_status_request();

  // .aggregator.v1.GenBatchProofRequest gen_batch_proof_request = 3;
  bool has_gen_batch_proof_request() const;
  private:
  bool _internal_has_gen_batch_proof_request() const;
  public:
  void clear_gen_batch_proof_request();
  const ::aggregator::v1::GenBatchProofRequest& gen_batch_proof_request() const;
  PROTOBUF_NODISCARD ::aggregator::v1::GenBatchProofRequest* release_gen_batch_proof_request();
  ::aggregator::v1::GenBatchProofRequest* mutable_gen_batch_proof_request();
  void set_allocated_gen_batch_proof_request(::aggregator::v1::GenBatchProofRequest* gen_batch_proof_request);
  private:
  const ::aggregator::v1::GenBatchProofRequest& _internal_gen_batch_proof_request() const;
  ::aggregator::v1::GenBatchProofRequest* _internal_mutable_gen_batch_proof_request();
  public:
  void unsafe_arena_set_allocated_gen_batch_proof_request(
      ::aggregator::v1::GenBatchProofRequest* gen_batch_proof_request);
  ::aggregator::v1::GenBatchProofRequest* unsafe_arena_release_gen_batch_proof_request();

  // .aggregator.v1.GenAggregatedProofRequest gen_aggregated_proof_request = 4;
  bool has_gen_aggregated_proof_request() const;
  private:
  bool _internal_has_gen_aggregated_proof_request() const;
  public:
  void clear_gen_aggregated_proof_request();
  const ::aggregator::v1::GenAggregatedProofRequest& gen_aggregated_proof_request() const;
  PROTOBUF_NODISCARD ::aggregator::v1::GenAggregatedProofRequest* release_gen_aggregated_proof_request();
  ::aggregator::v1::GenAggregatedProofRequest* mutable_gen_aggregated_proof_request();
  void set_allocated_gen_aggregated_proof_request(::aggregator::v1::GenAggregatedProofRequest* gen_aggregated_proof_request);
  private:
  const ::aggregator::v1::GenAggregatedProofRequest& _internal_gen_aggregated_proof_request() const;
  ::aggregator::v1::GenAggregatedProofRequest* _internal_mutable_gen_aggregated_proof_request();
  public:
  void unsafe_arena_set_allocated_gen_aggregated_proof_request(
      ::aggregator::v1::GenAggregatedProofRequest* gen_aggregated_proof_request);
  ::aggregator::v1::GenAggregatedProofRequest* unsafe_arena_release_gen_aggregated_proof_request();

  // .aggregator.v1.GenFinalProofRequest gen_final_proof_request = 5;
  bool has_gen_final_proof_request() const;
  private:
  bool _internal_has_gen_final_proof_request() const;
  public:
  void clear_gen_final_proof_request();
  const ::aggregator::v1::GenFinalProofRequest& gen_final_proof_request() const;
  PROTOBUF_NODISCARD ::aggregator::v1::GenFinalProofRequest* release_gen_final_proof_request();
  ::aggregator::v1::GenFinalProofRequest* mutable_gen_final_proof_request();
  void set_allocated_gen_final_proof_request(::aggregator::v1::GenFinalProofRequest* gen_final_proof_request);
  private:
  const ::aggregator::v1::GenFinalProofRequest& _internal_gen_final_proof_request() const;
  ::aggregator::v1::GenFinalProofRequest* _internal_mutable_gen_final_proof_request();
  public:
  void unsafe_arena_set_allocated_gen_final_proof_request(
      ::aggregator::v1::GenFinalProofRequest* gen_final_proof_request);
  ::aggregator::v1::GenFinalProofRequest* unsafe_arena_release_gen_final_proof_request();

  // .aggregator.v1.CancelRequest cancel_request = 6;
  bool has_cancel_request() const;
  private:
  bool _internal_has_cancel_request() const;
  public:
  void clear_cancel_request();
  const ::aggregator::v1::CancelRequest& cancel_request() const;
  PROTOBUF_NODISCARD ::aggregator::v1::CancelRequest* release_cancel_request();
  ::aggregator::v1::CancelRequest* mutable_cancel_request();
  void set_allocated_cancel_request(::aggregator::v1::CancelRequest* cancel_request);
  private:
  const ::aggregator::v1::CancelRequest& _internal_cancel_request() const;
  ::aggregator::v1::CancelRequest* _internal_mutable_cancel_request();
  public:
  void unsafe_arena_set_allocated_cancel_request(
      ::aggregator::v1::CancelRequest* cancel_request);
  ::aggregator::v1::CancelRequest* unsafe_arena_release_cancel_request();

  // .aggregator.v1.GetProofRequest get_proof_request = 7;
  bool has_get_proof_request() const;
  private:
  bool _internal_has_get_proof_request() const;
  public:
  void clear_get_proof_request();
  const ::aggregator::v1::GetProofRequest& get_proof_request() const;
  PROTOBUF_NODISCARD ::aggregator::v1::GetProofRequest* release_get_proof_request();
  ::aggregator::v1::GetProofRequest* mutable_get_proof_request();
  void set_allocated_get_proof_request(::aggregator::v1::GetProofRequest* get_proof_request);
  private:
  const ::aggregator::v1::GetProofRequest& _internal_get_proof_request() const;
  ::aggregator::v1::GetProofRequest* _internal_mutable_get_proof_request();
  public:
  void unsafe_arena_set_allocated_get_proof_request(
      ::aggregator::v1::GetProofRequest* get_proof_request);
  ::aggregator::v1::GetProofRequest* unsafe_arena_release_get_proof_request();

  void clear_request();
  RequestCase request_case() const;
  // @@protoc_insertion_point(class_scope:aggregator.v1.AggregatorMessage)
 private:
  class _Internal;
  void set_has_get_status_request();
  void set_has_gen_batch_proof_request();
  void set_has_gen_aggregated_proof_request();
  void set_has_gen_final_proof_request();
  void set_has_cancel_request();
  void set_has_get_proof_request();

  inline bool has_request() const;
  inline void clear_has_request();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    union RequestUnion {
      constexpr RequestUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::aggregator::v1::GetStatusRequest* get_status_request_;
      ::aggregator::v1::GenBatchProofRequest* gen_batch_proof_request_;
      ::aggregator::v1::GenAggregatedProofRequest* gen_aggregated_proof_request_;
      ::aggregator::v1::GenFinalProofRequest* gen_final_proof_request_;
      ::aggregator::v1::CancelRequest* cancel_request_;
      ::aggregator::v1::GetProofRequest* get_proof_request_;
    } request_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_aggregator_2eproto;
};
// -------------------------------------------------------------------

class ProverMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aggregator.v1.ProverMessage) */ {
 public:
  inline ProverMessage() : ProverMessage(nullptr) {}
  ~ProverMessage() override;
  explicit PROTOBUF_CONSTEXPR ProverMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ProverMessage(const ProverMessage& from);
  ProverMessage(ProverMessage&& from) noexcept
    : ProverMessage() {
    *this = ::std::move(from);
  }

  inline ProverMessage& operator=(const ProverMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProverMessage& operator=(ProverMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ProverMessage& default_instance() {
    return *internal_default_instance();
  }
  enum ResponseCase {
    kGetStatusResponse = 2,
    kGenBatchProofResponse = 3,
    kGenAggregatedProofResponse = 4,
    kGenFinalProofResponse = 5,
    kCancelResponse = 6,
    kGetProofResponse = 7,
    RESPONSE_NOT_SET = 0,
  };

  static inline const ProverMessage* internal_default_instance() {
    return reinterpret_cast<const ProverMessage*>(
               &_ProverMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(ProverMessage& a, ProverMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(ProverMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProverMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ProverMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ProverMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ProverMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ProverMessage& from) {
    ProverMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProverMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "aggregator.v1.ProverMessage";
  }
  protected:
  explicit ProverMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kGetStatusResponseFieldNumber = 2,
    kGenBatchProofResponseFieldNumber = 3,
    kGenAggregatedProofResponseFieldNumber = 4,
    kGenFinalProofResponseFieldNumber = 5,
    kCancelResponseFieldNumber = 6,
    kGetProofResponseFieldNumber = 7,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // .aggregator.v1.GetStatusResponse get_status_response = 2;
  bool has_get_status_response() const;
  private:
  bool _internal_has_get_status_response() const;
  public:
  void clear_get_status_response();
  const ::aggregator::v1::GetStatusResponse& get_status_response() const;
  PROTOBUF_NODISCARD ::aggregator::v1::GetStatusResponse* release_get_status_response();
  ::aggregator::v1::GetStatusResponse* mutable_get_status_response();
  void set_allocated_get_status_response(::aggregator::v1::GetStatusResponse* get_status_response);
  private:
  const ::aggregator::v1::GetStatusResponse& _internal_get_status_response() const;
  ::aggregator::v1::GetStatusResponse* _internal_mutable_get_status_response();
  public:
  void unsafe_arena_set_allocated_get_status_response(
      ::aggregator::v1::GetStatusResponse* get_status_response);
  ::aggregator::v1::GetStatusResponse* unsafe_arena_release_get_status_response();

  // .aggregator.v1.GenBatchProofResponse gen_batch_proof_response = 3;
  bool has_gen_batch_proof_response() const;
  private:
  bool _internal_has_gen_batch_proof_response() const;
  public:
  void clear_gen_batch_proof_response();
  const ::aggregator::v1::GenBatchProofResponse& gen_batch_proof_response() const;
  PROTOBUF_NODISCARD ::aggregator::v1::GenBatchProofResponse* release_gen_batch_proof_response();
  ::aggregator::v1::GenBatchProofResponse* mutable_gen_batch_proof_response();
  void set_allocated_gen_batch_proof_response(::aggregator::v1::GenBatchProofResponse* gen_batch_proof_response);
  private:
  const ::aggregator::v1::GenBatchProofResponse& _internal_gen_batch_proof_response() const;
  ::aggregator::v1::GenBatchProofResponse* _internal_mutable_gen_batch_proof_response();
  public:
  void unsafe_arena_set_allocated_gen_batch_proof_response(
      ::aggregator::v1::GenBatchProofResponse* gen_batch_proof_response);
  ::aggregator::v1::GenBatchProofResponse* unsafe_arena_release_gen_batch_proof_response();

  // .aggregator.v1.GenAggregatedProofResponse gen_aggregated_proof_response = 4;
  bool has_gen_aggregated_proof_response() const;
  private:
  bool _internal_has_gen_aggregated_proof_response() const;
  public:
  void clear_gen_aggregated_proof_response();
  const ::aggregator::v1::GenAggregatedProofResponse& gen_aggregated_proof_response() const;
  PROTOBUF_NODISCARD ::aggregator::v1::GenAggregatedProofResponse* release_gen_aggregated_proof_response();
  ::aggregator::v1::GenAggregatedProofResponse* mutable_gen_aggregated_proof_response();
  void set_allocated_gen_aggregated_proof_response(::aggregator::v1::GenAggregatedProofResponse* gen_aggregated_proof_response);
  private:
  const ::aggregator::v1::GenAggregatedProofResponse& _internal_gen_aggregated_proof_response() const;
  ::aggregator::v1::GenAggregatedProofResponse* _internal_mutable_gen_aggregated_proof_response();
  public:
  void unsafe_arena_set_allocated_gen_aggregated_proof_response(
      ::aggregator::v1::GenAggregatedProofResponse* gen_aggregated_proof_response);
  ::aggregator::v1::GenAggregatedProofResponse* unsafe_arena_release_gen_aggregated_proof_response();

  // .aggregator.v1.GenFinalProofResponse gen_final_proof_response = 5;
  bool has_gen_final_proof_response() const;
  private:
  bool _internal_has_gen_final_proof_response() const;
  public:
  void clear_gen_final_proof_response();
  const ::aggregator::v1::GenFinalProofResponse& gen_final_proof_response() const;
  PROTOBUF_NODISCARD ::aggregator::v1::GenFinalProofResponse* release_gen_final_proof_response();
  ::aggregator::v1::GenFinalProofResponse* mutable_gen_final_proof_response();
  void set_allocated_gen_final_proof_response(::aggregator::v1::GenFinalProofResponse* gen_final_proof_response);
  private:
  const ::aggregator::v1::GenFinalProofResponse& _internal_gen_final_proof_response() const;
  ::aggregator::v1::GenFinalProofResponse* _internal_mutable_gen_final_proof_response();
  public:
  void unsafe_arena_set_allocated_gen_final_proof_response(
      ::aggregator::v1::GenFinalProofResponse* gen_final_proof_response);
  ::aggregator::v1::GenFinalProofResponse* unsafe_arena_release_gen_final_proof_response();

  // .aggregator.v1.CancelResponse cancel_response = 6;
  bool has_cancel_response() const;
  private:
  bool _internal_has_cancel_response() const;
  public:
  void clear_cancel_response();
  const ::aggregator::v1::CancelResponse& cancel_response() const;
  PROTOBUF_NODISCARD ::aggregator::v1::CancelResponse* release_cancel_response();
  ::aggregator::v1::CancelResponse* mutable_cancel_response();
  void set_allocated_cancel_response(::aggregator::v1::CancelResponse* cancel_response);
  private:
  const ::aggregator::v1::CancelResponse& _internal_cancel_response() const;
  ::aggregator::v1::CancelResponse* _internal_mutable_cancel_response();
  public:
  void unsafe_arena_set_allocated_cancel_response(
      ::aggregator::v1::CancelResponse* cancel_response);
  ::aggregator::v1::CancelResponse* unsafe_arena_release_cancel_response();

  // .aggregator.v1.GetProofResponse get_proof_response = 7;
  bool has_get_proof_response() const;
  private:
  bool _internal_has_get_proof_response() const;
  public:
  void clear_get_proof_response();
  const ::aggregator::v1::GetProofResponse& get_proof_response() const;
  PROTOBUF_NODISCARD ::aggregator::v1::GetProofResponse* release_get_proof_response();
  ::aggregator::v1::GetProofResponse* mutable_get_proof_response();
  void set_allocated_get_proof_response(::aggregator::v1::GetProofResponse* get_proof_response);
  private:
  const ::aggregator::v1::GetProofResponse& _internal_get_proof_response() const;
  ::aggregator::v1::GetProofResponse* _internal_mutable_get_proof_response();
  public:
  void unsafe_arena_set_allocated_get_proof_response(
      ::aggregator::v1::GetProofResponse* get_proof_response);
  ::aggregator::v1::GetProofResponse* unsafe_arena_release_get_proof_response();

  void clear_response();
  ResponseCase response_case() const;
  // @@protoc_insertion_point(class_scope:aggregator.v1.ProverMessage)
 private:
  class _Internal;
  void set_has_get_status_response();
  void set_has_gen_batch_proof_response();
  void set_has_gen_aggregated_proof_response();
  void set_has_gen_final_proof_response();
  void set_has_cancel_response();
  void set_has_get_proof_response();

  inline bool has_response() const;
  inline void clear_has_response();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    union ResponseUnion {
      constexpr ResponseUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::aggregator::v1::GetStatusResponse* get_status_response_;
      ::aggregator::v1::GenBatchProofResponse* gen_batch_proof_response_;
      ::aggregator::v1::GenAggregatedProofResponse* gen_aggregated_proof_response_;
      ::aggregator::v1::GenFinalProofResponse* gen_final_proof_response_;
      ::aggregator::v1::CancelResponse* cancel_response_;
      ::aggregator::v1::GetProofResponse* get_proof_response_;
    } response_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_aggregator_2eproto;
};
// -------------------------------------------------------------------

class GetStatusRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:aggregator.v1.GetStatusRequest) */ {
 public:
  inline GetStatusRequest() : GetStatusRequest(nullptr) {}
  explicit PROTOBUF_CONSTEXPR GetStatusRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetStatusRequest(const GetStatusRequest& from);
  GetStatusRequest(GetStatusRequest&& from) noexcept
    : GetStatusRequest() {
    *this = ::std::move(from);
  }

  inline GetStatusRequest& operator=(const GetStatusRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetStatusRequest& operator=(GetStatusRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetStatusRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetStatusRequest* internal_default_instance() {
    return reinterpret_cast<const GetStatusRequest*>(
               &_GetStatusRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(GetStatusRequest& a, GetStatusRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetStatusRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetStatusRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetStatusRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetStatusRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const GetStatusRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const GetStatusRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "aggregator.v1.GetStatusRequest";
  }
  protected:
  explicit GetStatusRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:aggregator.v1.GetStatusRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_aggregator_2eproto;
};
// -------------------------------------------------------------------

class GenBatchProofRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aggregator.v1.GenBatchProofRequest) */ {
 public:
  inline GenBatchProofRequest() : GenBatchProofRequest(nullptr) {}
  ~GenBatchProofRequest() override;
  explicit PROTOBUF_CONSTEXPR GenBatchProofRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GenBatchProofRequest(const GenBatchProofRequest& from);
  GenBatchProofRequest(GenBatchProofRequest&& from) noexcept
    : GenBatchProofRequest() {
    *this = ::std::move(from);
  }

  inline GenBatchProofRequest& operator=(const GenBatchProofRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GenBatchProofRequest& operator=(GenBatchProofRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GenBatchProofRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GenBatchProofRequest* internal_default_instance() {
    return reinterpret_cast<const GenBatchProofRequest*>(
               &_GenBatchProofRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(GenBatchProofRequest& a, GenBatchProofRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GenBatchProofRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GenBatchProofRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GenBatchProofRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GenBatchProofRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GenBatchProofRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GenBatchProofRequest& from) {
    GenBatchProofRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GenBatchProofRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "aggregator.v1.GenBatchProofRequest";
  }
  protected:
  explicit GenBatchProofRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInputFieldNumber = 1,
  };
  // .aggregator.v1.InputProver input = 1;
  bool has_input() const;
  private:
  bool _internal_has_input() const;
  public:
  void clear_input();
  const ::aggregator::v1::InputProver& input() const;
  PROTOBUF_NODISCARD ::aggregator::v1::InputProver* release_input();
  ::aggregator::v1::InputProver* mutable_input();
  void set_allocated_input(::aggregator::v1::InputProver* input);
  private:
  const ::aggregator::v1::InputProver& _internal_input() const;
  ::aggregator::v1::InputProver* _internal_mutable_input();
  public:
  void unsafe_arena_set_allocated_input(
      ::aggregator::v1::InputProver* input);
  ::aggregator::v1::InputProver* unsafe_arena_release_input();

  // @@protoc_insertion_point(class_scope:aggregator.v1.GenBatchProofRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::aggregator::v1::InputProver* input_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_aggregator_2eproto;
};
// -------------------------------------------------------------------

class GenAggregatedProofRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aggregator.v1.GenAggregatedProofRequest) */ {
 public:
  inline GenAggregatedProofRequest() : GenAggregatedProofRequest(nullptr) {}
  ~GenAggregatedProofRequest() override;
  explicit PROTOBUF_CONSTEXPR GenAggregatedProofRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GenAggregatedProofRequest(const GenAggregatedProofRequest& from);
  GenAggregatedProofRequest(GenAggregatedProofRequest&& from) noexcept
    : GenAggregatedProofRequest() {
    *this = ::std::move(from);
  }

  inline GenAggregatedProofRequest& operator=(const GenAggregatedProofRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GenAggregatedProofRequest& operator=(GenAggregatedProofRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GenAggregatedProofRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GenAggregatedProofRequest* internal_default_instance() {
    return reinterpret_cast<const GenAggregatedProofRequest*>(
               &_GenAggregatedProofRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(GenAggregatedProofRequest& a, GenAggregatedProofRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GenAggregatedProofRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GenAggregatedProofRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GenAggregatedProofRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GenAggregatedProofRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GenAggregatedProofRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GenAggregatedProofRequest& from) {
    GenAggregatedProofRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GenAggregatedProofRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "aggregator.v1.GenAggregatedProofRequest";
  }
  protected:
  explicit GenAggregatedProofRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRecursiveProof1FieldNumber = 1,
    kRecursiveProof2FieldNumber = 2,
  };
  // string recursive_proof_1 = 1;
  void clear_recursive_proof_1();
  const std::string& recursive_proof_1() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_recursive_proof_1(ArgT0&& arg0, ArgT... args);
  std::string* mutable_recursive_proof_1();
  PROTOBUF_NODISCARD std::string* release_recursive_proof_1();
  void set_allocated_recursive_proof_1(std::string* recursive_proof_1);
  private:
  const std::string& _internal_recursive_proof_1() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_recursive_proof_1(const std::string& value);
  std::string* _internal_mutable_recursive_proof_1();
  public:

  // string recursive_proof_2 = 2;
  void clear_recursive_proof_2();
  const std::string& recursive_proof_2() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_recursive_proof_2(ArgT0&& arg0, ArgT... args);
  std::string* mutable_recursive_proof_2();
  PROTOBUF_NODISCARD std::string* release_recursive_proof_2();
  void set_allocated_recursive_proof_2(std::string* recursive_proof_2);
  private:
  const std::string& _internal_recursive_proof_2() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_recursive_proof_2(const std::string& value);
  std::string* _internal_mutable_recursive_proof_2();
  public:

  // @@protoc_insertion_point(class_scope:aggregator.v1.GenAggregatedProofRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr recursive_proof_1_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr recursive_proof_2_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_aggregator_2eproto;
};
// -------------------------------------------------------------------

class GenFinalProofRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aggregator.v1.GenFinalProofRequest) */ {
 public:
  inline GenFinalProofRequest() : GenFinalProofRequest(nullptr) {}
  ~GenFinalProofRequest() override;
  explicit PROTOBUF_CONSTEXPR GenFinalProofRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GenFinalProofRequest(const GenFinalProofRequest& from);
  GenFinalProofRequest(GenFinalProofRequest&& from) noexcept
    : GenFinalProofRequest() {
    *this = ::std::move(from);
  }

  inline GenFinalProofRequest& operator=(const GenFinalProofRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GenFinalProofRequest& operator=(GenFinalProofRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GenFinalProofRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GenFinalProofRequest* internal_default_instance() {
    return reinterpret_cast<const GenFinalProofRequest*>(
               &_GenFinalProofRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(GenFinalProofRequest& a, GenFinalProofRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GenFinalProofRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GenFinalProofRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GenFinalProofRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GenFinalProofRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GenFinalProofRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GenFinalProofRequest& from) {
    GenFinalProofRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GenFinalProofRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "aggregator.v1.GenFinalProofRequest";
  }
  protected:
  explicit GenFinalProofRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRecursiveProofFieldNumber = 1,
    kAggregatorAddrFieldNumber = 2,
  };
  // string recursive_proof = 1;
  void clear_recursive_proof();
  const std::string& recursive_proof() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_recursive_proof(ArgT0&& arg0, ArgT... args);
  std::string* mutable_recursive_proof();
  PROTOBUF_NODISCARD std::string* release_recursive_proof();
  void set_allocated_recursive_proof(std::string* recursive_proof);
  private:
  const std::string& _internal_recursive_proof() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_recursive_proof(const std::string& value);
  std::string* _internal_mutable_recursive_proof();
  public:

  // string aggregator_addr = 2;
  void clear_aggregator_addr();
  const std::string& aggregator_addr() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_aggregator_addr(ArgT0&& arg0, ArgT... args);
  std::string* mutable_aggregator_addr();
  PROTOBUF_NODISCARD std::string* release_aggregator_addr();
  void set_allocated_aggregator_addr(std::string* aggregator_addr);
  private:
  const std::string& _internal_aggregator_addr() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_aggregator_addr(const std::string& value);
  std::string* _internal_mutable_aggregator_addr();
  public:

  // @@protoc_insertion_point(class_scope:aggregator.v1.GenFinalProofRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr recursive_proof_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr aggregator_addr_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_aggregator_2eproto;
};
// -------------------------------------------------------------------

class CancelRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aggregator.v1.CancelRequest) */ {
 public:
  inline CancelRequest() : CancelRequest(nullptr) {}
  ~CancelRequest() override;
  explicit PROTOBUF_CONSTEXPR CancelRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CancelRequest(const CancelRequest& from);
  CancelRequest(CancelRequest&& from) noexcept
    : CancelRequest() {
    *this = ::std::move(from);
  }

  inline CancelRequest& operator=(const CancelRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CancelRequest& operator=(CancelRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CancelRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CancelRequest* internal_default_instance() {
    return reinterpret_cast<const CancelRequest*>(
               &_CancelRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(CancelRequest& a, CancelRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CancelRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CancelRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CancelRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CancelRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CancelRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CancelRequest& from) {
    CancelRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CancelRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "aggregator.v1.CancelRequest";
  }
  protected:
  explicit CancelRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // @@protoc_insertion_point(class_scope:aggregator.v1.CancelRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_aggregator_2eproto;
};
// -------------------------------------------------------------------

class GetProofRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aggregator.v1.GetProofRequest) */ {
 public:
  inline GetProofRequest() : GetProofRequest(nullptr) {}
  ~GetProofRequest() override;
  explicit PROTOBUF_CONSTEXPR GetProofRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetProofRequest(const GetProofRequest& from);
  GetProofRequest(GetProofRequest&& from) noexcept
    : GetProofRequest() {
    *this = ::std::move(from);
  }

  inline GetProofRequest& operator=(const GetProofRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetProofRequest& operator=(GetProofRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetProofRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetProofRequest* internal_default_instance() {
    return reinterpret_cast<const GetProofRequest*>(
               &_GetProofRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(GetProofRequest& a, GetProofRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetProofRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetProofRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetProofRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetProofRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetProofRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetProofRequest& from) {
    GetProofRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetProofRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "aggregator.v1.GetProofRequest";
  }
  protected:
  explicit GetProofRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kTimeoutFieldNumber = 2,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // uint64 timeout = 2;
  void clear_timeout();
  uint64_t timeout() const;
  void set_timeout(uint64_t value);
  private:
  uint64_t _internal_timeout() const;
  void _internal_set_timeout(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:aggregator.v1.GetProofRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    uint64_t timeout_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_aggregator_2eproto;
};
// -------------------------------------------------------------------

class GetStatusResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aggregator.v1.GetStatusResponse) */ {
 public:
  inline GetStatusResponse() : GetStatusResponse(nullptr) {}
  ~GetStatusResponse() override;
  explicit PROTOBUF_CONSTEXPR GetStatusResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetStatusResponse(const GetStatusResponse& from);
  GetStatusResponse(GetStatusResponse&& from) noexcept
    : GetStatusResponse() {
    *this = ::std::move(from);
  }

  inline GetStatusResponse& operator=(const GetStatusResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetStatusResponse& operator=(GetStatusResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetStatusResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetStatusResponse* internal_default_instance() {
    return reinterpret_cast<const GetStatusResponse*>(
               &_GetStatusResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(GetStatusResponse& a, GetStatusResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetStatusResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetStatusResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetStatusResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetStatusResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetStatusResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetStatusResponse& from) {
    GetStatusResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetStatusResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "aggregator.v1.GetStatusResponse";
  }
  protected:
  explicit GetStatusResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef GetStatusResponse_Status Status;
  static constexpr Status STATUS_UNSPECIFIED =
    GetStatusResponse_Status_STATUS_UNSPECIFIED;
  static constexpr Status STATUS_BOOTING =
    GetStatusResponse_Status_STATUS_BOOTING;
  static constexpr Status STATUS_COMPUTING =
    GetStatusResponse_Status_STATUS_COMPUTING;
  static constexpr Status STATUS_IDLE =
    GetStatusResponse_Status_STATUS_IDLE;
  static constexpr Status STATUS_HALT =
    GetStatusResponse_Status_STATUS_HALT;
  static inline bool Status_IsValid(int value) {
    return GetStatusResponse_Status_IsValid(value);
  }
  static constexpr Status Status_MIN =
    GetStatusResponse_Status_Status_MIN;
  static constexpr Status Status_MAX =
    GetStatusResponse_Status_Status_MAX;
  static constexpr int Status_ARRAYSIZE =
    GetStatusResponse_Status_Status_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Status_descriptor() {
    return GetStatusResponse_Status_descriptor();
  }
  template<typename T>
  static inline const std::string& Status_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Status>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Status_Name.");
    return GetStatusResponse_Status_Name(enum_t_value);
  }
  static inline bool Status_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Status* value) {
    return GetStatusResponse_Status_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kPendingRequestQueueIdsFieldNumber = 8,
    kLastComputedRequestIdFieldNumber = 2,
    kCurrentComputingRequestIdFieldNumber = 4,
    kVersionProtoFieldNumber = 6,
    kVersionServerFieldNumber = 7,
    kProverNameFieldNumber = 9,
    kProverIdFieldNumber = 10,
    kLastComputedEndTimeFieldNumber = 3,
    kCurrentComputingStartTimeFieldNumber = 5,
    kNumberOfCoresFieldNumber = 11,
    kTotalMemoryFieldNumber = 12,
    kFreeMemoryFieldNumber = 13,
    kForkIdFieldNumber = 14,
    kStatusFieldNumber = 1,
  };
  // repeated string pending_request_queue_ids = 8;
  int pending_request_queue_ids_size() const;
  private:
  int _internal_pending_request_queue_ids_size() const;
  public:
  void clear_pending_request_queue_ids();
  const std::string& pending_request_queue_ids(int index) const;
  std::string* mutable_pending_request_queue_ids(int index);
  void set_pending_request_queue_ids(int index, const std::string& value);
  void set_pending_request_queue_ids(int index, std::string&& value);
  void set_pending_request_queue_ids(int index, const char* value);
  void set_pending_request_queue_ids(int index, const char* value, size_t size);
  std::string* add_pending_request_queue_ids();
  void add_pending_request_queue_ids(const std::string& value);
  void add_pending_request_queue_ids(std::string&& value);
  void add_pending_request_queue_ids(const char* value);
  void add_pending_request_queue_ids(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& pending_request_queue_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_pending_request_queue_ids();
  private:
  const std::string& _internal_pending_request_queue_ids(int index) const;
  std::string* _internal_add_pending_request_queue_ids();
  public:

  // string last_computed_request_id = 2;
  void clear_last_computed_request_id();
  const std::string& last_computed_request_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_last_computed_request_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_last_computed_request_id();
  PROTOBUF_NODISCARD std::string* release_last_computed_request_id();
  void set_allocated_last_computed_request_id(std::string* last_computed_request_id);
  private:
  const std::string& _internal_last_computed_request_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_last_computed_request_id(const std::string& value);
  std::string* _internal_mutable_last_computed_request_id();
  public:

  // string current_computing_request_id = 4;
  void clear_current_computing_request_id();
  const std::string& current_computing_request_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_current_computing_request_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_current_computing_request_id();
  PROTOBUF_NODISCARD std::string* release_current_computing_request_id();
  void set_allocated_current_computing_request_id(std::string* current_computing_request_id);
  private:
  const std::string& _internal_current_computing_request_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_current_computing_request_id(const std::string& value);
  std::string* _internal_mutable_current_computing_request_id();
  public:

  // string version_proto = 6;
  void clear_version_proto();
  const std::string& version_proto() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version_proto(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version_proto();
  PROTOBUF_NODISCARD std::string* release_version_proto();
  void set_allocated_version_proto(std::string* version_proto);
  private:
  const std::string& _internal_version_proto() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version_proto(const std::string& value);
  std::string* _internal_mutable_version_proto();
  public:

  // string version_server = 7;
  void clear_version_server();
  const std::string& version_server() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version_server(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version_server();
  PROTOBUF_NODISCARD std::string* release_version_server();
  void set_allocated_version_server(std::string* version_server);
  private:
  const std::string& _internal_version_server() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version_server(const std::string& value);
  std::string* _internal_mutable_version_server();
  public:

  // string prover_name = 9;
  void clear_prover_name();
  const std::string& prover_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_prover_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_prover_name();
  PROTOBUF_NODISCARD std::string* release_prover_name();
  void set_allocated_prover_name(std::string* prover_name);
  private:
  const std::string& _internal_prover_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_prover_name(const std::string& value);
  std::string* _internal_mutable_prover_name();
  public:

  // string prover_id = 10;
  void clear_prover_id();
  const std::string& prover_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_prover_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_prover_id();
  PROTOBUF_NODISCARD std::string* release_prover_id();
  void set_allocated_prover_id(std::string* prover_id);
  private:
  const std::string& _internal_prover_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_prover_id(const std::string& value);
  std::string* _internal_mutable_prover_id();
  public:

  // uint64 last_computed_end_time = 3;
  void clear_last_computed_end_time();
  uint64_t last_computed_end_time() const;
  void set_last_computed_end_time(uint64_t value);
  private:
  uint64_t _internal_last_computed_end_time() const;
  void _internal_set_last_computed_end_time(uint64_t value);
  public:

  // uint64 current_computing_start_time = 5;
  void clear_current_computing_start_time();
  uint64_t current_computing_start_time() const;
  void set_current_computing_start_time(uint64_t value);
  private:
  uint64_t _internal_current_computing_start_time() const;
  void _internal_set_current_computing_start_time(uint64_t value);
  public:

  // uint64 number_of_cores = 11;
  void clear_number_of_cores();
  uint64_t number_of_cores() const;
  void set_number_of_cores(uint64_t value);
  private:
  uint64_t _internal_number_of_cores() const;
  void _internal_set_number_of_cores(uint64_t value);
  public:

  // uint64 total_memory = 12;
  void clear_total_memory();
  uint64_t total_memory() const;
  void set_total_memory(uint64_t value);
  private:
  uint64_t _internal_total_memory() const;
  void _internal_set_total_memory(uint64_t value);
  public:

  // uint64 free_memory = 13;
  void clear_free_memory();
  uint64_t free_memory() const;
  void set_free_memory(uint64_t value);
  private:
  uint64_t _internal_free_memory() const;
  void _internal_set_free_memory(uint64_t value);
  public:

  // uint64 fork_id = 14;
  void clear_fork_id();
  uint64_t fork_id() const;
  void set_fork_id(uint64_t value);
  private:
  uint64_t _internal_fork_id() const;
  void _internal_set_fork_id(uint64_t value);
  public:

  // .aggregator.v1.GetStatusResponse.Status status = 1;
  void clear_status();
  ::aggregator::v1::GetStatusResponse_Status status() const;
  void set_status(::aggregator::v1::GetStatusResponse_Status value);
  private:
  ::aggregator::v1::GetStatusResponse_Status _internal_status() const;
  void _internal_set_status(::aggregator::v1::GetStatusResponse_Status value);
  public:

  // @@protoc_insertion_point(class_scope:aggregator.v1.GetStatusResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> pending_request_queue_ids_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr last_computed_request_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr current_computing_request_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_proto_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_server_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr prover_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr prover_id_;
    uint64_t last_computed_end_time_;
    uint64_t current_computing_start_time_;
    uint64_t number_of_cores_;
    uint64_t total_memory_;
    uint64_t free_memory_;
    uint64_t fork_id_;
    int status_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_aggregator_2eproto;
};
// -------------------------------------------------------------------

class GenBatchProofResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aggregator.v1.GenBatchProofResponse) */ {
 public:
  inline GenBatchProofResponse() : GenBatchProofResponse(nullptr) {}
  ~GenBatchProofResponse() override;
  explicit PROTOBUF_CONSTEXPR GenBatchProofResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GenBatchProofResponse(const GenBatchProofResponse& from);
  GenBatchProofResponse(GenBatchProofResponse&& from) noexcept
    : GenBatchProofResponse() {
    *this = ::std::move(from);
  }

  inline GenBatchProofResponse& operator=(const GenBatchProofResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GenBatchProofResponse& operator=(GenBatchProofResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GenBatchProofResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GenBatchProofResponse* internal_default_instance() {
    return reinterpret_cast<const GenBatchProofResponse*>(
               &_GenBatchProofResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(GenBatchProofResponse& a, GenBatchProofResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GenBatchProofResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GenBatchProofResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GenBatchProofResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GenBatchProofResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GenBatchProofResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GenBatchProofResponse& from) {
    GenBatchProofResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GenBatchProofResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "aggregator.v1.GenBatchProofResponse";
  }
  protected:
  explicit GenBatchProofResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kResultFieldNumber = 2,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // .aggregator.v1.Result result = 2;
  void clear_result();
  ::aggregator::v1::Result result() const;
  void set_result(::aggregator::v1::Result value);
  private:
  ::aggregator::v1::Result _internal_result() const;
  void _internal_set_result(::aggregator::v1::Result value);
  public:

  // @@protoc_insertion_point(class_scope:aggregator.v1.GenBatchProofResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    int result_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_aggregator_2eproto;
};
// -------------------------------------------------------------------

class GenAggregatedProofResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aggregator.v1.GenAggregatedProofResponse) */ {
 public:
  inline GenAggregatedProofResponse() : GenAggregatedProofResponse(nullptr) {}
  ~GenAggregatedProofResponse() override;
  explicit PROTOBUF_CONSTEXPR GenAggregatedProofResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GenAggregatedProofResponse(const GenAggregatedProofResponse& from);
  GenAggregatedProofResponse(GenAggregatedProofResponse&& from) noexcept
    : GenAggregatedProofResponse() {
    *this = ::std::move(from);
  }

  inline GenAggregatedProofResponse& operator=(const GenAggregatedProofResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GenAggregatedProofResponse& operator=(GenAggregatedProofResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GenAggregatedProofResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GenAggregatedProofResponse* internal_default_instance() {
    return reinterpret_cast<const GenAggregatedProofResponse*>(
               &_GenAggregatedProofResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(GenAggregatedProofResponse& a, GenAggregatedProofResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GenAggregatedProofResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GenAggregatedProofResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GenAggregatedProofResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GenAggregatedProofResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GenAggregatedProofResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GenAggregatedProofResponse& from) {
    GenAggregatedProofResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GenAggregatedProofResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "aggregator.v1.GenAggregatedProofResponse";
  }
  protected:
  explicit GenAggregatedProofResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kResultFieldNumber = 2,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // .aggregator.v1.Result result = 2;
  void clear_result();
  ::aggregator::v1::Result result() const;
  void set_result(::aggregator::v1::Result value);
  private:
  ::aggregator::v1::Result _internal_result() const;
  void _internal_set_result(::aggregator::v1::Result value);
  public:

  // @@protoc_insertion_point(class_scope:aggregator.v1.GenAggregatedProofResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    int result_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_aggregator_2eproto;
};
// -------------------------------------------------------------------

class GenFinalProofResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aggregator.v1.GenFinalProofResponse) */ {
 public:
  inline GenFinalProofResponse() : GenFinalProofResponse(nullptr) {}
  ~GenFinalProofResponse() override;
  explicit PROTOBUF_CONSTEXPR GenFinalProofResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GenFinalProofResponse(const GenFinalProofResponse& from);
  GenFinalProofResponse(GenFinalProofResponse&& from) noexcept
    : GenFinalProofResponse() {
    *this = ::std::move(from);
  }

  inline GenFinalProofResponse& operator=(const GenFinalProofResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GenFinalProofResponse& operator=(GenFinalProofResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GenFinalProofResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GenFinalProofResponse* internal_default_instance() {
    return reinterpret_cast<const GenFinalProofResponse*>(
               &_GenFinalProofResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(GenFinalProofResponse& a, GenFinalProofResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GenFinalProofResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GenFinalProofResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GenFinalProofResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GenFinalProofResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GenFinalProofResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GenFinalProofResponse& from) {
    GenFinalProofResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GenFinalProofResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "aggregator.v1.GenFinalProofResponse";
  }
  protected:
  explicit GenFinalProofResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kResultFieldNumber = 2,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // .aggregator.v1.Result result = 2;
  void clear_result();
  ::aggregator::v1::Result result() const;
  void set_result(::aggregator::v1::Result value);
  private:
  ::aggregator::v1::Result _internal_result() const;
  void _internal_set_result(::aggregator::v1::Result value);
  public:

  // @@protoc_insertion_point(class_scope:aggregator.v1.GenFinalProofResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    int result_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_aggregator_2eproto;
};
// -------------------------------------------------------------------

class CancelResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aggregator.v1.CancelResponse) */ {
 public:
  inline CancelResponse() : CancelResponse(nullptr) {}
  ~CancelResponse() override;
  explicit PROTOBUF_CONSTEXPR CancelResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CancelResponse(const CancelResponse& from);
  CancelResponse(CancelResponse&& from) noexcept
    : CancelResponse() {
    *this = ::std::move(from);
  }

  inline CancelResponse& operator=(const CancelResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CancelResponse& operator=(CancelResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CancelResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CancelResponse* internal_default_instance() {
    return reinterpret_cast<const CancelResponse*>(
               &_CancelResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(CancelResponse& a, CancelResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CancelResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CancelResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CancelResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CancelResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CancelResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CancelResponse& from) {
    CancelResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CancelResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "aggregator.v1.CancelResponse";
  }
  protected:
  explicit CancelResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultFieldNumber = 1,
  };
  // .aggregator.v1.Result result = 1;
  void clear_result();
  ::aggregator::v1::Result result() const;
  void set_result(::aggregator::v1::Result value);
  private:
  ::aggregator::v1::Result _internal_result() const;
  void _internal_set_result(::aggregator::v1::Result value);
  public:

  // @@protoc_insertion_point(class_scope:aggregator.v1.CancelResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int result_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_aggregator_2eproto;
};
// -------------------------------------------------------------------

class GetProofResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aggregator.v1.GetProofResponse) */ {
 public:
  inline GetProofResponse() : GetProofResponse(nullptr) {}
  ~GetProofResponse() override;
  explicit PROTOBUF_CONSTEXPR GetProofResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetProofResponse(const GetProofResponse& from);
  GetProofResponse(GetProofResponse&& from) noexcept
    : GetProofResponse() {
    *this = ::std::move(from);
  }

  inline GetProofResponse& operator=(const GetProofResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetProofResponse& operator=(GetProofResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetProofResponse& default_instance() {
    return *internal_default_instance();
  }
  enum ProofCase {
    kFinalProof = 2,
    kRecursiveProof = 3,
    PROOF_NOT_SET = 0,
  };

  static inline const GetProofResponse* internal_default_instance() {
    return reinterpret_cast<const GetProofResponse*>(
               &_GetProofResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(GetProofResponse& a, GetProofResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetProofResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetProofResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetProofResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetProofResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetProofResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetProofResponse& from) {
    GetProofResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetProofResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "aggregator.v1.GetProofResponse";
  }
  protected:
  explicit GetProofResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef GetProofResponse_Result Result;
  static constexpr Result RESULT_UNSPECIFIED =
    GetProofResponse_Result_RESULT_UNSPECIFIED;
  static constexpr Result RESULT_COMPLETED_OK =
    GetProofResponse_Result_RESULT_COMPLETED_OK;
  static constexpr Result RESULT_ERROR =
    GetProofResponse_Result_RESULT_ERROR;
  static constexpr Result RESULT_COMPLETED_ERROR =
    GetProofResponse_Result_RESULT_COMPLETED_ERROR;
  static constexpr Result RESULT_PENDING =
    GetProofResponse_Result_RESULT_PENDING;
  static constexpr Result RESULT_INTERNAL_ERROR =
    GetProofResponse_Result_RESULT_INTERNAL_ERROR;
  static constexpr Result RESULT_CANCEL =
    GetProofResponse_Result_RESULT_CANCEL;
  static inline bool Result_IsValid(int value) {
    return GetProofResponse_Result_IsValid(value);
  }
  static constexpr Result Result_MIN =
    GetProofResponse_Result_Result_MIN;
  static constexpr Result Result_MAX =
    GetProofResponse_Result_Result_MAX;
  static constexpr int Result_ARRAYSIZE =
    GetProofResponse_Result_Result_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Result_descriptor() {
    return GetProofResponse_Result_descriptor();
  }
  template<typename T>
  static inline const std::string& Result_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Result>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Result_Name.");
    return GetProofResponse_Result_Name(enum_t_value);
  }
  static inline bool Result_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Result* value) {
    return GetProofResponse_Result_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kResultStringFieldNumber = 5,
    kResultFieldNumber = 4,
    kFinalProofFieldNumber = 2,
    kRecursiveProofFieldNumber = 3,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string result_string = 5;
  void clear_result_string();
  const std::string& result_string() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_result_string(ArgT0&& arg0, ArgT... args);
  std::string* mutable_result_string();
  PROTOBUF_NODISCARD std::string* release_result_string();
  void set_allocated_result_string(std::string* result_string);
  private:
  const std::string& _internal_result_string() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_result_string(const std::string& value);
  std::string* _internal_mutable_result_string();
  public:

  // .aggregator.v1.GetProofResponse.Result result = 4;
  void clear_result();
  ::aggregator::v1::GetProofResponse_Result result() const;
  void set_result(::aggregator::v1::GetProofResponse_Result value);
  private:
  ::aggregator::v1::GetProofResponse_Result _internal_result() const;
  void _internal_set_result(::aggregator::v1::GetProofResponse_Result value);
  public:

  // .aggregator.v1.FinalProof final_proof = 2;
  bool has_final_proof() const;
  private:
  bool _internal_has_final_proof() const;
  public:
  void clear_final_proof();
  const ::aggregator::v1::FinalProof& final_proof() const;
  PROTOBUF_NODISCARD ::aggregator::v1::FinalProof* release_final_proof();
  ::aggregator::v1::FinalProof* mutable_final_proof();
  void set_allocated_final_proof(::aggregator::v1::FinalProof* final_proof);
  private:
  const ::aggregator::v1::FinalProof& _internal_final_proof() const;
  ::aggregator::v1::FinalProof* _internal_mutable_final_proof();
  public:
  void unsafe_arena_set_allocated_final_proof(
      ::aggregator::v1::FinalProof* final_proof);
  ::aggregator::v1::FinalProof* unsafe_arena_release_final_proof();

  // string recursive_proof = 3;
  bool has_recursive_proof() const;
  private:
  bool _internal_has_recursive_proof() const;
  public:
  void clear_recursive_proof();
  const std::string& recursive_proof() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_recursive_proof(ArgT0&& arg0, ArgT... args);
  std::string* mutable_recursive_proof();
  PROTOBUF_NODISCARD std::string* release_recursive_proof();
  void set_allocated_recursive_proof(std::string* recursive_proof);
  private:
  const std::string& _internal_recursive_proof() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_recursive_proof(const std::string& value);
  std::string* _internal_mutable_recursive_proof();
  public:

  void clear_proof();
  ProofCase proof_case() const;
  // @@protoc_insertion_point(class_scope:aggregator.v1.GetProofResponse)
 private:
  class _Internal;
  void set_has_final_proof();
  void set_has_recursive_proof();

  inline bool has_proof() const;
  inline void clear_has_proof();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr result_string_;
    int result_;
    union ProofUnion {
      constexpr ProofUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::aggregator::v1::FinalProof* final_proof_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr recursive_proof_;
    } proof_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_aggregator_2eproto;
};
// -------------------------------------------------------------------

class FinalProof final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aggregator.v1.FinalProof) */ {
 public:
  inline FinalProof() : FinalProof(nullptr) {}
  ~FinalProof() override;
  explicit PROTOBUF_CONSTEXPR FinalProof(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FinalProof(const FinalProof& from);
  FinalProof(FinalProof&& from) noexcept
    : FinalProof() {
    *this = ::std::move(from);
  }

  inline FinalProof& operator=(const FinalProof& from) {
    CopyFrom(from);
    return *this;
  }
  inline FinalProof& operator=(FinalProof&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FinalProof& default_instance() {
    return *internal_default_instance();
  }
  static inline const FinalProof* internal_default_instance() {
    return reinterpret_cast<const FinalProof*>(
               &_FinalProof_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(FinalProof& a, FinalProof& b) {
    a.Swap(&b);
  }
  inline void Swap(FinalProof* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FinalProof* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FinalProof* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FinalProof>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FinalProof& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FinalProof& from) {
    FinalProof::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FinalProof* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "aggregator.v1.FinalProof";
  }
  protected:
  explicit FinalProof(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProofFieldNumber = 1,
    kPublicFieldNumber = 2,
  };
  // string proof = 1;
  void clear_proof();
  const std::string& proof() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_proof(ArgT0&& arg0, ArgT... args);
  std::string* mutable_proof();
  PROTOBUF_NODISCARD std::string* release_proof();
  void set_allocated_proof(std::string* proof);
  private:
  const std::string& _internal_proof() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_proof(const std::string& value);
  std::string* _internal_mutable_proof();
  public:

  // .aggregator.v1.PublicInputsExtended public = 2;
  bool has_public_() const;
  private:
  bool _internal_has_public_() const;
  public:
  void clear_public_();
  const ::aggregator::v1::PublicInputsExtended& public_() const;
  PROTOBUF_NODISCARD ::aggregator::v1::PublicInputsExtended* release_public_();
  ::aggregator::v1::PublicInputsExtended* mutable_public_();
  void set_allocated_public_(::aggregator::v1::PublicInputsExtended* public_);
  private:
  const ::aggregator::v1::PublicInputsExtended& _internal_public_() const;
  ::aggregator::v1::PublicInputsExtended* _internal_mutable_public_();
  public:
  void unsafe_arena_set_allocated_public_(
      ::aggregator::v1::PublicInputsExtended* public_);
  ::aggregator::v1::PublicInputsExtended* unsafe_arena_release_public_();

  // @@protoc_insertion_point(class_scope:aggregator.v1.FinalProof)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr proof_;
    ::aggregator::v1::PublicInputsExtended* public__;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_aggregator_2eproto;
};
// -------------------------------------------------------------------

class PublicInputs final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aggregator.v1.PublicInputs) */ {
 public:
  inline PublicInputs() : PublicInputs(nullptr) {}
  ~PublicInputs() override;
  explicit PROTOBUF_CONSTEXPR PublicInputs(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PublicInputs(const PublicInputs& from);
  PublicInputs(PublicInputs&& from) noexcept
    : PublicInputs() {
    *this = ::std::move(from);
  }

  inline PublicInputs& operator=(const PublicInputs& from) {
    CopyFrom(from);
    return *this;
  }
  inline PublicInputs& operator=(PublicInputs&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PublicInputs& default_instance() {
    return *internal_default_instance();
  }
  static inline const PublicInputs* internal_default_instance() {
    return reinterpret_cast<const PublicInputs*>(
               &_PublicInputs_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(PublicInputs& a, PublicInputs& b) {
    a.Swap(&b);
  }
  inline void Swap(PublicInputs* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PublicInputs* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PublicInputs* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PublicInputs>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PublicInputs& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PublicInputs& from) {
    PublicInputs::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PublicInputs* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "aggregator.v1.PublicInputs";
  }
  protected:
  explicit PublicInputs(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOldStateRootFieldNumber = 1,
    kOldAccInputHashFieldNumber = 2,
    kBatchL2DataFieldNumber = 6,
    kGlobalExitRootFieldNumber = 7,
    kSequencerAddrFieldNumber = 9,
    kAggregatorAddrFieldNumber = 10,
    kOldBatchNumFieldNumber = 3,
    kChainIdFieldNumber = 4,
    kForkIdFieldNumber = 5,
    kEthTimestampFieldNumber = 8,
  };
  // bytes old_state_root = 1;
  void clear_old_state_root();
  const std::string& old_state_root() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_old_state_root(ArgT0&& arg0, ArgT... args);
  std::string* mutable_old_state_root();
  PROTOBUF_NODISCARD std::string* release_old_state_root();
  void set_allocated_old_state_root(std::string* old_state_root);
  private:
  const std::string& _internal_old_state_root() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_old_state_root(const std::string& value);
  std::string* _internal_mutable_old_state_root();
  public:

  // bytes old_acc_input_hash = 2;
  void clear_old_acc_input_hash();
  const std::string& old_acc_input_hash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_old_acc_input_hash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_old_acc_input_hash();
  PROTOBUF_NODISCARD std::string* release_old_acc_input_hash();
  void set_allocated_old_acc_input_hash(std::string* old_acc_input_hash);
  private:
  const std::string& _internal_old_acc_input_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_old_acc_input_hash(const std::string& value);
  std::string* _internal_mutable_old_acc_input_hash();
  public:

  // bytes batch_l2_data = 6;
  void clear_batch_l2_data();
  const std::string& batch_l2_data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_batch_l2_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_batch_l2_data();
  PROTOBUF_NODISCARD std::string* release_batch_l2_data();
  void set_allocated_batch_l2_data(std::string* batch_l2_data);
  private:
  const std::string& _internal_batch_l2_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_batch_l2_data(const std::string& value);
  std::string* _internal_mutable_batch_l2_data();
  public:

  // bytes global_exit_root = 7;
  void clear_global_exit_root();
  const std::string& global_exit_root() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_global_exit_root(ArgT0&& arg0, ArgT... args);
  std::string* mutable_global_exit_root();
  PROTOBUF_NODISCARD std::string* release_global_exit_root();
  void set_allocated_global_exit_root(std::string* global_exit_root);
  private:
  const std::string& _internal_global_exit_root() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_global_exit_root(const std::string& value);
  std::string* _internal_mutable_global_exit_root();
  public:

  // string sequencer_addr = 9;
  void clear_sequencer_addr();
  const std::string& sequencer_addr() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sequencer_addr(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sequencer_addr();
  PROTOBUF_NODISCARD std::string* release_sequencer_addr();
  void set_allocated_sequencer_addr(std::string* sequencer_addr);
  private:
  const std::string& _internal_sequencer_addr() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sequencer_addr(const std::string& value);
  std::string* _internal_mutable_sequencer_addr();
  public:

  // string aggregator_addr = 10;
  void clear_aggregator_addr();
  const std::string& aggregator_addr() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_aggregator_addr(ArgT0&& arg0, ArgT... args);
  std::string* mutable_aggregator_addr();
  PROTOBUF_NODISCARD std::string* release_aggregator_addr();
  void set_allocated_aggregator_addr(std::string* aggregator_addr);
  private:
  const std::string& _internal_aggregator_addr() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_aggregator_addr(const std::string& value);
  std::string* _internal_mutable_aggregator_addr();
  public:

  // uint64 old_batch_num = 3;
  void clear_old_batch_num();
  uint64_t old_batch_num() const;
  void set_old_batch_num(uint64_t value);
  private:
  uint64_t _internal_old_batch_num() const;
  void _internal_set_old_batch_num(uint64_t value);
  public:

  // uint64 chain_id = 4;
  void clear_chain_id();
  uint64_t chain_id() const;
  void set_chain_id(uint64_t value);
  private:
  uint64_t _internal_chain_id() const;
  void _internal_set_chain_id(uint64_t value);
  public:

  // uint64 fork_id = 5;
  void clear_fork_id();
  uint64_t fork_id() const;
  void set_fork_id(uint64_t value);
  private:
  uint64_t _internal_fork_id() const;
  void _internal_set_fork_id(uint64_t value);
  public:

  // uint64 eth_timestamp = 8;
  void clear_eth_timestamp();
  uint64_t eth_timestamp() const;
  void set_eth_timestamp(uint64_t value);
  private:
  uint64_t _internal_eth_timestamp() const;
  void _internal_set_eth_timestamp(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:aggregator.v1.PublicInputs)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr old_state_root_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr old_acc_input_hash_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr batch_l2_data_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr global_exit_root_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sequencer_addr_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr aggregator_addr_;
    uint64_t old_batch_num_;
    uint64_t chain_id_;
    uint64_t fork_id_;
    uint64_t eth_timestamp_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_aggregator_2eproto;
};
// -------------------------------------------------------------------

class InputProver_DbEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<InputProver_DbEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<InputProver_DbEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  InputProver_DbEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR InputProver_DbEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit InputProver_DbEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const InputProver_DbEntry_DoNotUse& other);
  static const InputProver_DbEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const InputProver_DbEntry_DoNotUse*>(&_InputProver_DbEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "aggregator.v1.InputProver.DbEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "aggregator.v1.InputProver.DbEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_aggregator_2eproto;
};

// -------------------------------------------------------------------

class InputProver_ContractsBytecodeEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<InputProver_ContractsBytecodeEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<InputProver_ContractsBytecodeEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  InputProver_ContractsBytecodeEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR InputProver_ContractsBytecodeEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit InputProver_ContractsBytecodeEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const InputProver_ContractsBytecodeEntry_DoNotUse& other);
  static const InputProver_ContractsBytecodeEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const InputProver_ContractsBytecodeEntry_DoNotUse*>(&_InputProver_ContractsBytecodeEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "aggregator.v1.InputProver.ContractsBytecodeEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "aggregator.v1.InputProver.ContractsBytecodeEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_aggregator_2eproto;
};

// -------------------------------------------------------------------

class InputProver final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aggregator.v1.InputProver) */ {
 public:
  inline InputProver() : InputProver(nullptr) {}
  ~InputProver() override;
  explicit PROTOBUF_CONSTEXPR InputProver(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InputProver(const InputProver& from);
  InputProver(InputProver&& from) noexcept
    : InputProver() {
    *this = ::std::move(from);
  }

  inline InputProver& operator=(const InputProver& from) {
    CopyFrom(from);
    return *this;
  }
  inline InputProver& operator=(InputProver&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InputProver& default_instance() {
    return *internal_default_instance();
  }
  static inline const InputProver* internal_default_instance() {
    return reinterpret_cast<const InputProver*>(
               &_InputProver_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(InputProver& a, InputProver& b) {
    a.Swap(&b);
  }
  inline void Swap(InputProver* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InputProver* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InputProver* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InputProver>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InputProver& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const InputProver& from) {
    InputProver::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InputProver* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "aggregator.v1.InputProver";
  }
  protected:
  explicit InputProver(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kDbFieldNumber = 4,
    kContractsBytecodeFieldNumber = 5,
    kPublicInputsFieldNumber = 1,
  };
  // map<string, string> db = 4;
  int db_size() const;
  private:
  int _internal_db_size() const;
  public:
  void clear_db();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_db() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_db();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      db() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_db();

  // map<string, string> contracts_bytecode = 5;
  int contracts_bytecode_size() const;
  private:
  int _internal_contracts_bytecode_size() const;
  public:
  void clear_contracts_bytecode();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_contracts_bytecode() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_contracts_bytecode();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      contracts_bytecode() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_contracts_bytecode();

  // .aggregator.v1.PublicInputs public_inputs = 1;
  bool has_public_inputs() const;
  private:
  bool _internal_has_public_inputs() const;
  public:
  void clear_public_inputs();
  const ::aggregator::v1::PublicInputs& public_inputs() const;
  PROTOBUF_NODISCARD ::aggregator::v1::PublicInputs* release_public_inputs();
  ::aggregator::v1::PublicInputs* mutable_public_inputs();
  void set_allocated_public_inputs(::aggregator::v1::PublicInputs* public_inputs);
  private:
  const ::aggregator::v1::PublicInputs& _internal_public_inputs() const;
  ::aggregator::v1::PublicInputs* _internal_mutable_public_inputs();
  public:
  void unsafe_arena_set_allocated_public_inputs(
      ::aggregator::v1::PublicInputs* public_inputs);
  ::aggregator::v1::PublicInputs* unsafe_arena_release_public_inputs();

  // @@protoc_insertion_point(class_scope:aggregator.v1.InputProver)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        InputProver_DbEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> db_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        InputProver_ContractsBytecodeEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> contracts_bytecode_;
    ::aggregator::v1::PublicInputs* public_inputs_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_aggregator_2eproto;
};
// -------------------------------------------------------------------

class PublicInputsExtended final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aggregator.v1.PublicInputsExtended) */ {
 public:
  inline PublicInputsExtended() : PublicInputsExtended(nullptr) {}
  ~PublicInputsExtended() override;
  explicit PROTOBUF_CONSTEXPR PublicInputsExtended(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PublicInputsExtended(const PublicInputsExtended& from);
  PublicInputsExtended(PublicInputsExtended&& from) noexcept
    : PublicInputsExtended() {
    *this = ::std::move(from);
  }

  inline PublicInputsExtended& operator=(const PublicInputsExtended& from) {
    CopyFrom(from);
    return *this;
  }
  inline PublicInputsExtended& operator=(PublicInputsExtended&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PublicInputsExtended& default_instance() {
    return *internal_default_instance();
  }
  static inline const PublicInputsExtended* internal_default_instance() {
    return reinterpret_cast<const PublicInputsExtended*>(
               &_PublicInputsExtended_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(PublicInputsExtended& a, PublicInputsExtended& b) {
    a.Swap(&b);
  }
  inline void Swap(PublicInputsExtended* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PublicInputsExtended* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PublicInputsExtended* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PublicInputsExtended>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PublicInputsExtended& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PublicInputsExtended& from) {
    PublicInputsExtended::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PublicInputsExtended* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "aggregator.v1.PublicInputsExtended";
  }
  protected:
  explicit PublicInputsExtended(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNewStateRootFieldNumber = 2,
    kNewAccInputHashFieldNumber = 3,
    kNewLocalExitRootFieldNumber = 4,
    kPublicInputsFieldNumber = 1,
    kNewBatchNumFieldNumber = 5,
  };
  // bytes new_state_root = 2;
  void clear_new_state_root();
  const std::string& new_state_root() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_new_state_root(ArgT0&& arg0, ArgT... args);
  std::string* mutable_new_state_root();
  PROTOBUF_NODISCARD std::string* release_new_state_root();
  void set_allocated_new_state_root(std::string* new_state_root);
  private:
  const std::string& _internal_new_state_root() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_new_state_root(const std::string& value);
  std::string* _internal_mutable_new_state_root();
  public:

  // bytes new_acc_input_hash = 3;
  void clear_new_acc_input_hash();
  const std::string& new_acc_input_hash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_new_acc_input_hash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_new_acc_input_hash();
  PROTOBUF_NODISCARD std::string* release_new_acc_input_hash();
  void set_allocated_new_acc_input_hash(std::string* new_acc_input_hash);
  private:
  const std::string& _internal_new_acc_input_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_new_acc_input_hash(const std::string& value);
  std::string* _internal_mutable_new_acc_input_hash();
  public:

  // bytes new_local_exit_root = 4;
  void clear_new_local_exit_root();
  const std::string& new_local_exit_root() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_new_local_exit_root(ArgT0&& arg0, ArgT... args);
  std::string* mutable_new_local_exit_root();
  PROTOBUF_NODISCARD std::string* release_new_local_exit_root();
  void set_allocated_new_local_exit_root(std::string* new_local_exit_root);
  private:
  const std::string& _internal_new_local_exit_root() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_new_local_exit_root(const std::string& value);
  std::string* _internal_mutable_new_local_exit_root();
  public:

  // .aggregator.v1.PublicInputs public_inputs = 1;
  bool has_public_inputs() const;
  private:
  bool _internal_has_public_inputs() const;
  public:
  void clear_public_inputs();
  const ::aggregator::v1::PublicInputs& public_inputs() const;
  PROTOBUF_NODISCARD ::aggregator::v1::PublicInputs* release_public_inputs();
  ::aggregator::v1::PublicInputs* mutable_public_inputs();
  void set_allocated_public_inputs(::aggregator::v1::PublicInputs* public_inputs);
  private:
  const ::aggregator::v1::PublicInputs& _internal_public_inputs() const;
  ::aggregator::v1::PublicInputs* _internal_mutable_public_inputs();
  public:
  void unsafe_arena_set_allocated_public_inputs(
      ::aggregator::v1::PublicInputs* public_inputs);
  ::aggregator::v1::PublicInputs* unsafe_arena_release_public_inputs();

  // uint64 new_batch_num = 5;
  void clear_new_batch_num();
  uint64_t new_batch_num() const;
  void set_new_batch_num(uint64_t value);
  private:
  uint64_t _internal_new_batch_num() const;
  void _internal_set_new_batch_num(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:aggregator.v1.PublicInputsExtended)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr new_state_root_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr new_acc_input_hash_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr new_local_exit_root_;
    ::aggregator::v1::PublicInputs* public_inputs_;
    uint64_t new_batch_num_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_aggregator_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Version

// string v0_0_1 = 1;
inline void Version::clear_v0_0_1() {
  _impl_.v0_0_1_.ClearToEmpty();
}
inline const std::string& Version::v0_0_1() const {
  // @@protoc_insertion_point(field_get:aggregator.v1.Version.v0_0_1)
  return _internal_v0_0_1();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Version::set_v0_0_1(ArgT0&& arg0, ArgT... args) {
 
 _impl_.v0_0_1_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:aggregator.v1.Version.v0_0_1)
}
inline std::string* Version::mutable_v0_0_1() {
  std::string* _s = _internal_mutable_v0_0_1();
  // @@protoc_insertion_point(field_mutable:aggregator.v1.Version.v0_0_1)
  return _s;
}
inline const std::string& Version::_internal_v0_0_1() const {
  return _impl_.v0_0_1_.Get();
}
inline void Version::_internal_set_v0_0_1(const std::string& value) {
  
  _impl_.v0_0_1_.Set(value, GetArenaForAllocation());
}
inline std::string* Version::_internal_mutable_v0_0_1() {
  
  return _impl_.v0_0_1_.Mutable(GetArenaForAllocation());
}
inline std::string* Version::release_v0_0_1() {
  // @@protoc_insertion_point(field_release:aggregator.v1.Version.v0_0_1)
  return _impl_.v0_0_1_.Release();
}
inline void Version::set_allocated_v0_0_1(std::string* v0_0_1) {
  if (v0_0_1 != nullptr) {
    
  } else {
    
  }
  _impl_.v0_0_1_.SetAllocated(v0_0_1, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.v0_0_1_.IsDefault()) {
    _impl_.v0_0_1_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aggregator.v1.Version.v0_0_1)
}

// -------------------------------------------------------------------

// AggregatorMessage

// string id = 1;
inline void AggregatorMessage::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& AggregatorMessage::id() const {
  // @@protoc_insertion_point(field_get:aggregator.v1.AggregatorMessage.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AggregatorMessage::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:aggregator.v1.AggregatorMessage.id)
}
inline std::string* AggregatorMessage::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:aggregator.v1.AggregatorMessage.id)
  return _s;
}
inline const std::string& AggregatorMessage::_internal_id() const {
  return _impl_.id_.Get();
}
inline void AggregatorMessage::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* AggregatorMessage::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* AggregatorMessage::release_id() {
  // @@protoc_insertion_point(field_release:aggregator.v1.AggregatorMessage.id)
  return _impl_.id_.Release();
}
inline void AggregatorMessage::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aggregator.v1.AggregatorMessage.id)
}

// .aggregator.v1.GetStatusRequest get_status_request = 2;
inline bool AggregatorMessage::_internal_has_get_status_request() const {
  return request_case() == kGetStatusRequest;
}
inline bool AggregatorMessage::has_get_status_request() const {
  return _internal_has_get_status_request();
}
inline void AggregatorMessage::set_has_get_status_request() {
  _impl_._oneof_case_[0] = kGetStatusRequest;
}
inline void AggregatorMessage::clear_get_status_request() {
  if (_internal_has_get_status_request()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.request_.get_status_request_;
    }
    clear_has_request();
  }
}
inline ::aggregator::v1::GetStatusRequest* AggregatorMessage::release_get_status_request() {
  // @@protoc_insertion_point(field_release:aggregator.v1.AggregatorMessage.get_status_request)
  if (_internal_has_get_status_request()) {
    clear_has_request();
    ::aggregator::v1::GetStatusRequest* temp = _impl_.request_.get_status_request_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.request_.get_status_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::aggregator::v1::GetStatusRequest& AggregatorMessage::_internal_get_status_request() const {
  return _internal_has_get_status_request()
      ? *_impl_.request_.get_status_request_
      : reinterpret_cast< ::aggregator::v1::GetStatusRequest&>(::aggregator::v1::_GetStatusRequest_default_instance_);
}
inline const ::aggregator::v1::GetStatusRequest& AggregatorMessage::get_status_request() const {
  // @@protoc_insertion_point(field_get:aggregator.v1.AggregatorMessage.get_status_request)
  return _internal_get_status_request();
}
inline ::aggregator::v1::GetStatusRequest* AggregatorMessage::unsafe_arena_release_get_status_request() {
  // @@protoc_insertion_point(field_unsafe_arena_release:aggregator.v1.AggregatorMessage.get_status_request)
  if (_internal_has_get_status_request()) {
    clear_has_request();
    ::aggregator::v1::GetStatusRequest* temp = _impl_.request_.get_status_request_;
    _impl_.request_.get_status_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AggregatorMessage::unsafe_arena_set_allocated_get_status_request(::aggregator::v1::GetStatusRequest* get_status_request) {
  clear_request();
  if (get_status_request) {
    set_has_get_status_request();
    _impl_.request_.get_status_request_ = get_status_request;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aggregator.v1.AggregatorMessage.get_status_request)
}
inline ::aggregator::v1::GetStatusRequest* AggregatorMessage::_internal_mutable_get_status_request() {
  if (!_internal_has_get_status_request()) {
    clear_request();
    set_has_get_status_request();
    _impl_.request_.get_status_request_ = CreateMaybeMessage< ::aggregator::v1::GetStatusRequest >(GetArenaForAllocation());
  }
  return _impl_.request_.get_status_request_;
}
inline ::aggregator::v1::GetStatusRequest* AggregatorMessage::mutable_get_status_request() {
  ::aggregator::v1::GetStatusRequest* _msg = _internal_mutable_get_status_request();
  // @@protoc_insertion_point(field_mutable:aggregator.v1.AggregatorMessage.get_status_request)
  return _msg;
}

// .aggregator.v1.GenBatchProofRequest gen_batch_proof_request = 3;
inline bool AggregatorMessage::_internal_has_gen_batch_proof_request() const {
  return request_case() == kGenBatchProofRequest;
}
inline bool AggregatorMessage::has_gen_batch_proof_request() const {
  return _internal_has_gen_batch_proof_request();
}
inline void AggregatorMessage::set_has_gen_batch_proof_request() {
  _impl_._oneof_case_[0] = kGenBatchProofRequest;
}
inline void AggregatorMessage::clear_gen_batch_proof_request() {
  if (_internal_has_gen_batch_proof_request()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.request_.gen_batch_proof_request_;
    }
    clear_has_request();
  }
}
inline ::aggregator::v1::GenBatchProofRequest* AggregatorMessage::release_gen_batch_proof_request() {
  // @@protoc_insertion_point(field_release:aggregator.v1.AggregatorMessage.gen_batch_proof_request)
  if (_internal_has_gen_batch_proof_request()) {
    clear_has_request();
    ::aggregator::v1::GenBatchProofRequest* temp = _impl_.request_.gen_batch_proof_request_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.request_.gen_batch_proof_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::aggregator::v1::GenBatchProofRequest& AggregatorMessage::_internal_gen_batch_proof_request() const {
  return _internal_has_gen_batch_proof_request()
      ? *_impl_.request_.gen_batch_proof_request_
      : reinterpret_cast< ::aggregator::v1::GenBatchProofRequest&>(::aggregator::v1::_GenBatchProofRequest_default_instance_);
}
inline const ::aggregator::v1::GenBatchProofRequest& AggregatorMessage::gen_batch_proof_request() const {
  // @@protoc_insertion_point(field_get:aggregator.v1.AggregatorMessage.gen_batch_proof_request)
  return _internal_gen_batch_proof_request();
}
inline ::aggregator::v1::GenBatchProofRequest* AggregatorMessage::unsafe_arena_release_gen_batch_proof_request() {
  // @@protoc_insertion_point(field_unsafe_arena_release:aggregator.v1.AggregatorMessage.gen_batch_proof_request)
  if (_internal_has_gen_batch_proof_request()) {
    clear_has_request();
    ::aggregator::v1::GenBatchProofRequest* temp = _impl_.request_.gen_batch_proof_request_;
    _impl_.request_.gen_batch_proof_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AggregatorMessage::unsafe_arena_set_allocated_gen_batch_proof_request(::aggregator::v1::GenBatchProofRequest* gen_batch_proof_request) {
  clear_request();
  if (gen_batch_proof_request) {
    set_has_gen_batch_proof_request();
    _impl_.request_.gen_batch_proof_request_ = gen_batch_proof_request;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aggregator.v1.AggregatorMessage.gen_batch_proof_request)
}
inline ::aggregator::v1::GenBatchProofRequest* AggregatorMessage::_internal_mutable_gen_batch_proof_request() {
  if (!_internal_has_gen_batch_proof_request()) {
    clear_request();
    set_has_gen_batch_proof_request();
    _impl_.request_.gen_batch_proof_request_ = CreateMaybeMessage< ::aggregator::v1::GenBatchProofRequest >(GetArenaForAllocation());
  }
  return _impl_.request_.gen_batch_proof_request_;
}
inline ::aggregator::v1::GenBatchProofRequest* AggregatorMessage::mutable_gen_batch_proof_request() {
  ::aggregator::v1::GenBatchProofRequest* _msg = _internal_mutable_gen_batch_proof_request();
  // @@protoc_insertion_point(field_mutable:aggregator.v1.AggregatorMessage.gen_batch_proof_request)
  return _msg;
}

// .aggregator.v1.GenAggregatedProofRequest gen_aggregated_proof_request = 4;
inline bool AggregatorMessage::_internal_has_gen_aggregated_proof_request() const {
  return request_case() == kGenAggregatedProofRequest;
}
inline bool AggregatorMessage::has_gen_aggregated_proof_request() const {
  return _internal_has_gen_aggregated_proof_request();
}
inline void AggregatorMessage::set_has_gen_aggregated_proof_request() {
  _impl_._oneof_case_[0] = kGenAggregatedProofRequest;
}
inline void AggregatorMessage::clear_gen_aggregated_proof_request() {
  if (_internal_has_gen_aggregated_proof_request()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.request_.gen_aggregated_proof_request_;
    }
    clear_has_request();
  }
}
inline ::aggregator::v1::GenAggregatedProofRequest* AggregatorMessage::release_gen_aggregated_proof_request() {
  // @@protoc_insertion_point(field_release:aggregator.v1.AggregatorMessage.gen_aggregated_proof_request)
  if (_internal_has_gen_aggregated_proof_request()) {
    clear_has_request();
    ::aggregator::v1::GenAggregatedProofRequest* temp = _impl_.request_.gen_aggregated_proof_request_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.request_.gen_aggregated_proof_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::aggregator::v1::GenAggregatedProofRequest& AggregatorMessage::_internal_gen_aggregated_proof_request() const {
  return _internal_has_gen_aggregated_proof_request()
      ? *_impl_.request_.gen_aggregated_proof_request_
      : reinterpret_cast< ::aggregator::v1::GenAggregatedProofRequest&>(::aggregator::v1::_GenAggregatedProofRequest_default_instance_);
}
inline const ::aggregator::v1::GenAggregatedProofRequest& AggregatorMessage::gen_aggregated_proof_request() const {
  // @@protoc_insertion_point(field_get:aggregator.v1.AggregatorMessage.gen_aggregated_proof_request)
  return _internal_gen_aggregated_proof_request();
}
inline ::aggregator::v1::GenAggregatedProofRequest* AggregatorMessage::unsafe_arena_release_gen_aggregated_proof_request() {
  // @@protoc_insertion_point(field_unsafe_arena_release:aggregator.v1.AggregatorMessage.gen_aggregated_proof_request)
  if (_internal_has_gen_aggregated_proof_request()) {
    clear_has_request();
    ::aggregator::v1::GenAggregatedProofRequest* temp = _impl_.request_.gen_aggregated_proof_request_;
    _impl_.request_.gen_aggregated_proof_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AggregatorMessage::unsafe_arena_set_allocated_gen_aggregated_proof_request(::aggregator::v1::GenAggregatedProofRequest* gen_aggregated_proof_request) {
  clear_request();
  if (gen_aggregated_proof_request) {
    set_has_gen_aggregated_proof_request();
    _impl_.request_.gen_aggregated_proof_request_ = gen_aggregated_proof_request;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aggregator.v1.AggregatorMessage.gen_aggregated_proof_request)
}
inline ::aggregator::v1::GenAggregatedProofRequest* AggregatorMessage::_internal_mutable_gen_aggregated_proof_request() {
  if (!_internal_has_gen_aggregated_proof_request()) {
    clear_request();
    set_has_gen_aggregated_proof_request();
    _impl_.request_.gen_aggregated_proof_request_ = CreateMaybeMessage< ::aggregator::v1::GenAggregatedProofRequest >(GetArenaForAllocation());
  }
  return _impl_.request_.gen_aggregated_proof_request_;
}
inline ::aggregator::v1::GenAggregatedProofRequest* AggregatorMessage::mutable_gen_aggregated_proof_request() {
  ::aggregator::v1::GenAggregatedProofRequest* _msg = _internal_mutable_gen_aggregated_proof_request();
  // @@protoc_insertion_point(field_mutable:aggregator.v1.AggregatorMessage.gen_aggregated_proof_request)
  return _msg;
}

// .aggregator.v1.GenFinalProofRequest gen_final_proof_request = 5;
inline bool AggregatorMessage::_internal_has_gen_final_proof_request() const {
  return request_case() == kGenFinalProofRequest;
}
inline bool AggregatorMessage::has_gen_final_proof_request() const {
  return _internal_has_gen_final_proof_request();
}
inline void AggregatorMessage::set_has_gen_final_proof_request() {
  _impl_._oneof_case_[0] = kGenFinalProofRequest;
}
inline void AggregatorMessage::clear_gen_final_proof_request() {
  if (_internal_has_gen_final_proof_request()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.request_.gen_final_proof_request_;
    }
    clear_has_request();
  }
}
inline ::aggregator::v1::GenFinalProofRequest* AggregatorMessage::release_gen_final_proof_request() {
  // @@protoc_insertion_point(field_release:aggregator.v1.AggregatorMessage.gen_final_proof_request)
  if (_internal_has_gen_final_proof_request()) {
    clear_has_request();
    ::aggregator::v1::GenFinalProofRequest* temp = _impl_.request_.gen_final_proof_request_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.request_.gen_final_proof_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::aggregator::v1::GenFinalProofRequest& AggregatorMessage::_internal_gen_final_proof_request() const {
  return _internal_has_gen_final_proof_request()
      ? *_impl_.request_.gen_final_proof_request_
      : reinterpret_cast< ::aggregator::v1::GenFinalProofRequest&>(::aggregator::v1::_GenFinalProofRequest_default_instance_);
}
inline const ::aggregator::v1::GenFinalProofRequest& AggregatorMessage::gen_final_proof_request() const {
  // @@protoc_insertion_point(field_get:aggregator.v1.AggregatorMessage.gen_final_proof_request)
  return _internal_gen_final_proof_request();
}
inline ::aggregator::v1::GenFinalProofRequest* AggregatorMessage::unsafe_arena_release_gen_final_proof_request() {
  // @@protoc_insertion_point(field_unsafe_arena_release:aggregator.v1.AggregatorMessage.gen_final_proof_request)
  if (_internal_has_gen_final_proof_request()) {
    clear_has_request();
    ::aggregator::v1::GenFinalProofRequest* temp = _impl_.request_.gen_final_proof_request_;
    _impl_.request_.gen_final_proof_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AggregatorMessage::unsafe_arena_set_allocated_gen_final_proof_request(::aggregator::v1::GenFinalProofRequest* gen_final_proof_request) {
  clear_request();
  if (gen_final_proof_request) {
    set_has_gen_final_proof_request();
    _impl_.request_.gen_final_proof_request_ = gen_final_proof_request;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aggregator.v1.AggregatorMessage.gen_final_proof_request)
}
inline ::aggregator::v1::GenFinalProofRequest* AggregatorMessage::_internal_mutable_gen_final_proof_request() {
  if (!_internal_has_gen_final_proof_request()) {
    clear_request();
    set_has_gen_final_proof_request();
    _impl_.request_.gen_final_proof_request_ = CreateMaybeMessage< ::aggregator::v1::GenFinalProofRequest >(GetArenaForAllocation());
  }
  return _impl_.request_.gen_final_proof_request_;
}
inline ::aggregator::v1::GenFinalProofRequest* AggregatorMessage::mutable_gen_final_proof_request() {
  ::aggregator::v1::GenFinalProofRequest* _msg = _internal_mutable_gen_final_proof_request();
  // @@protoc_insertion_point(field_mutable:aggregator.v1.AggregatorMessage.gen_final_proof_request)
  return _msg;
}

// .aggregator.v1.CancelRequest cancel_request = 6;
inline bool AggregatorMessage::_internal_has_cancel_request() const {
  return request_case() == kCancelRequest;
}
inline bool AggregatorMessage::has_cancel_request() const {
  return _internal_has_cancel_request();
}
inline void AggregatorMessage::set_has_cancel_request() {
  _impl_._oneof_case_[0] = kCancelRequest;
}
inline void AggregatorMessage::clear_cancel_request() {
  if (_internal_has_cancel_request()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.request_.cancel_request_;
    }
    clear_has_request();
  }
}
inline ::aggregator::v1::CancelRequest* AggregatorMessage::release_cancel_request() {
  // @@protoc_insertion_point(field_release:aggregator.v1.AggregatorMessage.cancel_request)
  if (_internal_has_cancel_request()) {
    clear_has_request();
    ::aggregator::v1::CancelRequest* temp = _impl_.request_.cancel_request_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.request_.cancel_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::aggregator::v1::CancelRequest& AggregatorMessage::_internal_cancel_request() const {
  return _internal_has_cancel_request()
      ? *_impl_.request_.cancel_request_
      : reinterpret_cast< ::aggregator::v1::CancelRequest&>(::aggregator::v1::_CancelRequest_default_instance_);
}
inline const ::aggregator::v1::CancelRequest& AggregatorMessage::cancel_request() const {
  // @@protoc_insertion_point(field_get:aggregator.v1.AggregatorMessage.cancel_request)
  return _internal_cancel_request();
}
inline ::aggregator::v1::CancelRequest* AggregatorMessage::unsafe_arena_release_cancel_request() {
  // @@protoc_insertion_point(field_unsafe_arena_release:aggregator.v1.AggregatorMessage.cancel_request)
  if (_internal_has_cancel_request()) {
    clear_has_request();
    ::aggregator::v1::CancelRequest* temp = _impl_.request_.cancel_request_;
    _impl_.request_.cancel_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AggregatorMessage::unsafe_arena_set_allocated_cancel_request(::aggregator::v1::CancelRequest* cancel_request) {
  clear_request();
  if (cancel_request) {
    set_has_cancel_request();
    _impl_.request_.cancel_request_ = cancel_request;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aggregator.v1.AggregatorMessage.cancel_request)
}
inline ::aggregator::v1::CancelRequest* AggregatorMessage::_internal_mutable_cancel_request() {
  if (!_internal_has_cancel_request()) {
    clear_request();
    set_has_cancel_request();
    _impl_.request_.cancel_request_ = CreateMaybeMessage< ::aggregator::v1::CancelRequest >(GetArenaForAllocation());
  }
  return _impl_.request_.cancel_request_;
}
inline ::aggregator::v1::CancelRequest* AggregatorMessage::mutable_cancel_request() {
  ::aggregator::v1::CancelRequest* _msg = _internal_mutable_cancel_request();
  // @@protoc_insertion_point(field_mutable:aggregator.v1.AggregatorMessage.cancel_request)
  return _msg;
}

// .aggregator.v1.GetProofRequest get_proof_request = 7;
inline bool AggregatorMessage::_internal_has_get_proof_request() const {
  return request_case() == kGetProofRequest;
}
inline bool AggregatorMessage::has_get_proof_request() const {
  return _internal_has_get_proof_request();
}
inline void AggregatorMessage::set_has_get_proof_request() {
  _impl_._oneof_case_[0] = kGetProofRequest;
}
inline void AggregatorMessage::clear_get_proof_request() {
  if (_internal_has_get_proof_request()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.request_.get_proof_request_;
    }
    clear_has_request();
  }
}
inline ::aggregator::v1::GetProofRequest* AggregatorMessage::release_get_proof_request() {
  // @@protoc_insertion_point(field_release:aggregator.v1.AggregatorMessage.get_proof_request)
  if (_internal_has_get_proof_request()) {
    clear_has_request();
    ::aggregator::v1::GetProofRequest* temp = _impl_.request_.get_proof_request_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.request_.get_proof_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::aggregator::v1::GetProofRequest& AggregatorMessage::_internal_get_proof_request() const {
  return _internal_has_get_proof_request()
      ? *_impl_.request_.get_proof_request_
      : reinterpret_cast< ::aggregator::v1::GetProofRequest&>(::aggregator::v1::_GetProofRequest_default_instance_);
}
inline const ::aggregator::v1::GetProofRequest& AggregatorMessage::get_proof_request() const {
  // @@protoc_insertion_point(field_get:aggregator.v1.AggregatorMessage.get_proof_request)
  return _internal_get_proof_request();
}
inline ::aggregator::v1::GetProofRequest* AggregatorMessage::unsafe_arena_release_get_proof_request() {
  // @@protoc_insertion_point(field_unsafe_arena_release:aggregator.v1.AggregatorMessage.get_proof_request)
  if (_internal_has_get_proof_request()) {
    clear_has_request();
    ::aggregator::v1::GetProofRequest* temp = _impl_.request_.get_proof_request_;
    _impl_.request_.get_proof_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AggregatorMessage::unsafe_arena_set_allocated_get_proof_request(::aggregator::v1::GetProofRequest* get_proof_request) {
  clear_request();
  if (get_proof_request) {
    set_has_get_proof_request();
    _impl_.request_.get_proof_request_ = get_proof_request;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aggregator.v1.AggregatorMessage.get_proof_request)
}
inline ::aggregator::v1::GetProofRequest* AggregatorMessage::_internal_mutable_get_proof_request() {
  if (!_internal_has_get_proof_request()) {
    clear_request();
    set_has_get_proof_request();
    _impl_.request_.get_proof_request_ = CreateMaybeMessage< ::aggregator::v1::GetProofRequest >(GetArenaForAllocation());
  }
  return _impl_.request_.get_proof_request_;
}
inline ::aggregator::v1::GetProofRequest* AggregatorMessage::mutable_get_proof_request() {
  ::aggregator::v1::GetProofRequest* _msg = _internal_mutable_get_proof_request();
  // @@protoc_insertion_point(field_mutable:aggregator.v1.AggregatorMessage.get_proof_request)
  return _msg;
}

inline bool AggregatorMessage::has_request() const {
  return request_case() != REQUEST_NOT_SET;
}
inline void AggregatorMessage::clear_has_request() {
  _impl_._oneof_case_[0] = REQUEST_NOT_SET;
}
inline AggregatorMessage::RequestCase AggregatorMessage::request_case() const {
  return AggregatorMessage::RequestCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// ProverMessage

// string id = 1;
inline void ProverMessage::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& ProverMessage::id() const {
  // @@protoc_insertion_point(field_get:aggregator.v1.ProverMessage.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProverMessage::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:aggregator.v1.ProverMessage.id)
}
inline std::string* ProverMessage::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:aggregator.v1.ProverMessage.id)
  return _s;
}
inline const std::string& ProverMessage::_internal_id() const {
  return _impl_.id_.Get();
}
inline void ProverMessage::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* ProverMessage::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* ProverMessage::release_id() {
  // @@protoc_insertion_point(field_release:aggregator.v1.ProverMessage.id)
  return _impl_.id_.Release();
}
inline void ProverMessage::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aggregator.v1.ProverMessage.id)
}

// .aggregator.v1.GetStatusResponse get_status_response = 2;
inline bool ProverMessage::_internal_has_get_status_response() const {
  return response_case() == kGetStatusResponse;
}
inline bool ProverMessage::has_get_status_response() const {
  return _internal_has_get_status_response();
}
inline void ProverMessage::set_has_get_status_response() {
  _impl_._oneof_case_[0] = kGetStatusResponse;
}
inline void ProverMessage::clear_get_status_response() {
  if (_internal_has_get_status_response()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.response_.get_status_response_;
    }
    clear_has_response();
  }
}
inline ::aggregator::v1::GetStatusResponse* ProverMessage::release_get_status_response() {
  // @@protoc_insertion_point(field_release:aggregator.v1.ProverMessage.get_status_response)
  if (_internal_has_get_status_response()) {
    clear_has_response();
    ::aggregator::v1::GetStatusResponse* temp = _impl_.response_.get_status_response_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_.get_status_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::aggregator::v1::GetStatusResponse& ProverMessage::_internal_get_status_response() const {
  return _internal_has_get_status_response()
      ? *_impl_.response_.get_status_response_
      : reinterpret_cast< ::aggregator::v1::GetStatusResponse&>(::aggregator::v1::_GetStatusResponse_default_instance_);
}
inline const ::aggregator::v1::GetStatusResponse& ProverMessage::get_status_response() const {
  // @@protoc_insertion_point(field_get:aggregator.v1.ProverMessage.get_status_response)
  return _internal_get_status_response();
}
inline ::aggregator::v1::GetStatusResponse* ProverMessage::unsafe_arena_release_get_status_response() {
  // @@protoc_insertion_point(field_unsafe_arena_release:aggregator.v1.ProverMessage.get_status_response)
  if (_internal_has_get_status_response()) {
    clear_has_response();
    ::aggregator::v1::GetStatusResponse* temp = _impl_.response_.get_status_response_;
    _impl_.response_.get_status_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ProverMessage::unsafe_arena_set_allocated_get_status_response(::aggregator::v1::GetStatusResponse* get_status_response) {
  clear_response();
  if (get_status_response) {
    set_has_get_status_response();
    _impl_.response_.get_status_response_ = get_status_response;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aggregator.v1.ProverMessage.get_status_response)
}
inline ::aggregator::v1::GetStatusResponse* ProverMessage::_internal_mutable_get_status_response() {
  if (!_internal_has_get_status_response()) {
    clear_response();
    set_has_get_status_response();
    _impl_.response_.get_status_response_ = CreateMaybeMessage< ::aggregator::v1::GetStatusResponse >(GetArenaForAllocation());
  }
  return _impl_.response_.get_status_response_;
}
inline ::aggregator::v1::GetStatusResponse* ProverMessage::mutable_get_status_response() {
  ::aggregator::v1::GetStatusResponse* _msg = _internal_mutable_get_status_response();
  // @@protoc_insertion_point(field_mutable:aggregator.v1.ProverMessage.get_status_response)
  return _msg;
}

// .aggregator.v1.GenBatchProofResponse gen_batch_proof_response = 3;
inline bool ProverMessage::_internal_has_gen_batch_proof_response() const {
  return response_case() == kGenBatchProofResponse;
}
inline bool ProverMessage::has_gen_batch_proof_response() const {
  return _internal_has_gen_batch_proof_response();
}
inline void ProverMessage::set_has_gen_batch_proof_response() {
  _impl_._oneof_case_[0] = kGenBatchProofResponse;
}
inline void ProverMessage::clear_gen_batch_proof_response() {
  if (_internal_has_gen_batch_proof_response()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.response_.gen_batch_proof_response_;
    }
    clear_has_response();
  }
}
inline ::aggregator::v1::GenBatchProofResponse* ProverMessage::release_gen_batch_proof_response() {
  // @@protoc_insertion_point(field_release:aggregator.v1.ProverMessage.gen_batch_proof_response)
  if (_internal_has_gen_batch_proof_response()) {
    clear_has_response();
    ::aggregator::v1::GenBatchProofResponse* temp = _impl_.response_.gen_batch_proof_response_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_.gen_batch_proof_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::aggregator::v1::GenBatchProofResponse& ProverMessage::_internal_gen_batch_proof_response() const {
  return _internal_has_gen_batch_proof_response()
      ? *_impl_.response_.gen_batch_proof_response_
      : reinterpret_cast< ::aggregator::v1::GenBatchProofResponse&>(::aggregator::v1::_GenBatchProofResponse_default_instance_);
}
inline const ::aggregator::v1::GenBatchProofResponse& ProverMessage::gen_batch_proof_response() const {
  // @@protoc_insertion_point(field_get:aggregator.v1.ProverMessage.gen_batch_proof_response)
  return _internal_gen_batch_proof_response();
}
inline ::aggregator::v1::GenBatchProofResponse* ProverMessage::unsafe_arena_release_gen_batch_proof_response() {
  // @@protoc_insertion_point(field_unsafe_arena_release:aggregator.v1.ProverMessage.gen_batch_proof_response)
  if (_internal_has_gen_batch_proof_response()) {
    clear_has_response();
    ::aggregator::v1::GenBatchProofResponse* temp = _impl_.response_.gen_batch_proof_response_;
    _impl_.response_.gen_batch_proof_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ProverMessage::unsafe_arena_set_allocated_gen_batch_proof_response(::aggregator::v1::GenBatchProofResponse* gen_batch_proof_response) {
  clear_response();
  if (gen_batch_proof_response) {
    set_has_gen_batch_proof_response();
    _impl_.response_.gen_batch_proof_response_ = gen_batch_proof_response;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aggregator.v1.ProverMessage.gen_batch_proof_response)
}
inline ::aggregator::v1::GenBatchProofResponse* ProverMessage::_internal_mutable_gen_batch_proof_response() {
  if (!_internal_has_gen_batch_proof_response()) {
    clear_response();
    set_has_gen_batch_proof_response();
    _impl_.response_.gen_batch_proof_response_ = CreateMaybeMessage< ::aggregator::v1::GenBatchProofResponse >(GetArenaForAllocation());
  }
  return _impl_.response_.gen_batch_proof_response_;
}
inline ::aggregator::v1::GenBatchProofResponse* ProverMessage::mutable_gen_batch_proof_response() {
  ::aggregator::v1::GenBatchProofResponse* _msg = _internal_mutable_gen_batch_proof_response();
  // @@protoc_insertion_point(field_mutable:aggregator.v1.ProverMessage.gen_batch_proof_response)
  return _msg;
}

// .aggregator.v1.GenAggregatedProofResponse gen_aggregated_proof_response = 4;
inline bool ProverMessage::_internal_has_gen_aggregated_proof_response() const {
  return response_case() == kGenAggregatedProofResponse;
}
inline bool ProverMessage::has_gen_aggregated_proof_response() const {
  return _internal_has_gen_aggregated_proof_response();
}
inline void ProverMessage::set_has_gen_aggregated_proof_response() {
  _impl_._oneof_case_[0] = kGenAggregatedProofResponse;
}
inline void ProverMessage::clear_gen_aggregated_proof_response() {
  if (_internal_has_gen_aggregated_proof_response()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.response_.gen_aggregated_proof_response_;
    }
    clear_has_response();
  }
}
inline ::aggregator::v1::GenAggregatedProofResponse* ProverMessage::release_gen_aggregated_proof_response() {
  // @@protoc_insertion_point(field_release:aggregator.v1.ProverMessage.gen_aggregated_proof_response)
  if (_internal_has_gen_aggregated_proof_response()) {
    clear_has_response();
    ::aggregator::v1::GenAggregatedProofResponse* temp = _impl_.response_.gen_aggregated_proof_response_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_.gen_aggregated_proof_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::aggregator::v1::GenAggregatedProofResponse& ProverMessage::_internal_gen_aggregated_proof_response() const {
  return _internal_has_gen_aggregated_proof_response()
      ? *_impl_.response_.gen_aggregated_proof_response_
      : reinterpret_cast< ::aggregator::v1::GenAggregatedProofResponse&>(::aggregator::v1::_GenAggregatedProofResponse_default_instance_);
}
inline const ::aggregator::v1::GenAggregatedProofResponse& ProverMessage::gen_aggregated_proof_response() const {
  // @@protoc_insertion_point(field_get:aggregator.v1.ProverMessage.gen_aggregated_proof_response)
  return _internal_gen_aggregated_proof_response();
}
inline ::aggregator::v1::GenAggregatedProofResponse* ProverMessage::unsafe_arena_release_gen_aggregated_proof_response() {
  // @@protoc_insertion_point(field_unsafe_arena_release:aggregator.v1.ProverMessage.gen_aggregated_proof_response)
  if (_internal_has_gen_aggregated_proof_response()) {
    clear_has_response();
    ::aggregator::v1::GenAggregatedProofResponse* temp = _impl_.response_.gen_aggregated_proof_response_;
    _impl_.response_.gen_aggregated_proof_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ProverMessage::unsafe_arena_set_allocated_gen_aggregated_proof_response(::aggregator::v1::GenAggregatedProofResponse* gen_aggregated_proof_response) {
  clear_response();
  if (gen_aggregated_proof_response) {
    set_has_gen_aggregated_proof_response();
    _impl_.response_.gen_aggregated_proof_response_ = gen_aggregated_proof_response;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aggregator.v1.ProverMessage.gen_aggregated_proof_response)
}
inline ::aggregator::v1::GenAggregatedProofResponse* ProverMessage::_internal_mutable_gen_aggregated_proof_response() {
  if (!_internal_has_gen_aggregated_proof_response()) {
    clear_response();
    set_has_gen_aggregated_proof_response();
    _impl_.response_.gen_aggregated_proof_response_ = CreateMaybeMessage< ::aggregator::v1::GenAggregatedProofResponse >(GetArenaForAllocation());
  }
  return _impl_.response_.gen_aggregated_proof_response_;
}
inline ::aggregator::v1::GenAggregatedProofResponse* ProverMessage::mutable_gen_aggregated_proof_response() {
  ::aggregator::v1::GenAggregatedProofResponse* _msg = _internal_mutable_gen_aggregated_proof_response();
  // @@protoc_insertion_point(field_mutable:aggregator.v1.ProverMessage.gen_aggregated_proof_response)
  return _msg;
}

// .aggregator.v1.GenFinalProofResponse gen_final_proof_response = 5;
inline bool ProverMessage::_internal_has_gen_final_proof_response() const {
  return response_case() == kGenFinalProofResponse;
}
inline bool ProverMessage::has_gen_final_proof_response() const {
  return _internal_has_gen_final_proof_response();
}
inline void ProverMessage::set_has_gen_final_proof_response() {
  _impl_._oneof_case_[0] = kGenFinalProofResponse;
}
inline void ProverMessage::clear_gen_final_proof_response() {
  if (_internal_has_gen_final_proof_response()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.response_.gen_final_proof_response_;
    }
    clear_has_response();
  }
}
inline ::aggregator::v1::GenFinalProofResponse* ProverMessage::release_gen_final_proof_response() {
  // @@protoc_insertion_point(field_release:aggregator.v1.ProverMessage.gen_final_proof_response)
  if (_internal_has_gen_final_proof_response()) {
    clear_has_response();
    ::aggregator::v1::GenFinalProofResponse* temp = _impl_.response_.gen_final_proof_response_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_.gen_final_proof_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::aggregator::v1::GenFinalProofResponse& ProverMessage::_internal_gen_final_proof_response() const {
  return _internal_has_gen_final_proof_response()
      ? *_impl_.response_.gen_final_proof_response_
      : reinterpret_cast< ::aggregator::v1::GenFinalProofResponse&>(::aggregator::v1::_GenFinalProofResponse_default_instance_);
}
inline const ::aggregator::v1::GenFinalProofResponse& ProverMessage::gen_final_proof_response() const {
  // @@protoc_insertion_point(field_get:aggregator.v1.ProverMessage.gen_final_proof_response)
  return _internal_gen_final_proof_response();
}
inline ::aggregator::v1::GenFinalProofResponse* ProverMessage::unsafe_arena_release_gen_final_proof_response() {
  // @@protoc_insertion_point(field_unsafe_arena_release:aggregator.v1.ProverMessage.gen_final_proof_response)
  if (_internal_has_gen_final_proof_response()) {
    clear_has_response();
    ::aggregator::v1::GenFinalProofResponse* temp = _impl_.response_.gen_final_proof_response_;
    _impl_.response_.gen_final_proof_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ProverMessage::unsafe_arena_set_allocated_gen_final_proof_response(::aggregator::v1::GenFinalProofResponse* gen_final_proof_response) {
  clear_response();
  if (gen_final_proof_response) {
    set_has_gen_final_proof_response();
    _impl_.response_.gen_final_proof_response_ = gen_final_proof_response;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aggregator.v1.ProverMessage.gen_final_proof_response)
}
inline ::aggregator::v1::GenFinalProofResponse* ProverMessage::_internal_mutable_gen_final_proof_response() {
  if (!_internal_has_gen_final_proof_response()) {
    clear_response();
    set_has_gen_final_proof_response();
    _impl_.response_.gen_final_proof_response_ = CreateMaybeMessage< ::aggregator::v1::GenFinalProofResponse >(GetArenaForAllocation());
  }
  return _impl_.response_.gen_final_proof_response_;
}
inline ::aggregator::v1::GenFinalProofResponse* ProverMessage::mutable_gen_final_proof_response() {
  ::aggregator::v1::GenFinalProofResponse* _msg = _internal_mutable_gen_final_proof_response();
  // @@protoc_insertion_point(field_mutable:aggregator.v1.ProverMessage.gen_final_proof_response)
  return _msg;
}

// .aggregator.v1.CancelResponse cancel_response = 6;
inline bool ProverMessage::_internal_has_cancel_response() const {
  return response_case() == kCancelResponse;
}
inline bool ProverMessage::has_cancel_response() const {
  return _internal_has_cancel_response();
}
inline void ProverMessage::set_has_cancel_response() {
  _impl_._oneof_case_[0] = kCancelResponse;
}
inline void ProverMessage::clear_cancel_response() {
  if (_internal_has_cancel_response()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.response_.cancel_response_;
    }
    clear_has_response();
  }
}
inline ::aggregator::v1::CancelResponse* ProverMessage::release_cancel_response() {
  // @@protoc_insertion_point(field_release:aggregator.v1.ProverMessage.cancel_response)
  if (_internal_has_cancel_response()) {
    clear_has_response();
    ::aggregator::v1::CancelResponse* temp = _impl_.response_.cancel_response_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_.cancel_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::aggregator::v1::CancelResponse& ProverMessage::_internal_cancel_response() const {
  return _internal_has_cancel_response()
      ? *_impl_.response_.cancel_response_
      : reinterpret_cast< ::aggregator::v1::CancelResponse&>(::aggregator::v1::_CancelResponse_default_instance_);
}
inline const ::aggregator::v1::CancelResponse& ProverMessage::cancel_response() const {
  // @@protoc_insertion_point(field_get:aggregator.v1.ProverMessage.cancel_response)
  return _internal_cancel_response();
}
inline ::aggregator::v1::CancelResponse* ProverMessage::unsafe_arena_release_cancel_response() {
  // @@protoc_insertion_point(field_unsafe_arena_release:aggregator.v1.ProverMessage.cancel_response)
  if (_internal_has_cancel_response()) {
    clear_has_response();
    ::aggregator::v1::CancelResponse* temp = _impl_.response_.cancel_response_;
    _impl_.response_.cancel_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ProverMessage::unsafe_arena_set_allocated_cancel_response(::aggregator::v1::CancelResponse* cancel_response) {
  clear_response();
  if (cancel_response) {
    set_has_cancel_response();
    _impl_.response_.cancel_response_ = cancel_response;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aggregator.v1.ProverMessage.cancel_response)
}
inline ::aggregator::v1::CancelResponse* ProverMessage::_internal_mutable_cancel_response() {
  if (!_internal_has_cancel_response()) {
    clear_response();
    set_has_cancel_response();
    _impl_.response_.cancel_response_ = CreateMaybeMessage< ::aggregator::v1::CancelResponse >(GetArenaForAllocation());
  }
  return _impl_.response_.cancel_response_;
}
inline ::aggregator::v1::CancelResponse* ProverMessage::mutable_cancel_response() {
  ::aggregator::v1::CancelResponse* _msg = _internal_mutable_cancel_response();
  // @@protoc_insertion_point(field_mutable:aggregator.v1.ProverMessage.cancel_response)
  return _msg;
}

// .aggregator.v1.GetProofResponse get_proof_response = 7;
inline bool ProverMessage::_internal_has_get_proof_response() const {
  return response_case() == kGetProofResponse;
}
inline bool ProverMessage::has_get_proof_response() const {
  return _internal_has_get_proof_response();
}
inline void ProverMessage::set_has_get_proof_response() {
  _impl_._oneof_case_[0] = kGetProofResponse;
}
inline void ProverMessage::clear_get_proof_response() {
  if (_internal_has_get_proof_response()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.response_.get_proof_response_;
    }
    clear_has_response();
  }
}
inline ::aggregator::v1::GetProofResponse* ProverMessage::release_get_proof_response() {
  // @@protoc_insertion_point(field_release:aggregator.v1.ProverMessage.get_proof_response)
  if (_internal_has_get_proof_response()) {
    clear_has_response();
    ::aggregator::v1::GetProofResponse* temp = _impl_.response_.get_proof_response_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_.get_proof_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::aggregator::v1::GetProofResponse& ProverMessage::_internal_get_proof_response() const {
  return _internal_has_get_proof_response()
      ? *_impl_.response_.get_proof_response_
      : reinterpret_cast< ::aggregator::v1::GetProofResponse&>(::aggregator::v1::_GetProofResponse_default_instance_);
}
inline const ::aggregator::v1::GetProofResponse& ProverMessage::get_proof_response() const {
  // @@protoc_insertion_point(field_get:aggregator.v1.ProverMessage.get_proof_response)
  return _internal_get_proof_response();
}
inline ::aggregator::v1::GetProofResponse* ProverMessage::unsafe_arena_release_get_proof_response() {
  // @@protoc_insertion_point(field_unsafe_arena_release:aggregator.v1.ProverMessage.get_proof_response)
  if (_internal_has_get_proof_response()) {
    clear_has_response();
    ::aggregator::v1::GetProofResponse* temp = _impl_.response_.get_proof_response_;
    _impl_.response_.get_proof_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ProverMessage::unsafe_arena_set_allocated_get_proof_response(::aggregator::v1::GetProofResponse* get_proof_response) {
  clear_response();
  if (get_proof_response) {
    set_has_get_proof_response();
    _impl_.response_.get_proof_response_ = get_proof_response;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aggregator.v1.ProverMessage.get_proof_response)
}
inline ::aggregator::v1::GetProofResponse* ProverMessage::_internal_mutable_get_proof_response() {
  if (!_internal_has_get_proof_response()) {
    clear_response();
    set_has_get_proof_response();
    _impl_.response_.get_proof_response_ = CreateMaybeMessage< ::aggregator::v1::GetProofResponse >(GetArenaForAllocation());
  }
  return _impl_.response_.get_proof_response_;
}
inline ::aggregator::v1::GetProofResponse* ProverMessage::mutable_get_proof_response() {
  ::aggregator::v1::GetProofResponse* _msg = _internal_mutable_get_proof_response();
  // @@protoc_insertion_point(field_mutable:aggregator.v1.ProverMessage.get_proof_response)
  return _msg;
}

inline bool ProverMessage::has_response() const {
  return response_case() != RESPONSE_NOT_SET;
}
inline void ProverMessage::clear_has_response() {
  _impl_._oneof_case_[0] = RESPONSE_NOT_SET;
}
inline ProverMessage::ResponseCase ProverMessage::response_case() const {
  return ProverMessage::ResponseCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// GetStatusRequest

// -------------------------------------------------------------------

// GenBatchProofRequest

// .aggregator.v1.InputProver input = 1;
inline bool GenBatchProofRequest::_internal_has_input() const {
  return this != internal_default_instance() && _impl_.input_ != nullptr;
}
inline bool GenBatchProofRequest::has_input() const {
  return _internal_has_input();
}
inline void GenBatchProofRequest::clear_input() {
  if (GetArenaForAllocation() == nullptr && _impl_.input_ != nullptr) {
    delete _impl_.input_;
  }
  _impl_.input_ = nullptr;
}
inline const ::aggregator::v1::InputProver& GenBatchProofRequest::_internal_input() const {
  const ::aggregator::v1::InputProver* p = _impl_.input_;
  return p != nullptr ? *p : reinterpret_cast<const ::aggregator::v1::InputProver&>(
      ::aggregator::v1::_InputProver_default_instance_);
}
inline const ::aggregator::v1::InputProver& GenBatchProofRequest::input() const {
  // @@protoc_insertion_point(field_get:aggregator.v1.GenBatchProofRequest.input)
  return _internal_input();
}
inline void GenBatchProofRequest::unsafe_arena_set_allocated_input(
    ::aggregator::v1::InputProver* input) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.input_);
  }
  _impl_.input_ = input;
  if (input) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aggregator.v1.GenBatchProofRequest.input)
}
inline ::aggregator::v1::InputProver* GenBatchProofRequest::release_input() {
  
  ::aggregator::v1::InputProver* temp = _impl_.input_;
  _impl_.input_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::aggregator::v1::InputProver* GenBatchProofRequest::unsafe_arena_release_input() {
  // @@protoc_insertion_point(field_release:aggregator.v1.GenBatchProofRequest.input)
  
  ::aggregator::v1::InputProver* temp = _impl_.input_;
  _impl_.input_ = nullptr;
  return temp;
}
inline ::aggregator::v1::InputProver* GenBatchProofRequest::_internal_mutable_input() {
  
  if (_impl_.input_ == nullptr) {
    auto* p = CreateMaybeMessage<::aggregator::v1::InputProver>(GetArenaForAllocation());
    _impl_.input_ = p;
  }
  return _impl_.input_;
}
inline ::aggregator::v1::InputProver* GenBatchProofRequest::mutable_input() {
  ::aggregator::v1::InputProver* _msg = _internal_mutable_input();
  // @@protoc_insertion_point(field_mutable:aggregator.v1.GenBatchProofRequest.input)
  return _msg;
}
inline void GenBatchProofRequest::set_allocated_input(::aggregator::v1::InputProver* input) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.input_;
  }
  if (input) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(input);
    if (message_arena != submessage_arena) {
      input = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, input, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.input_ = input;
  // @@protoc_insertion_point(field_set_allocated:aggregator.v1.GenBatchProofRequest.input)
}

// -------------------------------------------------------------------

// GenAggregatedProofRequest

// string recursive_proof_1 = 1;
inline void GenAggregatedProofRequest::clear_recursive_proof_1() {
  _impl_.recursive_proof_1_.ClearToEmpty();
}
inline const std::string& GenAggregatedProofRequest::recursive_proof_1() const {
  // @@protoc_insertion_point(field_get:aggregator.v1.GenAggregatedProofRequest.recursive_proof_1)
  return _internal_recursive_proof_1();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GenAggregatedProofRequest::set_recursive_proof_1(ArgT0&& arg0, ArgT... args) {
 
 _impl_.recursive_proof_1_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:aggregator.v1.GenAggregatedProofRequest.recursive_proof_1)
}
inline std::string* GenAggregatedProofRequest::mutable_recursive_proof_1() {
  std::string* _s = _internal_mutable_recursive_proof_1();
  // @@protoc_insertion_point(field_mutable:aggregator.v1.GenAggregatedProofRequest.recursive_proof_1)
  return _s;
}
inline const std::string& GenAggregatedProofRequest::_internal_recursive_proof_1() const {
  return _impl_.recursive_proof_1_.Get();
}
inline void GenAggregatedProofRequest::_internal_set_recursive_proof_1(const std::string& value) {
  
  _impl_.recursive_proof_1_.Set(value, GetArenaForAllocation());
}
inline std::string* GenAggregatedProofRequest::_internal_mutable_recursive_proof_1() {
  
  return _impl_.recursive_proof_1_.Mutable(GetArenaForAllocation());
}
inline std::string* GenAggregatedProofRequest::release_recursive_proof_1() {
  // @@protoc_insertion_point(field_release:aggregator.v1.GenAggregatedProofRequest.recursive_proof_1)
  return _impl_.recursive_proof_1_.Release();
}
inline void GenAggregatedProofRequest::set_allocated_recursive_proof_1(std::string* recursive_proof_1) {
  if (recursive_proof_1 != nullptr) {
    
  } else {
    
  }
  _impl_.recursive_proof_1_.SetAllocated(recursive_proof_1, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.recursive_proof_1_.IsDefault()) {
    _impl_.recursive_proof_1_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aggregator.v1.GenAggregatedProofRequest.recursive_proof_1)
}

// string recursive_proof_2 = 2;
inline void GenAggregatedProofRequest::clear_recursive_proof_2() {
  _impl_.recursive_proof_2_.ClearToEmpty();
}
inline const std::string& GenAggregatedProofRequest::recursive_proof_2() const {
  // @@protoc_insertion_point(field_get:aggregator.v1.GenAggregatedProofRequest.recursive_proof_2)
  return _internal_recursive_proof_2();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GenAggregatedProofRequest::set_recursive_proof_2(ArgT0&& arg0, ArgT... args) {
 
 _impl_.recursive_proof_2_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:aggregator.v1.GenAggregatedProofRequest.recursive_proof_2)
}
inline std::string* GenAggregatedProofRequest::mutable_recursive_proof_2() {
  std::string* _s = _internal_mutable_recursive_proof_2();
  // @@protoc_insertion_point(field_mutable:aggregator.v1.GenAggregatedProofRequest.recursive_proof_2)
  return _s;
}
inline const std::string& GenAggregatedProofRequest::_internal_recursive_proof_2() const {
  return _impl_.recursive_proof_2_.Get();
}
inline void GenAggregatedProofRequest::_internal_set_recursive_proof_2(const std::string& value) {
  
  _impl_.recursive_proof_2_.Set(value, GetArenaForAllocation());
}
inline std::string* GenAggregatedProofRequest::_internal_mutable_recursive_proof_2() {
  
  return _impl_.recursive_proof_2_.Mutable(GetArenaForAllocation());
}
inline std::string* GenAggregatedProofRequest::release_recursive_proof_2() {
  // @@protoc_insertion_point(field_release:aggregator.v1.GenAggregatedProofRequest.recursive_proof_2)
  return _impl_.recursive_proof_2_.Release();
}
inline void GenAggregatedProofRequest::set_allocated_recursive_proof_2(std::string* recursive_proof_2) {
  if (recursive_proof_2 != nullptr) {
    
  } else {
    
  }
  _impl_.recursive_proof_2_.SetAllocated(recursive_proof_2, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.recursive_proof_2_.IsDefault()) {
    _impl_.recursive_proof_2_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aggregator.v1.GenAggregatedProofRequest.recursive_proof_2)
}

// -------------------------------------------------------------------

// GenFinalProofRequest

// string recursive_proof = 1;
inline void GenFinalProofRequest::clear_recursive_proof() {
  _impl_.recursive_proof_.ClearToEmpty();
}
inline const std::string& GenFinalProofRequest::recursive_proof() const {
  // @@protoc_insertion_point(field_get:aggregator.v1.GenFinalProofRequest.recursive_proof)
  return _internal_recursive_proof();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GenFinalProofRequest::set_recursive_proof(ArgT0&& arg0, ArgT... args) {
 
 _impl_.recursive_proof_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:aggregator.v1.GenFinalProofRequest.recursive_proof)
}
inline std::string* GenFinalProofRequest::mutable_recursive_proof() {
  std::string* _s = _internal_mutable_recursive_proof();
  // @@protoc_insertion_point(field_mutable:aggregator.v1.GenFinalProofRequest.recursive_proof)
  return _s;
}
inline const std::string& GenFinalProofRequest::_internal_recursive_proof() const {
  return _impl_.recursive_proof_.Get();
}
inline void GenFinalProofRequest::_internal_set_recursive_proof(const std::string& value) {
  
  _impl_.recursive_proof_.Set(value, GetArenaForAllocation());
}
inline std::string* GenFinalProofRequest::_internal_mutable_recursive_proof() {
  
  return _impl_.recursive_proof_.Mutable(GetArenaForAllocation());
}
inline std::string* GenFinalProofRequest::release_recursive_proof() {
  // @@protoc_insertion_point(field_release:aggregator.v1.GenFinalProofRequest.recursive_proof)
  return _impl_.recursive_proof_.Release();
}
inline void GenFinalProofRequest::set_allocated_recursive_proof(std::string* recursive_proof) {
  if (recursive_proof != nullptr) {
    
  } else {
    
  }
  _impl_.recursive_proof_.SetAllocated(recursive_proof, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.recursive_proof_.IsDefault()) {
    _impl_.recursive_proof_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aggregator.v1.GenFinalProofRequest.recursive_proof)
}

// string aggregator_addr = 2;
inline void GenFinalProofRequest::clear_aggregator_addr() {
  _impl_.aggregator_addr_.ClearToEmpty();
}
inline const std::string& GenFinalProofRequest::aggregator_addr() const {
  // @@protoc_insertion_point(field_get:aggregator.v1.GenFinalProofRequest.aggregator_addr)
  return _internal_aggregator_addr();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GenFinalProofRequest::set_aggregator_addr(ArgT0&& arg0, ArgT... args) {
 
 _impl_.aggregator_addr_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:aggregator.v1.GenFinalProofRequest.aggregator_addr)
}
inline std::string* GenFinalProofRequest::mutable_aggregator_addr() {
  std::string* _s = _internal_mutable_aggregator_addr();
  // @@protoc_insertion_point(field_mutable:aggregator.v1.GenFinalProofRequest.aggregator_addr)
  return _s;
}
inline const std::string& GenFinalProofRequest::_internal_aggregator_addr() const {
  return _impl_.aggregator_addr_.Get();
}
inline void GenFinalProofRequest::_internal_set_aggregator_addr(const std::string& value) {
  
  _impl_.aggregator_addr_.Set(value, GetArenaForAllocation());
}
inline std::string* GenFinalProofRequest::_internal_mutable_aggregator_addr() {
  
  return _impl_.aggregator_addr_.Mutable(GetArenaForAllocation());
}
inline std::string* GenFinalProofRequest::release_aggregator_addr() {
  // @@protoc_insertion_point(field_release:aggregator.v1.GenFinalProofRequest.aggregator_addr)
  return _impl_.aggregator_addr_.Release();
}
inline void GenFinalProofRequest::set_allocated_aggregator_addr(std::string* aggregator_addr) {
  if (aggregator_addr != nullptr) {
    
  } else {
    
  }
  _impl_.aggregator_addr_.SetAllocated(aggregator_addr, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.aggregator_addr_.IsDefault()) {
    _impl_.aggregator_addr_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aggregator.v1.GenFinalProofRequest.aggregator_addr)
}

// -------------------------------------------------------------------

// CancelRequest

// string id = 1;
inline void CancelRequest::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& CancelRequest::id() const {
  // @@protoc_insertion_point(field_get:aggregator.v1.CancelRequest.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CancelRequest::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:aggregator.v1.CancelRequest.id)
}
inline std::string* CancelRequest::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:aggregator.v1.CancelRequest.id)
  return _s;
}
inline const std::string& CancelRequest::_internal_id() const {
  return _impl_.id_.Get();
}
inline void CancelRequest::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* CancelRequest::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* CancelRequest::release_id() {
  // @@protoc_insertion_point(field_release:aggregator.v1.CancelRequest.id)
  return _impl_.id_.Release();
}
inline void CancelRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aggregator.v1.CancelRequest.id)
}

// -------------------------------------------------------------------

// GetProofRequest

// string id = 1;
inline void GetProofRequest::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& GetProofRequest::id() const {
  // @@protoc_insertion_point(field_get:aggregator.v1.GetProofRequest.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetProofRequest::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:aggregator.v1.GetProofRequest.id)
}
inline std::string* GetProofRequest::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:aggregator.v1.GetProofRequest.id)
  return _s;
}
inline const std::string& GetProofRequest::_internal_id() const {
  return _impl_.id_.Get();
}
inline void GetProofRequest::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* GetProofRequest::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* GetProofRequest::release_id() {
  // @@protoc_insertion_point(field_release:aggregator.v1.GetProofRequest.id)
  return _impl_.id_.Release();
}
inline void GetProofRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aggregator.v1.GetProofRequest.id)
}

// uint64 timeout = 2;
inline void GetProofRequest::clear_timeout() {
  _impl_.timeout_ = uint64_t{0u};
}
inline uint64_t GetProofRequest::_internal_timeout() const {
  return _impl_.timeout_;
}
inline uint64_t GetProofRequest::timeout() const {
  // @@protoc_insertion_point(field_get:aggregator.v1.GetProofRequest.timeout)
  return _internal_timeout();
}
inline void GetProofRequest::_internal_set_timeout(uint64_t value) {
  
  _impl_.timeout_ = value;
}
inline void GetProofRequest::set_timeout(uint64_t value) {
  _internal_set_timeout(value);
  // @@protoc_insertion_point(field_set:aggregator.v1.GetProofRequest.timeout)
}

// -------------------------------------------------------------------

// GetStatusResponse

// .aggregator.v1.GetStatusResponse.Status status = 1;
inline void GetStatusResponse::clear_status() {
  _impl_.status_ = 0;
}
inline ::aggregator::v1::GetStatusResponse_Status GetStatusResponse::_internal_status() const {
  return static_cast< ::aggregator::v1::GetStatusResponse_Status >(_impl_.status_);
}
inline ::aggregator::v1::GetStatusResponse_Status GetStatusResponse::status() const {
  // @@protoc_insertion_point(field_get:aggregator.v1.GetStatusResponse.status)
  return _internal_status();
}
inline void GetStatusResponse::_internal_set_status(::aggregator::v1::GetStatusResponse_Status value) {
  
  _impl_.status_ = value;
}
inline void GetStatusResponse::set_status(::aggregator::v1::GetStatusResponse_Status value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:aggregator.v1.GetStatusResponse.status)
}

// string last_computed_request_id = 2;
inline void GetStatusResponse::clear_last_computed_request_id() {
  _impl_.last_computed_request_id_.ClearToEmpty();
}
inline const std::string& GetStatusResponse::last_computed_request_id() const {
  // @@protoc_insertion_point(field_get:aggregator.v1.GetStatusResponse.last_computed_request_id)
  return _internal_last_computed_request_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetStatusResponse::set_last_computed_request_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.last_computed_request_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:aggregator.v1.GetStatusResponse.last_computed_request_id)
}
inline std::string* GetStatusResponse::mutable_last_computed_request_id() {
  std::string* _s = _internal_mutable_last_computed_request_id();
  // @@protoc_insertion_point(field_mutable:aggregator.v1.GetStatusResponse.last_computed_request_id)
  return _s;
}
inline const std::string& GetStatusResponse::_internal_last_computed_request_id() const {
  return _impl_.last_computed_request_id_.Get();
}
inline void GetStatusResponse::_internal_set_last_computed_request_id(const std::string& value) {
  
  _impl_.last_computed_request_id_.Set(value, GetArenaForAllocation());
}
inline std::string* GetStatusResponse::_internal_mutable_last_computed_request_id() {
  
  return _impl_.last_computed_request_id_.Mutable(GetArenaForAllocation());
}
inline std::string* GetStatusResponse::release_last_computed_request_id() {
  // @@protoc_insertion_point(field_release:aggregator.v1.GetStatusResponse.last_computed_request_id)
  return _impl_.last_computed_request_id_.Release();
}
inline void GetStatusResponse::set_allocated_last_computed_request_id(std::string* last_computed_request_id) {
  if (last_computed_request_id != nullptr) {
    
  } else {
    
  }
  _impl_.last_computed_request_id_.SetAllocated(last_computed_request_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.last_computed_request_id_.IsDefault()) {
    _impl_.last_computed_request_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aggregator.v1.GetStatusResponse.last_computed_request_id)
}

// uint64 last_computed_end_time = 3;
inline void GetStatusResponse::clear_last_computed_end_time() {
  _impl_.last_computed_end_time_ = uint64_t{0u};
}
inline uint64_t GetStatusResponse::_internal_last_computed_end_time() const {
  return _impl_.last_computed_end_time_;
}
inline uint64_t GetStatusResponse::last_computed_end_time() const {
  // @@protoc_insertion_point(field_get:aggregator.v1.GetStatusResponse.last_computed_end_time)
  return _internal_last_computed_end_time();
}
inline void GetStatusResponse::_internal_set_last_computed_end_time(uint64_t value) {
  
  _impl_.last_computed_end_time_ = value;
}
inline void GetStatusResponse::set_last_computed_end_time(uint64_t value) {
  _internal_set_last_computed_end_time(value);
  // @@protoc_insertion_point(field_set:aggregator.v1.GetStatusResponse.last_computed_end_time)
}

// string current_computing_request_id = 4;
inline void GetStatusResponse::clear_current_computing_request_id() {
  _impl_.current_computing_request_id_.ClearToEmpty();
}
inline const std::string& GetStatusResponse::current_computing_request_id() const {
  // @@protoc_insertion_point(field_get:aggregator.v1.GetStatusResponse.current_computing_request_id)
  return _internal_current_computing_request_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetStatusResponse::set_current_computing_request_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.current_computing_request_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:aggregator.v1.GetStatusResponse.current_computing_request_id)
}
inline std::string* GetStatusResponse::mutable_current_computing_request_id() {
  std::string* _s = _internal_mutable_current_computing_request_id();
  // @@protoc_insertion_point(field_mutable:aggregator.v1.GetStatusResponse.current_computing_request_id)
  return _s;
}
inline const std::string& GetStatusResponse::_internal_current_computing_request_id() const {
  return _impl_.current_computing_request_id_.Get();
}
inline void GetStatusResponse::_internal_set_current_computing_request_id(const std::string& value) {
  
  _impl_.current_computing_request_id_.Set(value, GetArenaForAllocation());
}
inline std::string* GetStatusResponse::_internal_mutable_current_computing_request_id() {
  
  return _impl_.current_computing_request_id_.Mutable(GetArenaForAllocation());
}
inline std::string* GetStatusResponse::release_current_computing_request_id() {
  // @@protoc_insertion_point(field_release:aggregator.v1.GetStatusResponse.current_computing_request_id)
  return _impl_.current_computing_request_id_.Release();
}
inline void GetStatusResponse::set_allocated_current_computing_request_id(std::string* current_computing_request_id) {
  if (current_computing_request_id != nullptr) {
    
  } else {
    
  }
  _impl_.current_computing_request_id_.SetAllocated(current_computing_request_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.current_computing_request_id_.IsDefault()) {
    _impl_.current_computing_request_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aggregator.v1.GetStatusResponse.current_computing_request_id)
}

// uint64 current_computing_start_time = 5;
inline void GetStatusResponse::clear_current_computing_start_time() {
  _impl_.current_computing_start_time_ = uint64_t{0u};
}
inline uint64_t GetStatusResponse::_internal_current_computing_start_time() const {
  return _impl_.current_computing_start_time_;
}
inline uint64_t GetStatusResponse::current_computing_start_time() const {
  // @@protoc_insertion_point(field_get:aggregator.v1.GetStatusResponse.current_computing_start_time)
  return _internal_current_computing_start_time();
}
inline void GetStatusResponse::_internal_set_current_computing_start_time(uint64_t value) {
  
  _impl_.current_computing_start_time_ = value;
}
inline void GetStatusResponse::set_current_computing_start_time(uint64_t value) {
  _internal_set_current_computing_start_time(value);
  // @@protoc_insertion_point(field_set:aggregator.v1.GetStatusResponse.current_computing_start_time)
}

// string version_proto = 6;
inline void GetStatusResponse::clear_version_proto() {
  _impl_.version_proto_.ClearToEmpty();
}
inline const std::string& GetStatusResponse::version_proto() const {
  // @@protoc_insertion_point(field_get:aggregator.v1.GetStatusResponse.version_proto)
  return _internal_version_proto();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetStatusResponse::set_version_proto(ArgT0&& arg0, ArgT... args) {
 
 _impl_.version_proto_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:aggregator.v1.GetStatusResponse.version_proto)
}
inline std::string* GetStatusResponse::mutable_version_proto() {
  std::string* _s = _internal_mutable_version_proto();
  // @@protoc_insertion_point(field_mutable:aggregator.v1.GetStatusResponse.version_proto)
  return _s;
}
inline const std::string& GetStatusResponse::_internal_version_proto() const {
  return _impl_.version_proto_.Get();
}
inline void GetStatusResponse::_internal_set_version_proto(const std::string& value) {
  
  _impl_.version_proto_.Set(value, GetArenaForAllocation());
}
inline std::string* GetStatusResponse::_internal_mutable_version_proto() {
  
  return _impl_.version_proto_.Mutable(GetArenaForAllocation());
}
inline std::string* GetStatusResponse::release_version_proto() {
  // @@protoc_insertion_point(field_release:aggregator.v1.GetStatusResponse.version_proto)
  return _impl_.version_proto_.Release();
}
inline void GetStatusResponse::set_allocated_version_proto(std::string* version_proto) {
  if (version_proto != nullptr) {
    
  } else {
    
  }
  _impl_.version_proto_.SetAllocated(version_proto, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.version_proto_.IsDefault()) {
    _impl_.version_proto_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aggregator.v1.GetStatusResponse.version_proto)
}

// string version_server = 7;
inline void GetStatusResponse::clear_version_server() {
  _impl_.version_server_.ClearToEmpty();
}
inline const std::string& GetStatusResponse::version_server() const {
  // @@protoc_insertion_point(field_get:aggregator.v1.GetStatusResponse.version_server)
  return _internal_version_server();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetStatusResponse::set_version_server(ArgT0&& arg0, ArgT... args) {
 
 _impl_.version_server_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:aggregator.v1.GetStatusResponse.version_server)
}
inline std::string* GetStatusResponse::mutable_version_server() {
  std::string* _s = _internal_mutable_version_server();
  // @@protoc_insertion_point(field_mutable:aggregator.v1.GetStatusResponse.version_server)
  return _s;
}
inline const std::string& GetStatusResponse::_internal_version_server() const {
  return _impl_.version_server_.Get();
}
inline void GetStatusResponse::_internal_set_version_server(const std::string& value) {
  
  _impl_.version_server_.Set(value, GetArenaForAllocation());
}
inline std::string* GetStatusResponse::_internal_mutable_version_server() {
  
  return _impl_.version_server_.Mutable(GetArenaForAllocation());
}
inline std::string* GetStatusResponse::release_version_server() {
  // @@protoc_insertion_point(field_release:aggregator.v1.GetStatusResponse.version_server)
  return _impl_.version_server_.Release();
}
inline void GetStatusResponse::set_allocated_version_server(std::string* version_server) {
  if (version_server != nullptr) {
    
  } else {
    
  }
  _impl_.version_server_.SetAllocated(version_server, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.version_server_.IsDefault()) {
    _impl_.version_server_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aggregator.v1.GetStatusResponse.version_server)
}

// repeated string pending_request_queue_ids = 8;
inline int GetStatusResponse::_internal_pending_request_queue_ids_size() const {
  return _impl_.pending_request_queue_ids_.size();
}
inline int GetStatusResponse::pending_request_queue_ids_size() const {
  return _internal_pending_request_queue_ids_size();
}
inline void GetStatusResponse::clear_pending_request_queue_ids() {
  _impl_.pending_request_queue_ids_.Clear();
}
inline std::string* GetStatusResponse::add_pending_request_queue_ids() {
  std::string* _s = _internal_add_pending_request_queue_ids();
  // @@protoc_insertion_point(field_add_mutable:aggregator.v1.GetStatusResponse.pending_request_queue_ids)
  return _s;
}
inline const std::string& GetStatusResponse::_internal_pending_request_queue_ids(int index) const {
  return _impl_.pending_request_queue_ids_.Get(index);
}
inline const std::string& GetStatusResponse::pending_request_queue_ids(int index) const {
  // @@protoc_insertion_point(field_get:aggregator.v1.GetStatusResponse.pending_request_queue_ids)
  return _internal_pending_request_queue_ids(index);
}
inline std::string* GetStatusResponse::mutable_pending_request_queue_ids(int index) {
  // @@protoc_insertion_point(field_mutable:aggregator.v1.GetStatusResponse.pending_request_queue_ids)
  return _impl_.pending_request_queue_ids_.Mutable(index);
}
inline void GetStatusResponse::set_pending_request_queue_ids(int index, const std::string& value) {
  _impl_.pending_request_queue_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:aggregator.v1.GetStatusResponse.pending_request_queue_ids)
}
inline void GetStatusResponse::set_pending_request_queue_ids(int index, std::string&& value) {
  _impl_.pending_request_queue_ids_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:aggregator.v1.GetStatusResponse.pending_request_queue_ids)
}
inline void GetStatusResponse::set_pending_request_queue_ids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.pending_request_queue_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:aggregator.v1.GetStatusResponse.pending_request_queue_ids)
}
inline void GetStatusResponse::set_pending_request_queue_ids(int index, const char* value, size_t size) {
  _impl_.pending_request_queue_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:aggregator.v1.GetStatusResponse.pending_request_queue_ids)
}
inline std::string* GetStatusResponse::_internal_add_pending_request_queue_ids() {
  return _impl_.pending_request_queue_ids_.Add();
}
inline void GetStatusResponse::add_pending_request_queue_ids(const std::string& value) {
  _impl_.pending_request_queue_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:aggregator.v1.GetStatusResponse.pending_request_queue_ids)
}
inline void GetStatusResponse::add_pending_request_queue_ids(std::string&& value) {
  _impl_.pending_request_queue_ids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:aggregator.v1.GetStatusResponse.pending_request_queue_ids)
}
inline void GetStatusResponse::add_pending_request_queue_ids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.pending_request_queue_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:aggregator.v1.GetStatusResponse.pending_request_queue_ids)
}
inline void GetStatusResponse::add_pending_request_queue_ids(const char* value, size_t size) {
  _impl_.pending_request_queue_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:aggregator.v1.GetStatusResponse.pending_request_queue_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
GetStatusResponse::pending_request_queue_ids() const {
  // @@protoc_insertion_point(field_list:aggregator.v1.GetStatusResponse.pending_request_queue_ids)
  return _impl_.pending_request_queue_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
GetStatusResponse::mutable_pending_request_queue_ids() {
  // @@protoc_insertion_point(field_mutable_list:aggregator.v1.GetStatusResponse.pending_request_queue_ids)
  return &_impl_.pending_request_queue_ids_;
}

// string prover_name = 9;
inline void GetStatusResponse::clear_prover_name() {
  _impl_.prover_name_.ClearToEmpty();
}
inline const std::string& GetStatusResponse::prover_name() const {
  // @@protoc_insertion_point(field_get:aggregator.v1.GetStatusResponse.prover_name)
  return _internal_prover_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetStatusResponse::set_prover_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.prover_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:aggregator.v1.GetStatusResponse.prover_name)
}
inline std::string* GetStatusResponse::mutable_prover_name() {
  std::string* _s = _internal_mutable_prover_name();
  // @@protoc_insertion_point(field_mutable:aggregator.v1.GetStatusResponse.prover_name)
  return _s;
}
inline const std::string& GetStatusResponse::_internal_prover_name() const {
  return _impl_.prover_name_.Get();
}
inline void GetStatusResponse::_internal_set_prover_name(const std::string& value) {
  
  _impl_.prover_name_.Set(value, GetArenaForAllocation());
}
inline std::string* GetStatusResponse::_internal_mutable_prover_name() {
  
  return _impl_.prover_name_.Mutable(GetArenaForAllocation());
}
inline std::string* GetStatusResponse::release_prover_name() {
  // @@protoc_insertion_point(field_release:aggregator.v1.GetStatusResponse.prover_name)
  return _impl_.prover_name_.Release();
}
inline void GetStatusResponse::set_allocated_prover_name(std::string* prover_name) {
  if (prover_name != nullptr) {
    
  } else {
    
  }
  _impl_.prover_name_.SetAllocated(prover_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.prover_name_.IsDefault()) {
    _impl_.prover_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aggregator.v1.GetStatusResponse.prover_name)
}

// string prover_id = 10;
inline void GetStatusResponse::clear_prover_id() {
  _impl_.prover_id_.ClearToEmpty();
}
inline const std::string& GetStatusResponse::prover_id() const {
  // @@protoc_insertion_point(field_get:aggregator.v1.GetStatusResponse.prover_id)
  return _internal_prover_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetStatusResponse::set_prover_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.prover_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:aggregator.v1.GetStatusResponse.prover_id)
}
inline std::string* GetStatusResponse::mutable_prover_id() {
  std::string* _s = _internal_mutable_prover_id();
  // @@protoc_insertion_point(field_mutable:aggregator.v1.GetStatusResponse.prover_id)
  return _s;
}
inline const std::string& GetStatusResponse::_internal_prover_id() const {
  return _impl_.prover_id_.Get();
}
inline void GetStatusResponse::_internal_set_prover_id(const std::string& value) {
  
  _impl_.prover_id_.Set(value, GetArenaForAllocation());
}
inline std::string* GetStatusResponse::_internal_mutable_prover_id() {
  
  return _impl_.prover_id_.Mutable(GetArenaForAllocation());
}
inline std::string* GetStatusResponse::release_prover_id() {
  // @@protoc_insertion_point(field_release:aggregator.v1.GetStatusResponse.prover_id)
  return _impl_.prover_id_.Release();
}
inline void GetStatusResponse::set_allocated_prover_id(std::string* prover_id) {
  if (prover_id != nullptr) {
    
  } else {
    
  }
  _impl_.prover_id_.SetAllocated(prover_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.prover_id_.IsDefault()) {
    _impl_.prover_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aggregator.v1.GetStatusResponse.prover_id)
}

// uint64 number_of_cores = 11;
inline void GetStatusResponse::clear_number_of_cores() {
  _impl_.number_of_cores_ = uint64_t{0u};
}
inline uint64_t GetStatusResponse::_internal_number_of_cores() const {
  return _impl_.number_of_cores_;
}
inline uint64_t GetStatusResponse::number_of_cores() const {
  // @@protoc_insertion_point(field_get:aggregator.v1.GetStatusResponse.number_of_cores)
  return _internal_number_of_cores();
}
inline void GetStatusResponse::_internal_set_number_of_cores(uint64_t value) {
  
  _impl_.number_of_cores_ = value;
}
inline void GetStatusResponse::set_number_of_cores(uint64_t value) {
  _internal_set_number_of_cores(value);
  // @@protoc_insertion_point(field_set:aggregator.v1.GetStatusResponse.number_of_cores)
}

// uint64 total_memory = 12;
inline void GetStatusResponse::clear_total_memory() {
  _impl_.total_memory_ = uint64_t{0u};
}
inline uint64_t GetStatusResponse::_internal_total_memory() const {
  return _impl_.total_memory_;
}
inline uint64_t GetStatusResponse::total_memory() const {
  // @@protoc_insertion_point(field_get:aggregator.v1.GetStatusResponse.total_memory)
  return _internal_total_memory();
}
inline void GetStatusResponse::_internal_set_total_memory(uint64_t value) {
  
  _impl_.total_memory_ = value;
}
inline void GetStatusResponse::set_total_memory(uint64_t value) {
  _internal_set_total_memory(value);
  // @@protoc_insertion_point(field_set:aggregator.v1.GetStatusResponse.total_memory)
}

// uint64 free_memory = 13;
inline void GetStatusResponse::clear_free_memory() {
  _impl_.free_memory_ = uint64_t{0u};
}
inline uint64_t GetStatusResponse::_internal_free_memory() const {
  return _impl_.free_memory_;
}
inline uint64_t GetStatusResponse::free_memory() const {
  // @@protoc_insertion_point(field_get:aggregator.v1.GetStatusResponse.free_memory)
  return _internal_free_memory();
}
inline void GetStatusResponse::_internal_set_free_memory(uint64_t value) {
  
  _impl_.free_memory_ = value;
}
inline void GetStatusResponse::set_free_memory(uint64_t value) {
  _internal_set_free_memory(value);
  // @@protoc_insertion_point(field_set:aggregator.v1.GetStatusResponse.free_memory)
}

// uint64 fork_id = 14;
inline void GetStatusResponse::clear_fork_id() {
  _impl_.fork_id_ = uint64_t{0u};
}
inline uint64_t GetStatusResponse::_internal_fork_id() const {
  return _impl_.fork_id_;
}
inline uint64_t GetStatusResponse::fork_id() const {
  // @@protoc_insertion_point(field_get:aggregator.v1.GetStatusResponse.fork_id)
  return _internal_fork_id();
}
inline void GetStatusResponse::_internal_set_fork_id(uint64_t value) {
  
  _impl_.fork_id_ = value;
}
inline void GetStatusResponse::set_fork_id(uint64_t value) {
  _internal_set_fork_id(value);
  // @@protoc_insertion_point(field_set:aggregator.v1.GetStatusResponse.fork_id)
}

// -------------------------------------------------------------------

// GenBatchProofResponse

// string id = 1;
inline void GenBatchProofResponse::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& GenBatchProofResponse::id() const {
  // @@protoc_insertion_point(field_get:aggregator.v1.GenBatchProofResponse.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GenBatchProofResponse::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:aggregator.v1.GenBatchProofResponse.id)
}
inline std::string* GenBatchProofResponse::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:aggregator.v1.GenBatchProofResponse.id)
  return _s;
}
inline const std::string& GenBatchProofResponse::_internal_id() const {
  return _impl_.id_.Get();
}
inline void GenBatchProofResponse::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* GenBatchProofResponse::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* GenBatchProofResponse::release_id() {
  // @@protoc_insertion_point(field_release:aggregator.v1.GenBatchProofResponse.id)
  return _impl_.id_.Release();
}
inline void GenBatchProofResponse::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aggregator.v1.GenBatchProofResponse.id)
}

// .aggregator.v1.Result result = 2;
inline void GenBatchProofResponse::clear_result() {
  _impl_.result_ = 0;
}
inline ::aggregator::v1::Result GenBatchProofResponse::_internal_result() const {
  return static_cast< ::aggregator::v1::Result >(_impl_.result_);
}
inline ::aggregator::v1::Result GenBatchProofResponse::result() const {
  // @@protoc_insertion_point(field_get:aggregator.v1.GenBatchProofResponse.result)
  return _internal_result();
}
inline void GenBatchProofResponse::_internal_set_result(::aggregator::v1::Result value) {
  
  _impl_.result_ = value;
}
inline void GenBatchProofResponse::set_result(::aggregator::v1::Result value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:aggregator.v1.GenBatchProofResponse.result)
}

// -------------------------------------------------------------------

// GenAggregatedProofResponse

// string id = 1;
inline void GenAggregatedProofResponse::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& GenAggregatedProofResponse::id() const {
  // @@protoc_insertion_point(field_get:aggregator.v1.GenAggregatedProofResponse.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GenAggregatedProofResponse::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:aggregator.v1.GenAggregatedProofResponse.id)
}
inline std::string* GenAggregatedProofResponse::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:aggregator.v1.GenAggregatedProofResponse.id)
  return _s;
}
inline const std::string& GenAggregatedProofResponse::_internal_id() const {
  return _impl_.id_.Get();
}
inline void GenAggregatedProofResponse::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* GenAggregatedProofResponse::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* GenAggregatedProofResponse::release_id() {
  // @@protoc_insertion_point(field_release:aggregator.v1.GenAggregatedProofResponse.id)
  return _impl_.id_.Release();
}
inline void GenAggregatedProofResponse::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aggregator.v1.GenAggregatedProofResponse.id)
}

// .aggregator.v1.Result result = 2;
inline void GenAggregatedProofResponse::clear_result() {
  _impl_.result_ = 0;
}
inline ::aggregator::v1::Result GenAggregatedProofResponse::_internal_result() const {
  return static_cast< ::aggregator::v1::Result >(_impl_.result_);
}
inline ::aggregator::v1::Result GenAggregatedProofResponse::result() const {
  // @@protoc_insertion_point(field_get:aggregator.v1.GenAggregatedProofResponse.result)
  return _internal_result();
}
inline void GenAggregatedProofResponse::_internal_set_result(::aggregator::v1::Result value) {
  
  _impl_.result_ = value;
}
inline void GenAggregatedProofResponse::set_result(::aggregator::v1::Result value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:aggregator.v1.GenAggregatedProofResponse.result)
}

// -------------------------------------------------------------------

// GenFinalProofResponse

// string id = 1;
inline void GenFinalProofResponse::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& GenFinalProofResponse::id() const {
  // @@protoc_insertion_point(field_get:aggregator.v1.GenFinalProofResponse.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GenFinalProofResponse::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:aggregator.v1.GenFinalProofResponse.id)
}
inline std::string* GenFinalProofResponse::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:aggregator.v1.GenFinalProofResponse.id)
  return _s;
}
inline const std::string& GenFinalProofResponse::_internal_id() const {
  return _impl_.id_.Get();
}
inline void GenFinalProofResponse::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* GenFinalProofResponse::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* GenFinalProofResponse::release_id() {
  // @@protoc_insertion_point(field_release:aggregator.v1.GenFinalProofResponse.id)
  return _impl_.id_.Release();
}
inline void GenFinalProofResponse::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aggregator.v1.GenFinalProofResponse.id)
}

// .aggregator.v1.Result result = 2;
inline void GenFinalProofResponse::clear_result() {
  _impl_.result_ = 0;
}
inline ::aggregator::v1::Result GenFinalProofResponse::_internal_result() const {
  return static_cast< ::aggregator::v1::Result >(_impl_.result_);
}
inline ::aggregator::v1::Result GenFinalProofResponse::result() const {
  // @@protoc_insertion_point(field_get:aggregator.v1.GenFinalProofResponse.result)
  return _internal_result();
}
inline void GenFinalProofResponse::_internal_set_result(::aggregator::v1::Result value) {
  
  _impl_.result_ = value;
}
inline void GenFinalProofResponse::set_result(::aggregator::v1::Result value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:aggregator.v1.GenFinalProofResponse.result)
}

// -------------------------------------------------------------------

// CancelResponse

// .aggregator.v1.Result result = 1;
inline void CancelResponse::clear_result() {
  _impl_.result_ = 0;
}
inline ::aggregator::v1::Result CancelResponse::_internal_result() const {
  return static_cast< ::aggregator::v1::Result >(_impl_.result_);
}
inline ::aggregator::v1::Result CancelResponse::result() const {
  // @@protoc_insertion_point(field_get:aggregator.v1.CancelResponse.result)
  return _internal_result();
}
inline void CancelResponse::_internal_set_result(::aggregator::v1::Result value) {
  
  _impl_.result_ = value;
}
inline void CancelResponse::set_result(::aggregator::v1::Result value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:aggregator.v1.CancelResponse.result)
}

// -------------------------------------------------------------------

// GetProofResponse

// string id = 1;
inline void GetProofResponse::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& GetProofResponse::id() const {
  // @@protoc_insertion_point(field_get:aggregator.v1.GetProofResponse.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetProofResponse::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:aggregator.v1.GetProofResponse.id)
}
inline std::string* GetProofResponse::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:aggregator.v1.GetProofResponse.id)
  return _s;
}
inline const std::string& GetProofResponse::_internal_id() const {
  return _impl_.id_.Get();
}
inline void GetProofResponse::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* GetProofResponse::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* GetProofResponse::release_id() {
  // @@protoc_insertion_point(field_release:aggregator.v1.GetProofResponse.id)
  return _impl_.id_.Release();
}
inline void GetProofResponse::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aggregator.v1.GetProofResponse.id)
}

// .aggregator.v1.FinalProof final_proof = 2;
inline bool GetProofResponse::_internal_has_final_proof() const {
  return proof_case() == kFinalProof;
}
inline bool GetProofResponse::has_final_proof() const {
  return _internal_has_final_proof();
}
inline void GetProofResponse::set_has_final_proof() {
  _impl_._oneof_case_[0] = kFinalProof;
}
inline void GetProofResponse::clear_final_proof() {
  if (_internal_has_final_proof()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.proof_.final_proof_;
    }
    clear_has_proof();
  }
}
inline ::aggregator::v1::FinalProof* GetProofResponse::release_final_proof() {
  // @@protoc_insertion_point(field_release:aggregator.v1.GetProofResponse.final_proof)
  if (_internal_has_final_proof()) {
    clear_has_proof();
    ::aggregator::v1::FinalProof* temp = _impl_.proof_.final_proof_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.proof_.final_proof_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::aggregator::v1::FinalProof& GetProofResponse::_internal_final_proof() const {
  return _internal_has_final_proof()
      ? *_impl_.proof_.final_proof_
      : reinterpret_cast< ::aggregator::v1::FinalProof&>(::aggregator::v1::_FinalProof_default_instance_);
}
inline const ::aggregator::v1::FinalProof& GetProofResponse::final_proof() const {
  // @@protoc_insertion_point(field_get:aggregator.v1.GetProofResponse.final_proof)
  return _internal_final_proof();
}
inline ::aggregator::v1::FinalProof* GetProofResponse::unsafe_arena_release_final_proof() {
  // @@protoc_insertion_point(field_unsafe_arena_release:aggregator.v1.GetProofResponse.final_proof)
  if (_internal_has_final_proof()) {
    clear_has_proof();
    ::aggregator::v1::FinalProof* temp = _impl_.proof_.final_proof_;
    _impl_.proof_.final_proof_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void GetProofResponse::unsafe_arena_set_allocated_final_proof(::aggregator::v1::FinalProof* final_proof) {
  clear_proof();
  if (final_proof) {
    set_has_final_proof();
    _impl_.proof_.final_proof_ = final_proof;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aggregator.v1.GetProofResponse.final_proof)
}
inline ::aggregator::v1::FinalProof* GetProofResponse::_internal_mutable_final_proof() {
  if (!_internal_has_final_proof()) {
    clear_proof();
    set_has_final_proof();
    _impl_.proof_.final_proof_ = CreateMaybeMessage< ::aggregator::v1::FinalProof >(GetArenaForAllocation());
  }
  return _impl_.proof_.final_proof_;
}
inline ::aggregator::v1::FinalProof* GetProofResponse::mutable_final_proof() {
  ::aggregator::v1::FinalProof* _msg = _internal_mutable_final_proof();
  // @@protoc_insertion_point(field_mutable:aggregator.v1.GetProofResponse.final_proof)
  return _msg;
}

// string recursive_proof = 3;
inline bool GetProofResponse::_internal_has_recursive_proof() const {
  return proof_case() == kRecursiveProof;
}
inline bool GetProofResponse::has_recursive_proof() const {
  return _internal_has_recursive_proof();
}
inline void GetProofResponse::set_has_recursive_proof() {
  _impl_._oneof_case_[0] = kRecursiveProof;
}
inline void GetProofResponse::clear_recursive_proof() {
  if (_internal_has_recursive_proof()) {
    _impl_.proof_.recursive_proof_.Destroy();
    clear_has_proof();
  }
}
inline const std::string& GetProofResponse::recursive_proof() const {
  // @@protoc_insertion_point(field_get:aggregator.v1.GetProofResponse.recursive_proof)
  return _internal_recursive_proof();
}
template <typename ArgT0, typename... ArgT>
inline void GetProofResponse::set_recursive_proof(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_recursive_proof()) {
    clear_proof();
    set_has_recursive_proof();
    _impl_.proof_.recursive_proof_.InitDefault();
  }
  _impl_.proof_.recursive_proof_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:aggregator.v1.GetProofResponse.recursive_proof)
}
inline std::string* GetProofResponse::mutable_recursive_proof() {
  std::string* _s = _internal_mutable_recursive_proof();
  // @@protoc_insertion_point(field_mutable:aggregator.v1.GetProofResponse.recursive_proof)
  return _s;
}
inline const std::string& GetProofResponse::_internal_recursive_proof() const {
  if (_internal_has_recursive_proof()) {
    return _impl_.proof_.recursive_proof_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void GetProofResponse::_internal_set_recursive_proof(const std::string& value) {
  if (!_internal_has_recursive_proof()) {
    clear_proof();
    set_has_recursive_proof();
    _impl_.proof_.recursive_proof_.InitDefault();
  }
  _impl_.proof_.recursive_proof_.Set(value, GetArenaForAllocation());
}
inline std::string* GetProofResponse::_internal_mutable_recursive_proof() {
  if (!_internal_has_recursive_proof()) {
    clear_proof();
    set_has_recursive_proof();
    _impl_.proof_.recursive_proof_.InitDefault();
  }
  return _impl_.proof_.recursive_proof_.Mutable(      GetArenaForAllocation());
}
inline std::string* GetProofResponse::release_recursive_proof() {
  // @@protoc_insertion_point(field_release:aggregator.v1.GetProofResponse.recursive_proof)
  if (_internal_has_recursive_proof()) {
    clear_has_proof();
    return _impl_.proof_.recursive_proof_.Release();
  } else {
    return nullptr;
  }
}
inline void GetProofResponse::set_allocated_recursive_proof(std::string* recursive_proof) {
  if (has_proof()) {
    clear_proof();
  }
  if (recursive_proof != nullptr) {
    set_has_recursive_proof();
    _impl_.proof_.recursive_proof_.InitAllocated(recursive_proof, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:aggregator.v1.GetProofResponse.recursive_proof)
}

// .aggregator.v1.GetProofResponse.Result result = 4;
inline void GetProofResponse::clear_result() {
  _impl_.result_ = 0;
}
inline ::aggregator::v1::GetProofResponse_Result GetProofResponse::_internal_result() const {
  return static_cast< ::aggregator::v1::GetProofResponse_Result >(_impl_.result_);
}
inline ::aggregator::v1::GetProofResponse_Result GetProofResponse::result() const {
  // @@protoc_insertion_point(field_get:aggregator.v1.GetProofResponse.result)
  return _internal_result();
}
inline void GetProofResponse::_internal_set_result(::aggregator::v1::GetProofResponse_Result value) {
  
  _impl_.result_ = value;
}
inline void GetProofResponse::set_result(::aggregator::v1::GetProofResponse_Result value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:aggregator.v1.GetProofResponse.result)
}

// string result_string = 5;
inline void GetProofResponse::clear_result_string() {
  _impl_.result_string_.ClearToEmpty();
}
inline const std::string& GetProofResponse::result_string() const {
  // @@protoc_insertion_point(field_get:aggregator.v1.GetProofResponse.result_string)
  return _internal_result_string();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetProofResponse::set_result_string(ArgT0&& arg0, ArgT... args) {
 
 _impl_.result_string_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:aggregator.v1.GetProofResponse.result_string)
}
inline std::string* GetProofResponse::mutable_result_string() {
  std::string* _s = _internal_mutable_result_string();
  // @@protoc_insertion_point(field_mutable:aggregator.v1.GetProofResponse.result_string)
  return _s;
}
inline const std::string& GetProofResponse::_internal_result_string() const {
  return _impl_.result_string_.Get();
}
inline void GetProofResponse::_internal_set_result_string(const std::string& value) {
  
  _impl_.result_string_.Set(value, GetArenaForAllocation());
}
inline std::string* GetProofResponse::_internal_mutable_result_string() {
  
  return _impl_.result_string_.Mutable(GetArenaForAllocation());
}
inline std::string* GetProofResponse::release_result_string() {
  // @@protoc_insertion_point(field_release:aggregator.v1.GetProofResponse.result_string)
  return _impl_.result_string_.Release();
}
inline void GetProofResponse::set_allocated_result_string(std::string* result_string) {
  if (result_string != nullptr) {
    
  } else {
    
  }
  _impl_.result_string_.SetAllocated(result_string, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.result_string_.IsDefault()) {
    _impl_.result_string_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aggregator.v1.GetProofResponse.result_string)
}

inline bool GetProofResponse::has_proof() const {
  return proof_case() != PROOF_NOT_SET;
}
inline void GetProofResponse::clear_has_proof() {
  _impl_._oneof_case_[0] = PROOF_NOT_SET;
}
inline GetProofResponse::ProofCase GetProofResponse::proof_case() const {
  return GetProofResponse::ProofCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// FinalProof

// string proof = 1;
inline void FinalProof::clear_proof() {
  _impl_.proof_.ClearToEmpty();
}
inline const std::string& FinalProof::proof() const {
  // @@protoc_insertion_point(field_get:aggregator.v1.FinalProof.proof)
  return _internal_proof();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FinalProof::set_proof(ArgT0&& arg0, ArgT... args) {
 
 _impl_.proof_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:aggregator.v1.FinalProof.proof)
}
inline std::string* FinalProof::mutable_proof() {
  std::string* _s = _internal_mutable_proof();
  // @@protoc_insertion_point(field_mutable:aggregator.v1.FinalProof.proof)
  return _s;
}
inline const std::string& FinalProof::_internal_proof() const {
  return _impl_.proof_.Get();
}
inline void FinalProof::_internal_set_proof(const std::string& value) {
  
  _impl_.proof_.Set(value, GetArenaForAllocation());
}
inline std::string* FinalProof::_internal_mutable_proof() {
  
  return _impl_.proof_.Mutable(GetArenaForAllocation());
}
inline std::string* FinalProof::release_proof() {
  // @@protoc_insertion_point(field_release:aggregator.v1.FinalProof.proof)
  return _impl_.proof_.Release();
}
inline void FinalProof::set_allocated_proof(std::string* proof) {
  if (proof != nullptr) {
    
  } else {
    
  }
  _impl_.proof_.SetAllocated(proof, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.proof_.IsDefault()) {
    _impl_.proof_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aggregator.v1.FinalProof.proof)
}

// .aggregator.v1.PublicInputsExtended public = 2;
inline bool FinalProof::_internal_has_public_() const {
  return this != internal_default_instance() && _impl_.public__ != nullptr;
}
inline bool FinalProof::has_public_() const {
  return _internal_has_public_();
}
inline void FinalProof::clear_public_() {
  if (GetArenaForAllocation() == nullptr && _impl_.public__ != nullptr) {
    delete _impl_.public__;
  }
  _impl_.public__ = nullptr;
}
inline const ::aggregator::v1::PublicInputsExtended& FinalProof::_internal_public_() const {
  const ::aggregator::v1::PublicInputsExtended* p = _impl_.public__;
  return p != nullptr ? *p : reinterpret_cast<const ::aggregator::v1::PublicInputsExtended&>(
      ::aggregator::v1::_PublicInputsExtended_default_instance_);
}
inline const ::aggregator::v1::PublicInputsExtended& FinalProof::public_() const {
  // @@protoc_insertion_point(field_get:aggregator.v1.FinalProof.public)
  return _internal_public_();
}
inline void FinalProof::unsafe_arena_set_allocated_public_(
    ::aggregator::v1::PublicInputsExtended* public_) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.public__);
  }
  _impl_.public__ = public_;
  if (public_) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aggregator.v1.FinalProof.public)
}
inline ::aggregator::v1::PublicInputsExtended* FinalProof::release_public_() {
  
  ::aggregator::v1::PublicInputsExtended* temp = _impl_.public__;
  _impl_.public__ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::aggregator::v1::PublicInputsExtended* FinalProof::unsafe_arena_release_public_() {
  // @@protoc_insertion_point(field_release:aggregator.v1.FinalProof.public)
  
  ::aggregator::v1::PublicInputsExtended* temp = _impl_.public__;
  _impl_.public__ = nullptr;
  return temp;
}
inline ::aggregator::v1::PublicInputsExtended* FinalProof::_internal_mutable_public_() {
  
  if (_impl_.public__ == nullptr) {
    auto* p = CreateMaybeMessage<::aggregator::v1::PublicInputsExtended>(GetArenaForAllocation());
    _impl_.public__ = p;
  }
  return _impl_.public__;
}
inline ::aggregator::v1::PublicInputsExtended* FinalProof::mutable_public_() {
  ::aggregator::v1::PublicInputsExtended* _msg = _internal_mutable_public_();
  // @@protoc_insertion_point(field_mutable:aggregator.v1.FinalProof.public)
  return _msg;
}
inline void FinalProof::set_allocated_public_(::aggregator::v1::PublicInputsExtended* public_) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.public__;
  }
  if (public_) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(public_);
    if (message_arena != submessage_arena) {
      public_ = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, public_, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.public__ = public_;
  // @@protoc_insertion_point(field_set_allocated:aggregator.v1.FinalProof.public)
}

// -------------------------------------------------------------------

// PublicInputs

// bytes old_state_root = 1;
inline void PublicInputs::clear_old_state_root() {
  _impl_.old_state_root_.ClearToEmpty();
}
inline const std::string& PublicInputs::old_state_root() const {
  // @@protoc_insertion_point(field_get:aggregator.v1.PublicInputs.old_state_root)
  return _internal_old_state_root();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PublicInputs::set_old_state_root(ArgT0&& arg0, ArgT... args) {
 
 _impl_.old_state_root_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:aggregator.v1.PublicInputs.old_state_root)
}
inline std::string* PublicInputs::mutable_old_state_root() {
  std::string* _s = _internal_mutable_old_state_root();
  // @@protoc_insertion_point(field_mutable:aggregator.v1.PublicInputs.old_state_root)
  return _s;
}
inline const std::string& PublicInputs::_internal_old_state_root() const {
  return _impl_.old_state_root_.Get();
}
inline void PublicInputs::_internal_set_old_state_root(const std::string& value) {
  
  _impl_.old_state_root_.Set(value, GetArenaForAllocation());
}
inline std::string* PublicInputs::_internal_mutable_old_state_root() {
  
  return _impl_.old_state_root_.Mutable(GetArenaForAllocation());
}
inline std::string* PublicInputs::release_old_state_root() {
  // @@protoc_insertion_point(field_release:aggregator.v1.PublicInputs.old_state_root)
  return _impl_.old_state_root_.Release();
}
inline void PublicInputs::set_allocated_old_state_root(std::string* old_state_root) {
  if (old_state_root != nullptr) {
    
  } else {
    
  }
  _impl_.old_state_root_.SetAllocated(old_state_root, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.old_state_root_.IsDefault()) {
    _impl_.old_state_root_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aggregator.v1.PublicInputs.old_state_root)
}

// bytes old_acc_input_hash = 2;
inline void PublicInputs::clear_old_acc_input_hash() {
  _impl_.old_acc_input_hash_.ClearToEmpty();
}
inline const std::string& PublicInputs::old_acc_input_hash() const {
  // @@protoc_insertion_point(field_get:aggregator.v1.PublicInputs.old_acc_input_hash)
  return _internal_old_acc_input_hash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PublicInputs::set_old_acc_input_hash(ArgT0&& arg0, ArgT... args) {
 
 _impl_.old_acc_input_hash_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:aggregator.v1.PublicInputs.old_acc_input_hash)
}
inline std::string* PublicInputs::mutable_old_acc_input_hash() {
  std::string* _s = _internal_mutable_old_acc_input_hash();
  // @@protoc_insertion_point(field_mutable:aggregator.v1.PublicInputs.old_acc_input_hash)
  return _s;
}
inline const std::string& PublicInputs::_internal_old_acc_input_hash() const {
  return _impl_.old_acc_input_hash_.Get();
}
inline void PublicInputs::_internal_set_old_acc_input_hash(const std::string& value) {
  
  _impl_.old_acc_input_hash_.Set(value, GetArenaForAllocation());
}
inline std::string* PublicInputs::_internal_mutable_old_acc_input_hash() {
  
  return _impl_.old_acc_input_hash_.Mutable(GetArenaForAllocation());
}
inline std::string* PublicInputs::release_old_acc_input_hash() {
  // @@protoc_insertion_point(field_release:aggregator.v1.PublicInputs.old_acc_input_hash)
  return _impl_.old_acc_input_hash_.Release();
}
inline void PublicInputs::set_allocated_old_acc_input_hash(std::string* old_acc_input_hash) {
  if (old_acc_input_hash != nullptr) {
    
  } else {
    
  }
  _impl_.old_acc_input_hash_.SetAllocated(old_acc_input_hash, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.old_acc_input_hash_.IsDefault()) {
    _impl_.old_acc_input_hash_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aggregator.v1.PublicInputs.old_acc_input_hash)
}

// uint64 old_batch_num = 3;
inline void PublicInputs::clear_old_batch_num() {
  _impl_.old_batch_num_ = uint64_t{0u};
}
inline uint64_t PublicInputs::_internal_old_batch_num() const {
  return _impl_.old_batch_num_;
}
inline uint64_t PublicInputs::old_batch_num() const {
  // @@protoc_insertion_point(field_get:aggregator.v1.PublicInputs.old_batch_num)
  return _internal_old_batch_num();
}
inline void PublicInputs::_internal_set_old_batch_num(uint64_t value) {
  
  _impl_.old_batch_num_ = value;
}
inline void PublicInputs::set_old_batch_num(uint64_t value) {
  _internal_set_old_batch_num(value);
  // @@protoc_insertion_point(field_set:aggregator.v1.PublicInputs.old_batch_num)
}

// uint64 chain_id = 4;
inline void PublicInputs::clear_chain_id() {
  _impl_.chain_id_ = uint64_t{0u};
}
inline uint64_t PublicInputs::_internal_chain_id() const {
  return _impl_.chain_id_;
}
inline uint64_t PublicInputs::chain_id() const {
  // @@protoc_insertion_point(field_get:aggregator.v1.PublicInputs.chain_id)
  return _internal_chain_id();
}
inline void PublicInputs::_internal_set_chain_id(uint64_t value) {
  
  _impl_.chain_id_ = value;
}
inline void PublicInputs::set_chain_id(uint64_t value) {
  _internal_set_chain_id(value);
  // @@protoc_insertion_point(field_set:aggregator.v1.PublicInputs.chain_id)
}

// uint64 fork_id = 5;
inline void PublicInputs::clear_fork_id() {
  _impl_.fork_id_ = uint64_t{0u};
}
inline uint64_t PublicInputs::_internal_fork_id() const {
  return _impl_.fork_id_;
}
inline uint64_t PublicInputs::fork_id() const {
  // @@protoc_insertion_point(field_get:aggregator.v1.PublicInputs.fork_id)
  return _internal_fork_id();
}
inline void PublicInputs::_internal_set_fork_id(uint64_t value) {
  
  _impl_.fork_id_ = value;
}
inline void PublicInputs::set_fork_id(uint64_t value) {
  _internal_set_fork_id(value);
  // @@protoc_insertion_point(field_set:aggregator.v1.PublicInputs.fork_id)
}

// bytes batch_l2_data = 6;
inline void PublicInputs::clear_batch_l2_data() {
  _impl_.batch_l2_data_.ClearToEmpty();
}
inline const std::string& PublicInputs::batch_l2_data() const {
  // @@protoc_insertion_point(field_get:aggregator.v1.PublicInputs.batch_l2_data)
  return _internal_batch_l2_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PublicInputs::set_batch_l2_data(ArgT0&& arg0, ArgT... args) {
 
 _impl_.batch_l2_data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:aggregator.v1.PublicInputs.batch_l2_data)
}
inline std::string* PublicInputs::mutable_batch_l2_data() {
  std::string* _s = _internal_mutable_batch_l2_data();
  // @@protoc_insertion_point(field_mutable:aggregator.v1.PublicInputs.batch_l2_data)
  return _s;
}
inline const std::string& PublicInputs::_internal_batch_l2_data() const {
  return _impl_.batch_l2_data_.Get();
}
inline void PublicInputs::_internal_set_batch_l2_data(const std::string& value) {
  
  _impl_.batch_l2_data_.Set(value, GetArenaForAllocation());
}
inline std::string* PublicInputs::_internal_mutable_batch_l2_data() {
  
  return _impl_.batch_l2_data_.Mutable(GetArenaForAllocation());
}
inline std::string* PublicInputs::release_batch_l2_data() {
  // @@protoc_insertion_point(field_release:aggregator.v1.PublicInputs.batch_l2_data)
  return _impl_.batch_l2_data_.Release();
}
inline void PublicInputs::set_allocated_batch_l2_data(std::string* batch_l2_data) {
  if (batch_l2_data != nullptr) {
    
  } else {
    
  }
  _impl_.batch_l2_data_.SetAllocated(batch_l2_data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.batch_l2_data_.IsDefault()) {
    _impl_.batch_l2_data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aggregator.v1.PublicInputs.batch_l2_data)
}

// bytes global_exit_root = 7;
inline void PublicInputs::clear_global_exit_root() {
  _impl_.global_exit_root_.ClearToEmpty();
}
inline const std::string& PublicInputs::global_exit_root() const {
  // @@protoc_insertion_point(field_get:aggregator.v1.PublicInputs.global_exit_root)
  return _internal_global_exit_root();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PublicInputs::set_global_exit_root(ArgT0&& arg0, ArgT... args) {
 
 _impl_.global_exit_root_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:aggregator.v1.PublicInputs.global_exit_root)
}
inline std::string* PublicInputs::mutable_global_exit_root() {
  std::string* _s = _internal_mutable_global_exit_root();
  // @@protoc_insertion_point(field_mutable:aggregator.v1.PublicInputs.global_exit_root)
  return _s;
}
inline const std::string& PublicInputs::_internal_global_exit_root() const {
  return _impl_.global_exit_root_.Get();
}
inline void PublicInputs::_internal_set_global_exit_root(const std::string& value) {
  
  _impl_.global_exit_root_.Set(value, GetArenaForAllocation());
}
inline std::string* PublicInputs::_internal_mutable_global_exit_root() {
  
  return _impl_.global_exit_root_.Mutable(GetArenaForAllocation());
}
inline std::string* PublicInputs::release_global_exit_root() {
  // @@protoc_insertion_point(field_release:aggregator.v1.PublicInputs.global_exit_root)
  return _impl_.global_exit_root_.Release();
}
inline void PublicInputs::set_allocated_global_exit_root(std::string* global_exit_root) {
  if (global_exit_root != nullptr) {
    
  } else {
    
  }
  _impl_.global_exit_root_.SetAllocated(global_exit_root, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.global_exit_root_.IsDefault()) {
    _impl_.global_exit_root_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aggregator.v1.PublicInputs.global_exit_root)
}

// uint64 eth_timestamp = 8;
inline void PublicInputs::clear_eth_timestamp() {
  _impl_.eth_timestamp_ = uint64_t{0u};
}
inline uint64_t PublicInputs::_internal_eth_timestamp() const {
  return _impl_.eth_timestamp_;
}
inline uint64_t PublicInputs::eth_timestamp() const {
  // @@protoc_insertion_point(field_get:aggregator.v1.PublicInputs.eth_timestamp)
  return _internal_eth_timestamp();
}
inline void PublicInputs::_internal_set_eth_timestamp(uint64_t value) {
  
  _impl_.eth_timestamp_ = value;
}
inline void PublicInputs::set_eth_timestamp(uint64_t value) {
  _internal_set_eth_timestamp(value);
  // @@protoc_insertion_point(field_set:aggregator.v1.PublicInputs.eth_timestamp)
}

// string sequencer_addr = 9;
inline void PublicInputs::clear_sequencer_addr() {
  _impl_.sequencer_addr_.ClearToEmpty();
}
inline const std::string& PublicInputs::sequencer_addr() const {
  // @@protoc_insertion_point(field_get:aggregator.v1.PublicInputs.sequencer_addr)
  return _internal_sequencer_addr();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PublicInputs::set_sequencer_addr(ArgT0&& arg0, ArgT... args) {
 
 _impl_.sequencer_addr_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:aggregator.v1.PublicInputs.sequencer_addr)
}
inline std::string* PublicInputs::mutable_sequencer_addr() {
  std::string* _s = _internal_mutable_sequencer_addr();
  // @@protoc_insertion_point(field_mutable:aggregator.v1.PublicInputs.sequencer_addr)
  return _s;
}
inline const std::string& PublicInputs::_internal_sequencer_addr() const {
  return _impl_.sequencer_addr_.Get();
}
inline void PublicInputs::_internal_set_sequencer_addr(const std::string& value) {
  
  _impl_.sequencer_addr_.Set(value, GetArenaForAllocation());
}
inline std::string* PublicInputs::_internal_mutable_sequencer_addr() {
  
  return _impl_.sequencer_addr_.Mutable(GetArenaForAllocation());
}
inline std::string* PublicInputs::release_sequencer_addr() {
  // @@protoc_insertion_point(field_release:aggregator.v1.PublicInputs.sequencer_addr)
  return _impl_.sequencer_addr_.Release();
}
inline void PublicInputs::set_allocated_sequencer_addr(std::string* sequencer_addr) {
  if (sequencer_addr != nullptr) {
    
  } else {
    
  }
  _impl_.sequencer_addr_.SetAllocated(sequencer_addr, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sequencer_addr_.IsDefault()) {
    _impl_.sequencer_addr_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aggregator.v1.PublicInputs.sequencer_addr)
}

// string aggregator_addr = 10;
inline void PublicInputs::clear_aggregator_addr() {
  _impl_.aggregator_addr_.ClearToEmpty();
}
inline const std::string& PublicInputs::aggregator_addr() const {
  // @@protoc_insertion_point(field_get:aggregator.v1.PublicInputs.aggregator_addr)
  return _internal_aggregator_addr();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PublicInputs::set_aggregator_addr(ArgT0&& arg0, ArgT... args) {
 
 _impl_.aggregator_addr_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:aggregator.v1.PublicInputs.aggregator_addr)
}
inline std::string* PublicInputs::mutable_aggregator_addr() {
  std::string* _s = _internal_mutable_aggregator_addr();
  // @@protoc_insertion_point(field_mutable:aggregator.v1.PublicInputs.aggregator_addr)
  return _s;
}
inline const std::string& PublicInputs::_internal_aggregator_addr() const {
  return _impl_.aggregator_addr_.Get();
}
inline void PublicInputs::_internal_set_aggregator_addr(const std::string& value) {
  
  _impl_.aggregator_addr_.Set(value, GetArenaForAllocation());
}
inline std::string* PublicInputs::_internal_mutable_aggregator_addr() {
  
  return _impl_.aggregator_addr_.Mutable(GetArenaForAllocation());
}
inline std::string* PublicInputs::release_aggregator_addr() {
  // @@protoc_insertion_point(field_release:aggregator.v1.PublicInputs.aggregator_addr)
  return _impl_.aggregator_addr_.Release();
}
inline void PublicInputs::set_allocated_aggregator_addr(std::string* aggregator_addr) {
  if (aggregator_addr != nullptr) {
    
  } else {
    
  }
  _impl_.aggregator_addr_.SetAllocated(aggregator_addr, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.aggregator_addr_.IsDefault()) {
    _impl_.aggregator_addr_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aggregator.v1.PublicInputs.aggregator_addr)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// InputProver

// .aggregator.v1.PublicInputs public_inputs = 1;
inline bool InputProver::_internal_has_public_inputs() const {
  return this != internal_default_instance() && _impl_.public_inputs_ != nullptr;
}
inline bool InputProver::has_public_inputs() const {
  return _internal_has_public_inputs();
}
inline void InputProver::clear_public_inputs() {
  if (GetArenaForAllocation() == nullptr && _impl_.public_inputs_ != nullptr) {
    delete _impl_.public_inputs_;
  }
  _impl_.public_inputs_ = nullptr;
}
inline const ::aggregator::v1::PublicInputs& InputProver::_internal_public_inputs() const {
  const ::aggregator::v1::PublicInputs* p = _impl_.public_inputs_;
  return p != nullptr ? *p : reinterpret_cast<const ::aggregator::v1::PublicInputs&>(
      ::aggregator::v1::_PublicInputs_default_instance_);
}
inline const ::aggregator::v1::PublicInputs& InputProver::public_inputs() const {
  // @@protoc_insertion_point(field_get:aggregator.v1.InputProver.public_inputs)
  return _internal_public_inputs();
}
inline void InputProver::unsafe_arena_set_allocated_public_inputs(
    ::aggregator::v1::PublicInputs* public_inputs) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.public_inputs_);
  }
  _impl_.public_inputs_ = public_inputs;
  if (public_inputs) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aggregator.v1.InputProver.public_inputs)
}
inline ::aggregator::v1::PublicInputs* InputProver::release_public_inputs() {
  
  ::aggregator::v1::PublicInputs* temp = _impl_.public_inputs_;
  _impl_.public_inputs_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::aggregator::v1::PublicInputs* InputProver::unsafe_arena_release_public_inputs() {
  // @@protoc_insertion_point(field_release:aggregator.v1.InputProver.public_inputs)
  
  ::aggregator::v1::PublicInputs* temp = _impl_.public_inputs_;
  _impl_.public_inputs_ = nullptr;
  return temp;
}
inline ::aggregator::v1::PublicInputs* InputProver::_internal_mutable_public_inputs() {
  
  if (_impl_.public_inputs_ == nullptr) {
    auto* p = CreateMaybeMessage<::aggregator::v1::PublicInputs>(GetArenaForAllocation());
    _impl_.public_inputs_ = p;
  }
  return _impl_.public_inputs_;
}
inline ::aggregator::v1::PublicInputs* InputProver::mutable_public_inputs() {
  ::aggregator::v1::PublicInputs* _msg = _internal_mutable_public_inputs();
  // @@protoc_insertion_point(field_mutable:aggregator.v1.InputProver.public_inputs)
  return _msg;
}
inline void InputProver::set_allocated_public_inputs(::aggregator::v1::PublicInputs* public_inputs) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.public_inputs_;
  }
  if (public_inputs) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(public_inputs);
    if (message_arena != submessage_arena) {
      public_inputs = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, public_inputs, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.public_inputs_ = public_inputs;
  // @@protoc_insertion_point(field_set_allocated:aggregator.v1.InputProver.public_inputs)
}

// map<string, string> db = 4;
inline int InputProver::_internal_db_size() const {
  return _impl_.db_.size();
}
inline int InputProver::db_size() const {
  return _internal_db_size();
}
inline void InputProver::clear_db() {
  _impl_.db_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
InputProver::_internal_db() const {
  return _impl_.db_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
InputProver::db() const {
  // @@protoc_insertion_point(field_map:aggregator.v1.InputProver.db)
  return _internal_db();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
InputProver::_internal_mutable_db() {
  return _impl_.db_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
InputProver::mutable_db() {
  // @@protoc_insertion_point(field_mutable_map:aggregator.v1.InputProver.db)
  return _internal_mutable_db();
}

// map<string, string> contracts_bytecode = 5;
inline int InputProver::_internal_contracts_bytecode_size() const {
  return _impl_.contracts_bytecode_.size();
}
inline int InputProver::contracts_bytecode_size() const {
  return _internal_contracts_bytecode_size();
}
inline void InputProver::clear_contracts_bytecode() {
  _impl_.contracts_bytecode_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
InputProver::_internal_contracts_bytecode() const {
  return _impl_.contracts_bytecode_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
InputProver::contracts_bytecode() const {
  // @@protoc_insertion_point(field_map:aggregator.v1.InputProver.contracts_bytecode)
  return _internal_contracts_bytecode();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
InputProver::_internal_mutable_contracts_bytecode() {
  return _impl_.contracts_bytecode_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
InputProver::mutable_contracts_bytecode() {
  // @@protoc_insertion_point(field_mutable_map:aggregator.v1.InputProver.contracts_bytecode)
  return _internal_mutable_contracts_bytecode();
}

// -------------------------------------------------------------------

// PublicInputsExtended

// .aggregator.v1.PublicInputs public_inputs = 1;
inline bool PublicInputsExtended::_internal_has_public_inputs() const {
  return this != internal_default_instance() && _impl_.public_inputs_ != nullptr;
}
inline bool PublicInputsExtended::has_public_inputs() const {
  return _internal_has_public_inputs();
}
inline void PublicInputsExtended::clear_public_inputs() {
  if (GetArenaForAllocation() == nullptr && _impl_.public_inputs_ != nullptr) {
    delete _impl_.public_inputs_;
  }
  _impl_.public_inputs_ = nullptr;
}
inline const ::aggregator::v1::PublicInputs& PublicInputsExtended::_internal_public_inputs() const {
  const ::aggregator::v1::PublicInputs* p = _impl_.public_inputs_;
  return p != nullptr ? *p : reinterpret_cast<const ::aggregator::v1::PublicInputs&>(
      ::aggregator::v1::_PublicInputs_default_instance_);
}
inline const ::aggregator::v1::PublicInputs& PublicInputsExtended::public_inputs() const {
  // @@protoc_insertion_point(field_get:aggregator.v1.PublicInputsExtended.public_inputs)
  return _internal_public_inputs();
}
inline void PublicInputsExtended::unsafe_arena_set_allocated_public_inputs(
    ::aggregator::v1::PublicInputs* public_inputs) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.public_inputs_);
  }
  _impl_.public_inputs_ = public_inputs;
  if (public_inputs) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aggregator.v1.PublicInputsExtended.public_inputs)
}
inline ::aggregator::v1::PublicInputs* PublicInputsExtended::release_public_inputs() {
  
  ::aggregator::v1::PublicInputs* temp = _impl_.public_inputs_;
  _impl_.public_inputs_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::aggregator::v1::PublicInputs* PublicInputsExtended::unsafe_arena_release_public_inputs() {
  // @@protoc_insertion_point(field_release:aggregator.v1.PublicInputsExtended.public_inputs)
  
  ::aggregator::v1::PublicInputs* temp = _impl_.public_inputs_;
  _impl_.public_inputs_ = nullptr;
  return temp;
}
inline ::aggregator::v1::PublicInputs* PublicInputsExtended::_internal_mutable_public_inputs() {
  
  if (_impl_.public_inputs_ == nullptr) {
    auto* p = CreateMaybeMessage<::aggregator::v1::PublicInputs>(GetArenaForAllocation());
    _impl_.public_inputs_ = p;
  }
  return _impl_.public_inputs_;
}
inline ::aggregator::v1::PublicInputs* PublicInputsExtended::mutable_public_inputs() {
  ::aggregator::v1::PublicInputs* _msg = _internal_mutable_public_inputs();
  // @@protoc_insertion_point(field_mutable:aggregator.v1.PublicInputsExtended.public_inputs)
  return _msg;
}
inline void PublicInputsExtended::set_allocated_public_inputs(::aggregator::v1::PublicInputs* public_inputs) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.public_inputs_;
  }
  if (public_inputs) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(public_inputs);
    if (message_arena != submessage_arena) {
      public_inputs = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, public_inputs, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.public_inputs_ = public_inputs;
  // @@protoc_insertion_point(field_set_allocated:aggregator.v1.PublicInputsExtended.public_inputs)
}

// bytes new_state_root = 2;
inline void PublicInputsExtended::clear_new_state_root() {
  _impl_.new_state_root_.ClearToEmpty();
}
inline const std::string& PublicInputsExtended::new_state_root() const {
  // @@protoc_insertion_point(field_get:aggregator.v1.PublicInputsExtended.new_state_root)
  return _internal_new_state_root();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PublicInputsExtended::set_new_state_root(ArgT0&& arg0, ArgT... args) {
 
 _impl_.new_state_root_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:aggregator.v1.PublicInputsExtended.new_state_root)
}
inline std::string* PublicInputsExtended::mutable_new_state_root() {
  std::string* _s = _internal_mutable_new_state_root();
  // @@protoc_insertion_point(field_mutable:aggregator.v1.PublicInputsExtended.new_state_root)
  return _s;
}
inline const std::string& PublicInputsExtended::_internal_new_state_root() const {
  return _impl_.new_state_root_.Get();
}
inline void PublicInputsExtended::_internal_set_new_state_root(const std::string& value) {
  
  _impl_.new_state_root_.Set(value, GetArenaForAllocation());
}
inline std::string* PublicInputsExtended::_internal_mutable_new_state_root() {
  
  return _impl_.new_state_root_.Mutable(GetArenaForAllocation());
}
inline std::string* PublicInputsExtended::release_new_state_root() {
  // @@protoc_insertion_point(field_release:aggregator.v1.PublicInputsExtended.new_state_root)
  return _impl_.new_state_root_.Release();
}
inline void PublicInputsExtended::set_allocated_new_state_root(std::string* new_state_root) {
  if (new_state_root != nullptr) {
    
  } else {
    
  }
  _impl_.new_state_root_.SetAllocated(new_state_root, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.new_state_root_.IsDefault()) {
    _impl_.new_state_root_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aggregator.v1.PublicInputsExtended.new_state_root)
}

// bytes new_acc_input_hash = 3;
inline void PublicInputsExtended::clear_new_acc_input_hash() {
  _impl_.new_acc_input_hash_.ClearToEmpty();
}
inline const std::string& PublicInputsExtended::new_acc_input_hash() const {
  // @@protoc_insertion_point(field_get:aggregator.v1.PublicInputsExtended.new_acc_input_hash)
  return _internal_new_acc_input_hash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PublicInputsExtended::set_new_acc_input_hash(ArgT0&& arg0, ArgT... args) {
 
 _impl_.new_acc_input_hash_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:aggregator.v1.PublicInputsExtended.new_acc_input_hash)
}
inline std::string* PublicInputsExtended::mutable_new_acc_input_hash() {
  std::string* _s = _internal_mutable_new_acc_input_hash();
  // @@protoc_insertion_point(field_mutable:aggregator.v1.PublicInputsExtended.new_acc_input_hash)
  return _s;
}
inline const std::string& PublicInputsExtended::_internal_new_acc_input_hash() const {
  return _impl_.new_acc_input_hash_.Get();
}
inline void PublicInputsExtended::_internal_set_new_acc_input_hash(const std::string& value) {
  
  _impl_.new_acc_input_hash_.Set(value, GetArenaForAllocation());
}
inline std::string* PublicInputsExtended::_internal_mutable_new_acc_input_hash() {
  
  return _impl_.new_acc_input_hash_.Mutable(GetArenaForAllocation());
}
inline std::string* PublicInputsExtended::release_new_acc_input_hash() {
  // @@protoc_insertion_point(field_release:aggregator.v1.PublicInputsExtended.new_acc_input_hash)
  return _impl_.new_acc_input_hash_.Release();
}
inline void PublicInputsExtended::set_allocated_new_acc_input_hash(std::string* new_acc_input_hash) {
  if (new_acc_input_hash != nullptr) {
    
  } else {
    
  }
  _impl_.new_acc_input_hash_.SetAllocated(new_acc_input_hash, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.new_acc_input_hash_.IsDefault()) {
    _impl_.new_acc_input_hash_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aggregator.v1.PublicInputsExtended.new_acc_input_hash)
}

// bytes new_local_exit_root = 4;
inline void PublicInputsExtended::clear_new_local_exit_root() {
  _impl_.new_local_exit_root_.ClearToEmpty();
}
inline const std::string& PublicInputsExtended::new_local_exit_root() const {
  // @@protoc_insertion_point(field_get:aggregator.v1.PublicInputsExtended.new_local_exit_root)
  return _internal_new_local_exit_root();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PublicInputsExtended::set_new_local_exit_root(ArgT0&& arg0, ArgT... args) {
 
 _impl_.new_local_exit_root_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:aggregator.v1.PublicInputsExtended.new_local_exit_root)
}
inline std::string* PublicInputsExtended::mutable_new_local_exit_root() {
  std::string* _s = _internal_mutable_new_local_exit_root();
  // @@protoc_insertion_point(field_mutable:aggregator.v1.PublicInputsExtended.new_local_exit_root)
  return _s;
}
inline const std::string& PublicInputsExtended::_internal_new_local_exit_root() const {
  return _impl_.new_local_exit_root_.Get();
}
inline void PublicInputsExtended::_internal_set_new_local_exit_root(const std::string& value) {
  
  _impl_.new_local_exit_root_.Set(value, GetArenaForAllocation());
}
inline std::string* PublicInputsExtended::_internal_mutable_new_local_exit_root() {
  
  return _impl_.new_local_exit_root_.Mutable(GetArenaForAllocation());
}
inline std::string* PublicInputsExtended::release_new_local_exit_root() {
  // @@protoc_insertion_point(field_release:aggregator.v1.PublicInputsExtended.new_local_exit_root)
  return _impl_.new_local_exit_root_.Release();
}
inline void PublicInputsExtended::set_allocated_new_local_exit_root(std::string* new_local_exit_root) {
  if (new_local_exit_root != nullptr) {
    
  } else {
    
  }
  _impl_.new_local_exit_root_.SetAllocated(new_local_exit_root, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.new_local_exit_root_.IsDefault()) {
    _impl_.new_local_exit_root_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aggregator.v1.PublicInputsExtended.new_local_exit_root)
}

// uint64 new_batch_num = 5;
inline void PublicInputsExtended::clear_new_batch_num() {
  _impl_.new_batch_num_ = uint64_t{0u};
}
inline uint64_t PublicInputsExtended::_internal_new_batch_num() const {
  return _impl_.new_batch_num_;
}
inline uint64_t PublicInputsExtended::new_batch_num() const {
  // @@protoc_insertion_point(field_get:aggregator.v1.PublicInputsExtended.new_batch_num)
  return _internal_new_batch_num();
}
inline void PublicInputsExtended::_internal_set_new_batch_num(uint64_t value) {
  
  _impl_.new_batch_num_ = value;
}
inline void PublicInputsExtended::set_new_batch_num(uint64_t value) {
  _internal_set_new_batch_num(value);
  // @@protoc_insertion_point(field_set:aggregator.v1.PublicInputsExtended.new_batch_num)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace v1
}  // namespace aggregator

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::aggregator::v1::GetStatusResponse_Status> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::aggregator::v1::GetStatusResponse_Status>() {
  return ::aggregator::v1::GetStatusResponse_Status_descriptor();
}
template <> struct is_proto_enum< ::aggregator::v1::GetProofResponse_Result> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::aggregator::v1::GetProofResponse_Result>() {
  return ::aggregator::v1::GetProofResponse_Result_descriptor();
}
template <> struct is_proto_enum< ::aggregator::v1::Result> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::aggregator::v1::Result>() {
  return ::aggregator::v1::Result_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_aggregator_2eproto
