// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: executor.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_executor_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_executor_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/empty.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_executor_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_executor_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[41]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_executor_2eproto;
namespace executor {
namespace v1 {
class Contract;
struct ContractDefaultTypeInternal;
extern ContractDefaultTypeInternal _Contract_default_instance_;
class ContractV2;
struct ContractV2DefaultTypeInternal;
extern ContractV2DefaultTypeInternal _ContractV2_default_instance_;
class DebugV2;
class DebugV2DefaultTypeInternal;
extern DebugV2DefaultTypeInternal _DebugV2_default_instance_;
class FullTrace;
struct FullTraceDefaultTypeInternal;
extern FullTraceDefaultTypeInternal _FullTrace_default_instance_;
class FullTraceV2;
struct FullTraceV2DefaultTypeInternal;
extern FullTraceV2DefaultTypeInternal _FullTraceV2_default_instance_;
class GetFlushStatusResponse;
struct GetFlushStatusResponseDefaultTypeInternal;
extern GetFlushStatusResponseDefaultTypeInternal _GetFlushStatusResponse_default_instance_;
class InfoReadWrite;
struct InfoReadWriteDefaultTypeInternal;
extern InfoReadWriteDefaultTypeInternal _InfoReadWrite_default_instance_;
class InfoReadWriteV2;
struct InfoReadWriteV2DefaultTypeInternal;
extern InfoReadWriteV2DefaultTypeInternal _InfoReadWriteV2_default_instance_;
class L1DataV2;
struct L1DataV2DefaultTypeInternal;
extern L1DataV2DefaultTypeInternal _L1DataV2_default_instance_;
class Log;
struct LogDefaultTypeInternal;
extern LogDefaultTypeInternal _Log_default_instance_;
class LogV2;
struct LogV2DefaultTypeInternal;
extern LogV2DefaultTypeInternal _LogV2_default_instance_;
class OverrideAccount;
struct OverrideAccountDefaultTypeInternal;
extern OverrideAccountDefaultTypeInternal _OverrideAccount_default_instance_;
class OverrideAccountV2;
struct OverrideAccountV2DefaultTypeInternal;
extern OverrideAccountV2DefaultTypeInternal _OverrideAccountV2_default_instance_;
class OverrideAccountV2_StateDiffEntry_DoNotUse;
struct OverrideAccountV2_StateDiffEntry_DoNotUseDefaultTypeInternal;
extern OverrideAccountV2_StateDiffEntry_DoNotUseDefaultTypeInternal _OverrideAccountV2_StateDiffEntry_DoNotUse_default_instance_;
class OverrideAccountV2_StateEntry_DoNotUse;
struct OverrideAccountV2_StateEntry_DoNotUseDefaultTypeInternal;
extern OverrideAccountV2_StateEntry_DoNotUseDefaultTypeInternal _OverrideAccountV2_StateEntry_DoNotUse_default_instance_;
class OverrideAccount_StateDiffEntry_DoNotUse;
struct OverrideAccount_StateDiffEntry_DoNotUseDefaultTypeInternal;
extern OverrideAccount_StateDiffEntry_DoNotUseDefaultTypeInternal _OverrideAccount_StateDiffEntry_DoNotUse_default_instance_;
class OverrideAccount_StateEntry_DoNotUse;
struct OverrideAccount_StateEntry_DoNotUseDefaultTypeInternal;
extern OverrideAccount_StateEntry_DoNotUseDefaultTypeInternal _OverrideAccount_StateEntry_DoNotUse_default_instance_;
class ProcessBatchRequest;
struct ProcessBatchRequestDefaultTypeInternal;
extern ProcessBatchRequestDefaultTypeInternal _ProcessBatchRequest_default_instance_;
class ProcessBatchRequestV2;
struct ProcessBatchRequestV2DefaultTypeInternal;
extern ProcessBatchRequestV2DefaultTypeInternal _ProcessBatchRequestV2_default_instance_;
class ProcessBatchRequestV2_ContractsBytecodeEntry_DoNotUse;
struct ProcessBatchRequestV2_ContractsBytecodeEntry_DoNotUseDefaultTypeInternal;
extern ProcessBatchRequestV2_ContractsBytecodeEntry_DoNotUseDefaultTypeInternal _ProcessBatchRequestV2_ContractsBytecodeEntry_DoNotUse_default_instance_;
class ProcessBatchRequestV2_DbEntry_DoNotUse;
struct ProcessBatchRequestV2_DbEntry_DoNotUseDefaultTypeInternal;
extern ProcessBatchRequestV2_DbEntry_DoNotUseDefaultTypeInternal _ProcessBatchRequestV2_DbEntry_DoNotUse_default_instance_;
class ProcessBatchRequestV2_L1InfoTreeDataEntry_DoNotUse;
struct ProcessBatchRequestV2_L1InfoTreeDataEntry_DoNotUseDefaultTypeInternal;
extern ProcessBatchRequestV2_L1InfoTreeDataEntry_DoNotUseDefaultTypeInternal _ProcessBatchRequestV2_L1InfoTreeDataEntry_DoNotUse_default_instance_;
class ProcessBatchRequestV2_StateOverrideEntry_DoNotUse;
struct ProcessBatchRequestV2_StateOverrideEntry_DoNotUseDefaultTypeInternal;
extern ProcessBatchRequestV2_StateOverrideEntry_DoNotUseDefaultTypeInternal _ProcessBatchRequestV2_StateOverrideEntry_DoNotUse_default_instance_;
class ProcessBatchRequest_ContractsBytecodeEntry_DoNotUse;
struct ProcessBatchRequest_ContractsBytecodeEntry_DoNotUseDefaultTypeInternal;
extern ProcessBatchRequest_ContractsBytecodeEntry_DoNotUseDefaultTypeInternal _ProcessBatchRequest_ContractsBytecodeEntry_DoNotUse_default_instance_;
class ProcessBatchRequest_DbEntry_DoNotUse;
struct ProcessBatchRequest_DbEntry_DoNotUseDefaultTypeInternal;
extern ProcessBatchRequest_DbEntry_DoNotUseDefaultTypeInternal _ProcessBatchRequest_DbEntry_DoNotUse_default_instance_;
class ProcessBatchRequest_StateOverrideEntry_DoNotUse;
struct ProcessBatchRequest_StateOverrideEntry_DoNotUseDefaultTypeInternal;
extern ProcessBatchRequest_StateOverrideEntry_DoNotUseDefaultTypeInternal _ProcessBatchRequest_StateOverrideEntry_DoNotUse_default_instance_;
class ProcessBatchResponse;
struct ProcessBatchResponseDefaultTypeInternal;
extern ProcessBatchResponseDefaultTypeInternal _ProcessBatchResponse_default_instance_;
class ProcessBatchResponseV2;
struct ProcessBatchResponseV2DefaultTypeInternal;
extern ProcessBatchResponseV2DefaultTypeInternal _ProcessBatchResponseV2_default_instance_;
class ProcessBatchResponseV2_ReadWriteAddressesEntry_DoNotUse;
struct ProcessBatchResponseV2_ReadWriteAddressesEntry_DoNotUseDefaultTypeInternal;
extern ProcessBatchResponseV2_ReadWriteAddressesEntry_DoNotUseDefaultTypeInternal _ProcessBatchResponseV2_ReadWriteAddressesEntry_DoNotUse_default_instance_;
class ProcessBatchResponse_ReadWriteAddressesEntry_DoNotUse;
struct ProcessBatchResponse_ReadWriteAddressesEntry_DoNotUseDefaultTypeInternal;
extern ProcessBatchResponse_ReadWriteAddressesEntry_DoNotUseDefaultTypeInternal _ProcessBatchResponse_ReadWriteAddressesEntry_DoNotUse_default_instance_;
class ProcessBlockResponseV2;
struct ProcessBlockResponseV2DefaultTypeInternal;
extern ProcessBlockResponseV2DefaultTypeInternal _ProcessBlockResponseV2_default_instance_;
class ProcessTransactionResponse;
struct ProcessTransactionResponseDefaultTypeInternal;
extern ProcessTransactionResponseDefaultTypeInternal _ProcessTransactionResponse_default_instance_;
class ProcessTransactionResponseV2;
struct ProcessTransactionResponseV2DefaultTypeInternal;
extern ProcessTransactionResponseV2DefaultTypeInternal _ProcessTransactionResponseV2_default_instance_;
class TraceConfig;
struct TraceConfigDefaultTypeInternal;
extern TraceConfigDefaultTypeInternal _TraceConfig_default_instance_;
class TraceConfigV2;
struct TraceConfigV2DefaultTypeInternal;
extern TraceConfigV2DefaultTypeInternal _TraceConfigV2_default_instance_;
class TransactionContext;
struct TransactionContextDefaultTypeInternal;
extern TransactionContextDefaultTypeInternal _TransactionContext_default_instance_;
class TransactionContextV2;
struct TransactionContextV2DefaultTypeInternal;
extern TransactionContextV2DefaultTypeInternal _TransactionContextV2_default_instance_;
class TransactionStep;
struct TransactionStepDefaultTypeInternal;
extern TransactionStepDefaultTypeInternal _TransactionStep_default_instance_;
class TransactionStepV2;
struct TransactionStepV2DefaultTypeInternal;
extern TransactionStepV2DefaultTypeInternal _TransactionStepV2_default_instance_;
class TransactionStepV2_StorageEntry_DoNotUse;
struct TransactionStepV2_StorageEntry_DoNotUseDefaultTypeInternal;
extern TransactionStepV2_StorageEntry_DoNotUseDefaultTypeInternal _TransactionStepV2_StorageEntry_DoNotUse_default_instance_;
class TransactionStep_StorageEntry_DoNotUse;
struct TransactionStep_StorageEntry_DoNotUseDefaultTypeInternal;
extern TransactionStep_StorageEntry_DoNotUseDefaultTypeInternal _TransactionStep_StorageEntry_DoNotUse_default_instance_;
}  // namespace v1
}  // namespace executor
PROTOBUF_NAMESPACE_OPEN
template<> ::executor::v1::Contract* Arena::CreateMaybeMessage<::executor::v1::Contract>(Arena*);
template<> ::executor::v1::ContractV2* Arena::CreateMaybeMessage<::executor::v1::ContractV2>(Arena*);
template<> ::executor::v1::DebugV2* Arena::CreateMaybeMessage<::executor::v1::DebugV2>(Arena*);
template<> ::executor::v1::FullTrace* Arena::CreateMaybeMessage<::executor::v1::FullTrace>(Arena*);
template<> ::executor::v1::FullTraceV2* Arena::CreateMaybeMessage<::executor::v1::FullTraceV2>(Arena*);
template<> ::executor::v1::GetFlushStatusResponse* Arena::CreateMaybeMessage<::executor::v1::GetFlushStatusResponse>(Arena*);
template<> ::executor::v1::InfoReadWrite* Arena::CreateMaybeMessage<::executor::v1::InfoReadWrite>(Arena*);
template<> ::executor::v1::InfoReadWriteV2* Arena::CreateMaybeMessage<::executor::v1::InfoReadWriteV2>(Arena*);
template<> ::executor::v1::L1DataV2* Arena::CreateMaybeMessage<::executor::v1::L1DataV2>(Arena*);
template<> ::executor::v1::Log* Arena::CreateMaybeMessage<::executor::v1::Log>(Arena*);
template<> ::executor::v1::LogV2* Arena::CreateMaybeMessage<::executor::v1::LogV2>(Arena*);
template<> ::executor::v1::OverrideAccount* Arena::CreateMaybeMessage<::executor::v1::OverrideAccount>(Arena*);
template<> ::executor::v1::OverrideAccountV2* Arena::CreateMaybeMessage<::executor::v1::OverrideAccountV2>(Arena*);
template<> ::executor::v1::OverrideAccountV2_StateDiffEntry_DoNotUse* Arena::CreateMaybeMessage<::executor::v1::OverrideAccountV2_StateDiffEntry_DoNotUse>(Arena*);
template<> ::executor::v1::OverrideAccountV2_StateEntry_DoNotUse* Arena::CreateMaybeMessage<::executor::v1::OverrideAccountV2_StateEntry_DoNotUse>(Arena*);
template<> ::executor::v1::OverrideAccount_StateDiffEntry_DoNotUse* Arena::CreateMaybeMessage<::executor::v1::OverrideAccount_StateDiffEntry_DoNotUse>(Arena*);
template<> ::executor::v1::OverrideAccount_StateEntry_DoNotUse* Arena::CreateMaybeMessage<::executor::v1::OverrideAccount_StateEntry_DoNotUse>(Arena*);
template<> ::executor::v1::ProcessBatchRequest* Arena::CreateMaybeMessage<::executor::v1::ProcessBatchRequest>(Arena*);
template<> ::executor::v1::ProcessBatchRequestV2* Arena::CreateMaybeMessage<::executor::v1::ProcessBatchRequestV2>(Arena*);
template<> ::executor::v1::ProcessBatchRequestV2_ContractsBytecodeEntry_DoNotUse* Arena::CreateMaybeMessage<::executor::v1::ProcessBatchRequestV2_ContractsBytecodeEntry_DoNotUse>(Arena*);
template<> ::executor::v1::ProcessBatchRequestV2_DbEntry_DoNotUse* Arena::CreateMaybeMessage<::executor::v1::ProcessBatchRequestV2_DbEntry_DoNotUse>(Arena*);
template<> ::executor::v1::ProcessBatchRequestV2_L1InfoTreeDataEntry_DoNotUse* Arena::CreateMaybeMessage<::executor::v1::ProcessBatchRequestV2_L1InfoTreeDataEntry_DoNotUse>(Arena*);
template<> ::executor::v1::ProcessBatchRequestV2_StateOverrideEntry_DoNotUse* Arena::CreateMaybeMessage<::executor::v1::ProcessBatchRequestV2_StateOverrideEntry_DoNotUse>(Arena*);
template<> ::executor::v1::ProcessBatchRequest_ContractsBytecodeEntry_DoNotUse* Arena::CreateMaybeMessage<::executor::v1::ProcessBatchRequest_ContractsBytecodeEntry_DoNotUse>(Arena*);
template<> ::executor::v1::ProcessBatchRequest_DbEntry_DoNotUse* Arena::CreateMaybeMessage<::executor::v1::ProcessBatchRequest_DbEntry_DoNotUse>(Arena*);
template<> ::executor::v1::ProcessBatchRequest_StateOverrideEntry_DoNotUse* Arena::CreateMaybeMessage<::executor::v1::ProcessBatchRequest_StateOverrideEntry_DoNotUse>(Arena*);
template<> ::executor::v1::ProcessBatchResponse* Arena::CreateMaybeMessage<::executor::v1::ProcessBatchResponse>(Arena*);
template<> ::executor::v1::ProcessBatchResponseV2* Arena::CreateMaybeMessage<::executor::v1::ProcessBatchResponseV2>(Arena*);
template<> ::executor::v1::ProcessBatchResponseV2_ReadWriteAddressesEntry_DoNotUse* Arena::CreateMaybeMessage<::executor::v1::ProcessBatchResponseV2_ReadWriteAddressesEntry_DoNotUse>(Arena*);
template<> ::executor::v1::ProcessBatchResponse_ReadWriteAddressesEntry_DoNotUse* Arena::CreateMaybeMessage<::executor::v1::ProcessBatchResponse_ReadWriteAddressesEntry_DoNotUse>(Arena*);
template<> ::executor::v1::ProcessBlockResponseV2* Arena::CreateMaybeMessage<::executor::v1::ProcessBlockResponseV2>(Arena*);
template<> ::executor::v1::ProcessTransactionResponse* Arena::CreateMaybeMessage<::executor::v1::ProcessTransactionResponse>(Arena*);
template<> ::executor::v1::ProcessTransactionResponseV2* Arena::CreateMaybeMessage<::executor::v1::ProcessTransactionResponseV2>(Arena*);
template<> ::executor::v1::TraceConfig* Arena::CreateMaybeMessage<::executor::v1::TraceConfig>(Arena*);
template<> ::executor::v1::TraceConfigV2* Arena::CreateMaybeMessage<::executor::v1::TraceConfigV2>(Arena*);
template<> ::executor::v1::TransactionContext* Arena::CreateMaybeMessage<::executor::v1::TransactionContext>(Arena*);
template<> ::executor::v1::TransactionContextV2* Arena::CreateMaybeMessage<::executor::v1::TransactionContextV2>(Arena*);
template<> ::executor::v1::TransactionStep* Arena::CreateMaybeMessage<::executor::v1::TransactionStep>(Arena*);
template<> ::executor::v1::TransactionStepV2* Arena::CreateMaybeMessage<::executor::v1::TransactionStepV2>(Arena*);
template<> ::executor::v1::TransactionStepV2_StorageEntry_DoNotUse* Arena::CreateMaybeMessage<::executor::v1::TransactionStepV2_StorageEntry_DoNotUse>(Arena*);
template<> ::executor::v1::TransactionStep_StorageEntry_DoNotUse* Arena::CreateMaybeMessage<::executor::v1::TransactionStep_StorageEntry_DoNotUse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace executor {
namespace v1 {

enum RomError : int {
  ROM_ERROR_UNSPECIFIED = 0,
  ROM_ERROR_NO_ERROR = 1,
  ROM_ERROR_OUT_OF_GAS = 2,
  ROM_ERROR_STACK_OVERFLOW = 3,
  ROM_ERROR_STACK_UNDERFLOW = 4,
  ROM_ERROR_MAX_CODE_SIZE_EXCEEDED = 5,
  ROM_ERROR_CONTRACT_ADDRESS_COLLISION = 6,
  ROM_ERROR_EXECUTION_REVERTED = 7,
  ROM_ERROR_OUT_OF_COUNTERS_STEP = 8,
  ROM_ERROR_OUT_OF_COUNTERS_KECCAK = 9,
  ROM_ERROR_OUT_OF_COUNTERS_BINARY = 10,
  ROM_ERROR_OUT_OF_COUNTERS_MEM = 11,
  ROM_ERROR_OUT_OF_COUNTERS_ARITH = 12,
  ROM_ERROR_OUT_OF_COUNTERS_PADDING = 13,
  ROM_ERROR_OUT_OF_COUNTERS_POSEIDON = 14,
  ROM_ERROR_OUT_OF_COUNTERS_SHA = 15,
  ROM_ERROR_INVALID_JUMP = 16,
  ROM_ERROR_INVALID_OPCODE = 17,
  ROM_ERROR_INVALID_STATIC = 18,
  ROM_ERROR_INVALID_BYTECODE_STARTS_EF = 19,
  ROM_ERROR_INTRINSIC_INVALID_SIGNATURE = 20,
  ROM_ERROR_INTRINSIC_INVALID_CHAIN_ID = 21,
  ROM_ERROR_INTRINSIC_INVALID_NONCE = 22,
  ROM_ERROR_INTRINSIC_INVALID_GAS_LIMIT = 23,
  ROM_ERROR_INTRINSIC_INVALID_BALANCE = 24,
  ROM_ERROR_INTRINSIC_INVALID_BATCH_GAS_LIMIT = 25,
  ROM_ERROR_INTRINSIC_INVALID_SENDER_CODE = 26,
  ROM_ERROR_INTRINSIC_TX_GAS_OVERFLOW = 27,
  ROM_ERROR_BATCH_DATA_TOO_BIG = 28,
  ROM_ERROR_UNSUPPORTED_FORK_ID = 29,
  ROM_ERROR_INVALID_RLP = 30,
  ROM_ERROR_INVALID_DECODE_CHANGE_L2_BLOCK = 31,
  ROM_ERROR_INVALID_NOT_FIRST_TX_CHANGE_L2_BLOCK = 32,
  ROM_ERROR_INVALID_TX_CHANGE_L2_BLOCK = 33,
  RomError_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  RomError_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool RomError_IsValid(int value);
constexpr RomError RomError_MIN = ROM_ERROR_UNSPECIFIED;
constexpr RomError RomError_MAX = ROM_ERROR_INVALID_TX_CHANGE_L2_BLOCK;
constexpr int RomError_ARRAYSIZE = RomError_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RomError_descriptor();
template<typename T>
inline const std::string& RomError_Name(T enum_t_value) {
  static_assert(::std::is_same<T, RomError>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function RomError_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    RomError_descriptor(), enum_t_value);
}
inline bool RomError_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, RomError* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<RomError>(
    RomError_descriptor(), name, value);
}
enum ExecutorError : int {
  EXECUTOR_ERROR_UNSPECIFIED = 0,
  EXECUTOR_ERROR_NO_ERROR = 1,
  EXECUTOR_ERROR_DB_ERROR = 2,
  EXECUTOR_ERROR_SM_MAIN_COUNTERS_OVERFLOW_STEPS = 3,
  EXECUTOR_ERROR_SM_MAIN_COUNTERS_OVERFLOW_KECCAK = 4,
  EXECUTOR_ERROR_SM_MAIN_COUNTERS_OVERFLOW_BINARY = 5,
  EXECUTOR_ERROR_SM_MAIN_COUNTERS_OVERFLOW_MEM = 6,
  EXECUTOR_ERROR_SM_MAIN_COUNTERS_OVERFLOW_ARITH = 7,
  EXECUTOR_ERROR_SM_MAIN_COUNTERS_OVERFLOW_PADDING = 8,
  EXECUTOR_ERROR_SM_MAIN_COUNTERS_OVERFLOW_POSEIDON = 9,
  EXECUTOR_ERROR_UNSUPPORTED_FORK_ID = 10,
  EXECUTOR_ERROR_BALANCE_MISMATCH = 11,
  EXECUTOR_ERROR_FEA2SCALAR = 12,
  EXECUTOR_ERROR_TOS32 = 13,
  EXECUTOR_ERROR_SM_MAIN_INVALID_UNSIGNED_TX = 14,
  EXECUTOR_ERROR_SM_MAIN_INVALID_NO_COUNTERS = 15,
  EXECUTOR_ERROR_SM_MAIN_ARITH_ECRECOVER_DIVIDE_BY_ZERO = 16,
  EXECUTOR_ERROR_SM_MAIN_ADDRESS_OUT_OF_RANGE = 17,
  EXECUTOR_ERROR_SM_MAIN_ADDRESS_NEGATIVE = 18,
  EXECUTOR_ERROR_SM_MAIN_STORAGE_INVALID_KEY = 19,
  EXECUTOR_ERROR_SM_MAIN_HASHK = 20,
  EXECUTOR_ERROR_SM_MAIN_HASHK_SIZE_OUT_OF_RANGE = 21,
  EXECUTOR_ERROR_SM_MAIN_HASHK_POSITION_NEGATIVE = 22,
  EXECUTOR_ERROR_SM_MAIN_HASHK_POSITION_PLUS_SIZE_OUT_OF_RANGE = 23,
  EXECUTOR_ERROR_SM_MAIN_HASHKDIGEST_ADDRESS_NOT_FOUND = 24,
  EXECUTOR_ERROR_SM_MAIN_HASHKDIGEST_NOT_COMPLETED = 25,
  EXECUTOR_ERROR_SM_MAIN_HASHP = 26,
  EXECUTOR_ERROR_SM_MAIN_HASHP_SIZE_OUT_OF_RANGE = 27,
  EXECUTOR_ERROR_SM_MAIN_HASHP_POSITION_NEGATIVE = 28,
  EXECUTOR_ERROR_SM_MAIN_HASHP_POSITION_PLUS_SIZE_OUT_OF_RANGE = 29,
  EXECUTOR_ERROR_SM_MAIN_HASHPDIGEST_ADDRESS_NOT_FOUND = 30,
  EXECUTOR_ERROR_SM_MAIN_HASHPDIGEST_NOT_COMPLETED = 31,
  EXECUTOR_ERROR_SM_MAIN_MEMALIGN_OFFSET_OUT_OF_RANGE = 32,
  EXECUTOR_ERROR_SM_MAIN_MULTIPLE_FREEIN = 33,
  EXECUTOR_ERROR_SM_MAIN_ASSERT = 34,
  EXECUTOR_ERROR_SM_MAIN_MEMORY = 35,
  EXECUTOR_ERROR_SM_MAIN_STORAGE_READ_MISMATCH = 36,
  EXECUTOR_ERROR_SM_MAIN_STORAGE_WRITE_MISMATCH = 37,
  EXECUTOR_ERROR_SM_MAIN_HASHK_VALUE_MISMATCH = 38,
  EXECUTOR_ERROR_SM_MAIN_HASHK_PADDING_MISMATCH = 39,
  EXECUTOR_ERROR_SM_MAIN_HASHK_SIZE_MISMATCH = 40,
  EXECUTOR_ERROR_SM_MAIN_HASHKLEN_LENGTH_MISMATCH = 41,
  EXECUTOR_ERROR_SM_MAIN_HASHKLEN_CALLED_TWICE = 42,
  EXECUTOR_ERROR_SM_MAIN_HASHKDIGEST_NOT_FOUND = 43,
  EXECUTOR_ERROR_SM_MAIN_HASHKDIGEST_DIGEST_MISMATCH = 44,
  EXECUTOR_ERROR_SM_MAIN_HASHKDIGEST_CALLED_TWICE = 45,
  EXECUTOR_ERROR_SM_MAIN_HASHP_VALUE_MISMATCH = 46,
  EXECUTOR_ERROR_SM_MAIN_HASHP_PADDING_MISMATCH = 47,
  EXECUTOR_ERROR_SM_MAIN_HASHP_SIZE_MISMATCH = 48,
  EXECUTOR_ERROR_SM_MAIN_HASHPLEN_LENGTH_MISMATCH = 49,
  EXECUTOR_ERROR_SM_MAIN_HASHPLEN_CALLED_TWICE = 50,
  EXECUTOR_ERROR_SM_MAIN_HASHPDIGEST_DIGEST_MISMATCH = 51,
  EXECUTOR_ERROR_SM_MAIN_HASHPDIGEST_CALLED_TWICE = 52,
  EXECUTOR_ERROR_SM_MAIN_ARITH_MISMATCH = 53,
  EXECUTOR_ERROR_SM_MAIN_ARITH_ECRECOVER_MISMATCH = 54,
  EXECUTOR_ERROR_SM_MAIN_BINARY_ADD_MISMATCH = 55,
  EXECUTOR_ERROR_SM_MAIN_BINARY_SUB_MISMATCH = 56,
  EXECUTOR_ERROR_SM_MAIN_BINARY_LT_MISMATCH = 57,
  EXECUTOR_ERROR_SM_MAIN_BINARY_SLT_MISMATCH = 58,
  EXECUTOR_ERROR_SM_MAIN_BINARY_EQ_MISMATCH = 59,
  EXECUTOR_ERROR_SM_MAIN_BINARY_AND_MISMATCH = 60,
  EXECUTOR_ERROR_SM_MAIN_BINARY_OR_MISMATCH = 61,
  EXECUTOR_ERROR_SM_MAIN_BINARY_XOR_MISMATCH = 62,
  EXECUTOR_ERROR_SM_MAIN_MEMALIGN_WRITE_MISMATCH = 63,
  EXECUTOR_ERROR_SM_MAIN_MEMALIGN_WRITE8_MISMATCH = 64,
  EXECUTOR_ERROR_SM_MAIN_MEMALIGN_READ_MISMATCH = 65,
  EXECUTOR_ERROR_SM_MAIN_JMPN_OUT_OF_RANGE = 66,
  EXECUTOR_ERROR_SM_MAIN_HASHK_READ_OUT_OF_RANGE = 67,
  EXECUTOR_ERROR_SM_MAIN_HASHP_READ_OUT_OF_RANGE = 68,
  EXECUTOR_ERROR_INVALID_OLD_STATE_ROOT = 69,
  EXECUTOR_ERROR_INVALID_OLD_ACC_INPUT_HASH = 70,
  EXECUTOR_ERROR_INVALID_CHAIN_ID = 71,
  EXECUTOR_ERROR_INVALID_BATCH_L2_DATA = 72,
  EXECUTOR_ERROR_INVALID_GLOBAL_EXIT_ROOT = 73,
  EXECUTOR_ERROR_INVALID_COINBASE = 74,
  EXECUTOR_ERROR_INVALID_FROM = 75,
  EXECUTOR_ERROR_INVALID_DB_KEY = 76,
  EXECUTOR_ERROR_INVALID_DB_VALUE = 77,
  EXECUTOR_ERROR_INVALID_CONTRACTS_BYTECODE_KEY = 78,
  EXECUTOR_ERROR_INVALID_CONTRACTS_BYTECODE_VALUE = 79,
  EXECUTOR_ERROR_INVALID_GET_KEY = 80,
  EXECUTOR_ERROR_SM_MAIN_COUNTERS_OVERFLOW_SHA256 = 81,
  EXECUTOR_ERROR_SM_MAIN_HASHS = 82,
  EXECUTOR_ERROR_SM_MAIN_HASHS_SIZE_OUT_OF_RANGE = 83,
  EXECUTOR_ERROR_SM_MAIN_HASHS_POSITION_NEGATIVE = 84,
  EXECUTOR_ERROR_SM_MAIN_HASHS_POSITION_PLUS_SIZE_OUT_OF_RANGE = 85,
  EXECUTOR_ERROR_SM_MAIN_HASHSDIGEST_ADDRESS_NOT_FOUND = 86,
  EXECUTOR_ERROR_SM_MAIN_HASHSDIGEST_NOT_COMPLETED = 87,
  EXECUTOR_ERROR_SM_MAIN_HASHS_VALUE_MISMATCH = 88,
  EXECUTOR_ERROR_SM_MAIN_HASHS_PADDING_MISMATCH = 89,
  EXECUTOR_ERROR_SM_MAIN_HASHS_SIZE_MISMATCH = 90,
  EXECUTOR_ERROR_SM_MAIN_HASHSLEN_LENGTH_MISMATCH = 91,
  EXECUTOR_ERROR_SM_MAIN_HASHSLEN_CALLED_TWICE = 92,
  EXECUTOR_ERROR_SM_MAIN_HASHSDIGEST_NOT_FOUND = 93,
  EXECUTOR_ERROR_SM_MAIN_HASHSDIGEST_DIGEST_MISMATCH = 94,
  EXECUTOR_ERROR_SM_MAIN_HASHSDIGEST_CALLED_TWICE = 95,
  EXECUTOR_ERROR_SM_MAIN_HASHS_READ_OUT_OF_RANGE = 96,
  EXECUTOR_ERROR_INVALID_L1_INFO_ROOT = 97,
  EXECUTOR_ERROR_INVALID_FORCED_BLOCKHASH_L1 = 98,
  EXECUTOR_ERROR_INVALID_L1_DATA_V2_GLOBAL_EXIT_ROOT = 99,
  EXECUTOR_ERROR_INVALID_L1_DATA_V2_BLOCK_HASH_L1 = 100,
  EXECUTOR_ERROR_INVALID_L1_SMT_PROOF = 101,
  EXECUTOR_ERROR_INVALID_BALANCE = 102,
  EXECUTOR_ERROR_SM_MAIN_BINARY_LT4_MISMATCH = 103,
  ExecutorError_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ExecutorError_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ExecutorError_IsValid(int value);
constexpr ExecutorError ExecutorError_MIN = EXECUTOR_ERROR_UNSPECIFIED;
constexpr ExecutorError ExecutorError_MAX = EXECUTOR_ERROR_SM_MAIN_BINARY_LT4_MISMATCH;
constexpr int ExecutorError_ARRAYSIZE = ExecutorError_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ExecutorError_descriptor();
template<typename T>
inline const std::string& ExecutorError_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ExecutorError>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ExecutorError_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ExecutorError_descriptor(), enum_t_value);
}
inline bool ExecutorError_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ExecutorError* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ExecutorError>(
    ExecutorError_descriptor(), name, value);
}
// ===================================================================

class ProcessBatchRequest_DbEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ProcessBatchRequest_DbEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ProcessBatchRequest_DbEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  ProcessBatchRequest_DbEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR ProcessBatchRequest_DbEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit ProcessBatchRequest_DbEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const ProcessBatchRequest_DbEntry_DoNotUse& other);
  static const ProcessBatchRequest_DbEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const ProcessBatchRequest_DbEntry_DoNotUse*>(&_ProcessBatchRequest_DbEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "executor.v1.ProcessBatchRequest.DbEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "executor.v1.ProcessBatchRequest.DbEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_executor_2eproto;
};

// -------------------------------------------------------------------

class ProcessBatchRequest_ContractsBytecodeEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ProcessBatchRequest_ContractsBytecodeEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ProcessBatchRequest_ContractsBytecodeEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  ProcessBatchRequest_ContractsBytecodeEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR ProcessBatchRequest_ContractsBytecodeEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit ProcessBatchRequest_ContractsBytecodeEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const ProcessBatchRequest_ContractsBytecodeEntry_DoNotUse& other);
  static const ProcessBatchRequest_ContractsBytecodeEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const ProcessBatchRequest_ContractsBytecodeEntry_DoNotUse*>(&_ProcessBatchRequest_ContractsBytecodeEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "executor.v1.ProcessBatchRequest.ContractsBytecodeEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "executor.v1.ProcessBatchRequest.ContractsBytecodeEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_executor_2eproto;
};

// -------------------------------------------------------------------

class ProcessBatchRequest_StateOverrideEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ProcessBatchRequest_StateOverrideEntry_DoNotUse, 
    std::string, ::executor::v1::OverrideAccount,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ProcessBatchRequest_StateOverrideEntry_DoNotUse, 
    std::string, ::executor::v1::OverrideAccount,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  ProcessBatchRequest_StateOverrideEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR ProcessBatchRequest_StateOverrideEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit ProcessBatchRequest_StateOverrideEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const ProcessBatchRequest_StateOverrideEntry_DoNotUse& other);
  static const ProcessBatchRequest_StateOverrideEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const ProcessBatchRequest_StateOverrideEntry_DoNotUse*>(&_ProcessBatchRequest_StateOverrideEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "executor.v1.ProcessBatchRequest.StateOverrideEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_executor_2eproto;
};

// -------------------------------------------------------------------

class ProcessBatchRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:executor.v1.ProcessBatchRequest) */ {
 public:
  inline ProcessBatchRequest() : ProcessBatchRequest(nullptr) {}
  ~ProcessBatchRequest() override;
  explicit PROTOBUF_CONSTEXPR ProcessBatchRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ProcessBatchRequest(const ProcessBatchRequest& from);
  ProcessBatchRequest(ProcessBatchRequest&& from) noexcept
    : ProcessBatchRequest() {
    *this = ::std::move(from);
  }

  inline ProcessBatchRequest& operator=(const ProcessBatchRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProcessBatchRequest& operator=(ProcessBatchRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ProcessBatchRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ProcessBatchRequest* internal_default_instance() {
    return reinterpret_cast<const ProcessBatchRequest*>(
               &_ProcessBatchRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ProcessBatchRequest& a, ProcessBatchRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ProcessBatchRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProcessBatchRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ProcessBatchRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ProcessBatchRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ProcessBatchRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ProcessBatchRequest& from) {
    ProcessBatchRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProcessBatchRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "executor.v1.ProcessBatchRequest";
  }
  protected:
  explicit ProcessBatchRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kDbFieldNumber = 13,
    kContractsBytecodeFieldNumber = 14,
    kStateOverrideFieldNumber = 17,
    kOldStateRootFieldNumber = 1,
    kOldAccInputHashFieldNumber = 2,
    kBatchL2DataFieldNumber = 6,
    kGlobalExitRootFieldNumber = 7,
    kCoinbaseFieldNumber = 9,
    kFromFieldNumber = 12,
    kContextIdFieldNumber = 16,
    kTraceConfigFieldNumber = 15,
    kOldBatchNumFieldNumber = 3,
    kChainIdFieldNumber = 4,
    kForkIdFieldNumber = 5,
    kEthTimestampFieldNumber = 8,
    kNoCountersFieldNumber = 11,
    kUpdateMerkleTreeFieldNumber = 10,
  };
  // map<string, string> db = 13;
  int db_size() const;
  private:
  int _internal_db_size() const;
  public:
  void clear_db();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_db() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_db();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      db() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_db();

  // map<string, string> contracts_bytecode = 14;
  int contracts_bytecode_size() const;
  private:
  int _internal_contracts_bytecode_size() const;
  public:
  void clear_contracts_bytecode();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_contracts_bytecode() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_contracts_bytecode();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      contracts_bytecode() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_contracts_bytecode();

  // map<string, .executor.v1.OverrideAccount> state_override = 17;
  int state_override_size() const;
  private:
  int _internal_state_override_size() const;
  public:
  void clear_state_override();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::executor::v1::OverrideAccount >&
      _internal_state_override() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::executor::v1::OverrideAccount >*
      _internal_mutable_state_override();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::executor::v1::OverrideAccount >&
      state_override() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::executor::v1::OverrideAccount >*
      mutable_state_override();

  // bytes old_state_root = 1;
  void clear_old_state_root();
  const std::string& old_state_root() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_old_state_root(ArgT0&& arg0, ArgT... args);
  std::string* mutable_old_state_root();
  PROTOBUF_NODISCARD std::string* release_old_state_root();
  void set_allocated_old_state_root(std::string* old_state_root);
  private:
  const std::string& _internal_old_state_root() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_old_state_root(const std::string& value);
  std::string* _internal_mutable_old_state_root();
  public:

  // bytes old_acc_input_hash = 2;
  void clear_old_acc_input_hash();
  const std::string& old_acc_input_hash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_old_acc_input_hash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_old_acc_input_hash();
  PROTOBUF_NODISCARD std::string* release_old_acc_input_hash();
  void set_allocated_old_acc_input_hash(std::string* old_acc_input_hash);
  private:
  const std::string& _internal_old_acc_input_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_old_acc_input_hash(const std::string& value);
  std::string* _internal_mutable_old_acc_input_hash();
  public:

  // bytes batch_l2_data = 6;
  void clear_batch_l2_data();
  const std::string& batch_l2_data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_batch_l2_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_batch_l2_data();
  PROTOBUF_NODISCARD std::string* release_batch_l2_data();
  void set_allocated_batch_l2_data(std::string* batch_l2_data);
  private:
  const std::string& _internal_batch_l2_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_batch_l2_data(const std::string& value);
  std::string* _internal_mutable_batch_l2_data();
  public:

  // bytes global_exit_root = 7;
  void clear_global_exit_root();
  const std::string& global_exit_root() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_global_exit_root(ArgT0&& arg0, ArgT... args);
  std::string* mutable_global_exit_root();
  PROTOBUF_NODISCARD std::string* release_global_exit_root();
  void set_allocated_global_exit_root(std::string* global_exit_root);
  private:
  const std::string& _internal_global_exit_root() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_global_exit_root(const std::string& value);
  std::string* _internal_mutable_global_exit_root();
  public:

  // string coinbase = 9;
  void clear_coinbase();
  const std::string& coinbase() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_coinbase(ArgT0&& arg0, ArgT... args);
  std::string* mutable_coinbase();
  PROTOBUF_NODISCARD std::string* release_coinbase();
  void set_allocated_coinbase(std::string* coinbase);
  private:
  const std::string& _internal_coinbase() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_coinbase(const std::string& value);
  std::string* _internal_mutable_coinbase();
  public:

  // string from = 12;
  void clear_from();
  const std::string& from() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_from(ArgT0&& arg0, ArgT... args);
  std::string* mutable_from();
  PROTOBUF_NODISCARD std::string* release_from();
  void set_allocated_from(std::string* from);
  private:
  const std::string& _internal_from() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_from(const std::string& value);
  std::string* _internal_mutable_from();
  public:

  // string context_id = 16;
  void clear_context_id();
  const std::string& context_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_context_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_context_id();
  PROTOBUF_NODISCARD std::string* release_context_id();
  void set_allocated_context_id(std::string* context_id);
  private:
  const std::string& _internal_context_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_context_id(const std::string& value);
  std::string* _internal_mutable_context_id();
  public:

  // .executor.v1.TraceConfig trace_config = 15;
  bool has_trace_config() const;
  private:
  bool _internal_has_trace_config() const;
  public:
  void clear_trace_config();
  const ::executor::v1::TraceConfig& trace_config() const;
  PROTOBUF_NODISCARD ::executor::v1::TraceConfig* release_trace_config();
  ::executor::v1::TraceConfig* mutable_trace_config();
  void set_allocated_trace_config(::executor::v1::TraceConfig* trace_config);
  private:
  const ::executor::v1::TraceConfig& _internal_trace_config() const;
  ::executor::v1::TraceConfig* _internal_mutable_trace_config();
  public:
  void unsafe_arena_set_allocated_trace_config(
      ::executor::v1::TraceConfig* trace_config);
  ::executor::v1::TraceConfig* unsafe_arena_release_trace_config();

  // uint64 old_batch_num = 3;
  void clear_old_batch_num();
  uint64_t old_batch_num() const;
  void set_old_batch_num(uint64_t value);
  private:
  uint64_t _internal_old_batch_num() const;
  void _internal_set_old_batch_num(uint64_t value);
  public:

  // uint64 chain_id = 4;
  void clear_chain_id();
  uint64_t chain_id() const;
  void set_chain_id(uint64_t value);
  private:
  uint64_t _internal_chain_id() const;
  void _internal_set_chain_id(uint64_t value);
  public:

  // uint64 fork_id = 5;
  void clear_fork_id();
  uint64_t fork_id() const;
  void set_fork_id(uint64_t value);
  private:
  uint64_t _internal_fork_id() const;
  void _internal_set_fork_id(uint64_t value);
  public:

  // uint64 eth_timestamp = 8;
  void clear_eth_timestamp();
  uint64_t eth_timestamp() const;
  void set_eth_timestamp(uint64_t value);
  private:
  uint64_t _internal_eth_timestamp() const;
  void _internal_set_eth_timestamp(uint64_t value);
  public:

  // uint64 no_counters = 11;
  void clear_no_counters();
  uint64_t no_counters() const;
  void set_no_counters(uint64_t value);
  private:
  uint64_t _internal_no_counters() const;
  void _internal_set_no_counters(uint64_t value);
  public:

  // uint32 update_merkle_tree = 10;
  void clear_update_merkle_tree();
  uint32_t update_merkle_tree() const;
  void set_update_merkle_tree(uint32_t value);
  private:
  uint32_t _internal_update_merkle_tree() const;
  void _internal_set_update_merkle_tree(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:executor.v1.ProcessBatchRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        ProcessBatchRequest_DbEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> db_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        ProcessBatchRequest_ContractsBytecodeEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> contracts_bytecode_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        ProcessBatchRequest_StateOverrideEntry_DoNotUse,
        std::string, ::executor::v1::OverrideAccount,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> state_override_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr old_state_root_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr old_acc_input_hash_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr batch_l2_data_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr global_exit_root_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr coinbase_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr from_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr context_id_;
    ::executor::v1::TraceConfig* trace_config_;
    uint64_t old_batch_num_;
    uint64_t chain_id_;
    uint64_t fork_id_;
    uint64_t eth_timestamp_;
    uint64_t no_counters_;
    uint32_t update_merkle_tree_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_executor_2eproto;
};
// -------------------------------------------------------------------

class ProcessBatchResponse_ReadWriteAddressesEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ProcessBatchResponse_ReadWriteAddressesEntry_DoNotUse, 
    std::string, ::executor::v1::InfoReadWrite,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ProcessBatchResponse_ReadWriteAddressesEntry_DoNotUse, 
    std::string, ::executor::v1::InfoReadWrite,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  ProcessBatchResponse_ReadWriteAddressesEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR ProcessBatchResponse_ReadWriteAddressesEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit ProcessBatchResponse_ReadWriteAddressesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const ProcessBatchResponse_ReadWriteAddressesEntry_DoNotUse& other);
  static const ProcessBatchResponse_ReadWriteAddressesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const ProcessBatchResponse_ReadWriteAddressesEntry_DoNotUse*>(&_ProcessBatchResponse_ReadWriteAddressesEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "executor.v1.ProcessBatchResponse.ReadWriteAddressesEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_executor_2eproto;
};

// -------------------------------------------------------------------

class ProcessBatchResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:executor.v1.ProcessBatchResponse) */ {
 public:
  inline ProcessBatchResponse() : ProcessBatchResponse(nullptr) {}
  ~ProcessBatchResponse() override;
  explicit PROTOBUF_CONSTEXPR ProcessBatchResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ProcessBatchResponse(const ProcessBatchResponse& from);
  ProcessBatchResponse(ProcessBatchResponse&& from) noexcept
    : ProcessBatchResponse() {
    *this = ::std::move(from);
  }

  inline ProcessBatchResponse& operator=(const ProcessBatchResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProcessBatchResponse& operator=(ProcessBatchResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ProcessBatchResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ProcessBatchResponse* internal_default_instance() {
    return reinterpret_cast<const ProcessBatchResponse*>(
               &_ProcessBatchResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ProcessBatchResponse& a, ProcessBatchResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ProcessBatchResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProcessBatchResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ProcessBatchResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ProcessBatchResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ProcessBatchResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ProcessBatchResponse& from) {
    ProcessBatchResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProcessBatchResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "executor.v1.ProcessBatchResponse";
  }
  protected:
  explicit ProcessBatchResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kResponsesFieldNumber = 13,
    kReadWriteAddressesFieldNumber = 15,
    kNewStateRootFieldNumber = 1,
    kNewAccInputHashFieldNumber = 2,
    kNewLocalExitRootFieldNumber = 3,
    kProverIdFieldNumber = 18,
    kNewBatchNumFieldNumber = 4,
    kCntKeccakHashesFieldNumber = 5,
    kCntPoseidonHashesFieldNumber = 6,
    kCntPoseidonPaddingsFieldNumber = 7,
    kCntMemAlignsFieldNumber = 8,
    kCntArithmeticsFieldNumber = 9,
    kCntBinariesFieldNumber = 10,
    kCumulativeGasUsedFieldNumber = 12,
    kCntStepsFieldNumber = 11,
    kErrorFieldNumber = 14,
    kFlushIdFieldNumber = 16,
    kStoredFlushIdFieldNumber = 17,
    kForkIdFieldNumber = 19,
  };
  // repeated .executor.v1.ProcessTransactionResponse responses = 13;
  int responses_size() const;
  private:
  int _internal_responses_size() const;
  public:
  void clear_responses();
  ::executor::v1::ProcessTransactionResponse* mutable_responses(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::executor::v1::ProcessTransactionResponse >*
      mutable_responses();
  private:
  const ::executor::v1::ProcessTransactionResponse& _internal_responses(int index) const;
  ::executor::v1::ProcessTransactionResponse* _internal_add_responses();
  public:
  const ::executor::v1::ProcessTransactionResponse& responses(int index) const;
  ::executor::v1::ProcessTransactionResponse* add_responses();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::executor::v1::ProcessTransactionResponse >&
      responses() const;

  // map<string, .executor.v1.InfoReadWrite> read_write_addresses = 15;
  int read_write_addresses_size() const;
  private:
  int _internal_read_write_addresses_size() const;
  public:
  void clear_read_write_addresses();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::executor::v1::InfoReadWrite >&
      _internal_read_write_addresses() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::executor::v1::InfoReadWrite >*
      _internal_mutable_read_write_addresses();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::executor::v1::InfoReadWrite >&
      read_write_addresses() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::executor::v1::InfoReadWrite >*
      mutable_read_write_addresses();

  // bytes new_state_root = 1;
  void clear_new_state_root();
  const std::string& new_state_root() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_new_state_root(ArgT0&& arg0, ArgT... args);
  std::string* mutable_new_state_root();
  PROTOBUF_NODISCARD std::string* release_new_state_root();
  void set_allocated_new_state_root(std::string* new_state_root);
  private:
  const std::string& _internal_new_state_root() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_new_state_root(const std::string& value);
  std::string* _internal_mutable_new_state_root();
  public:

  // bytes new_acc_input_hash = 2;
  void clear_new_acc_input_hash();
  const std::string& new_acc_input_hash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_new_acc_input_hash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_new_acc_input_hash();
  PROTOBUF_NODISCARD std::string* release_new_acc_input_hash();
  void set_allocated_new_acc_input_hash(std::string* new_acc_input_hash);
  private:
  const std::string& _internal_new_acc_input_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_new_acc_input_hash(const std::string& value);
  std::string* _internal_mutable_new_acc_input_hash();
  public:

  // bytes new_local_exit_root = 3;
  void clear_new_local_exit_root();
  const std::string& new_local_exit_root() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_new_local_exit_root(ArgT0&& arg0, ArgT... args);
  std::string* mutable_new_local_exit_root();
  PROTOBUF_NODISCARD std::string* release_new_local_exit_root();
  void set_allocated_new_local_exit_root(std::string* new_local_exit_root);
  private:
  const std::string& _internal_new_local_exit_root() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_new_local_exit_root(const std::string& value);
  std::string* _internal_mutable_new_local_exit_root();
  public:

  // string prover_id = 18;
  void clear_prover_id();
  const std::string& prover_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_prover_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_prover_id();
  PROTOBUF_NODISCARD std::string* release_prover_id();
  void set_allocated_prover_id(std::string* prover_id);
  private:
  const std::string& _internal_prover_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_prover_id(const std::string& value);
  std::string* _internal_mutable_prover_id();
  public:

  // uint64 new_batch_num = 4;
  void clear_new_batch_num();
  uint64_t new_batch_num() const;
  void set_new_batch_num(uint64_t value);
  private:
  uint64_t _internal_new_batch_num() const;
  void _internal_set_new_batch_num(uint64_t value);
  public:

  // uint32 cnt_keccak_hashes = 5;
  void clear_cnt_keccak_hashes();
  uint32_t cnt_keccak_hashes() const;
  void set_cnt_keccak_hashes(uint32_t value);
  private:
  uint32_t _internal_cnt_keccak_hashes() const;
  void _internal_set_cnt_keccak_hashes(uint32_t value);
  public:

  // uint32 cnt_poseidon_hashes = 6;
  void clear_cnt_poseidon_hashes();
  uint32_t cnt_poseidon_hashes() const;
  void set_cnt_poseidon_hashes(uint32_t value);
  private:
  uint32_t _internal_cnt_poseidon_hashes() const;
  void _internal_set_cnt_poseidon_hashes(uint32_t value);
  public:

  // uint32 cnt_poseidon_paddings = 7;
  void clear_cnt_poseidon_paddings();
  uint32_t cnt_poseidon_paddings() const;
  void set_cnt_poseidon_paddings(uint32_t value);
  private:
  uint32_t _internal_cnt_poseidon_paddings() const;
  void _internal_set_cnt_poseidon_paddings(uint32_t value);
  public:

  // uint32 cnt_mem_aligns = 8;
  void clear_cnt_mem_aligns();
  uint32_t cnt_mem_aligns() const;
  void set_cnt_mem_aligns(uint32_t value);
  private:
  uint32_t _internal_cnt_mem_aligns() const;
  void _internal_set_cnt_mem_aligns(uint32_t value);
  public:

  // uint32 cnt_arithmetics = 9;
  void clear_cnt_arithmetics();
  uint32_t cnt_arithmetics() const;
  void set_cnt_arithmetics(uint32_t value);
  private:
  uint32_t _internal_cnt_arithmetics() const;
  void _internal_set_cnt_arithmetics(uint32_t value);
  public:

  // uint32 cnt_binaries = 10;
  void clear_cnt_binaries();
  uint32_t cnt_binaries() const;
  void set_cnt_binaries(uint32_t value);
  private:
  uint32_t _internal_cnt_binaries() const;
  void _internal_set_cnt_binaries(uint32_t value);
  public:

  // uint64 cumulative_gas_used = 12;
  void clear_cumulative_gas_used();
  uint64_t cumulative_gas_used() const;
  void set_cumulative_gas_used(uint64_t value);
  private:
  uint64_t _internal_cumulative_gas_used() const;
  void _internal_set_cumulative_gas_used(uint64_t value);
  public:

  // uint32 cnt_steps = 11;
  void clear_cnt_steps();
  uint32_t cnt_steps() const;
  void set_cnt_steps(uint32_t value);
  private:
  uint32_t _internal_cnt_steps() const;
  void _internal_set_cnt_steps(uint32_t value);
  public:

  // .executor.v1.ExecutorError error = 14;
  void clear_error();
  ::executor::v1::ExecutorError error() const;
  void set_error(::executor::v1::ExecutorError value);
  private:
  ::executor::v1::ExecutorError _internal_error() const;
  void _internal_set_error(::executor::v1::ExecutorError value);
  public:

  // uint64 flush_id = 16;
  void clear_flush_id();
  uint64_t flush_id() const;
  void set_flush_id(uint64_t value);
  private:
  uint64_t _internal_flush_id() const;
  void _internal_set_flush_id(uint64_t value);
  public:

  // uint64 stored_flush_id = 17;
  void clear_stored_flush_id();
  uint64_t stored_flush_id() const;
  void set_stored_flush_id(uint64_t value);
  private:
  uint64_t _internal_stored_flush_id() const;
  void _internal_set_stored_flush_id(uint64_t value);
  public:

  // uint64 fork_id = 19;
  void clear_fork_id();
  uint64_t fork_id() const;
  void set_fork_id(uint64_t value);
  private:
  uint64_t _internal_fork_id() const;
  void _internal_set_fork_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:executor.v1.ProcessBatchResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::executor::v1::ProcessTransactionResponse > responses_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        ProcessBatchResponse_ReadWriteAddressesEntry_DoNotUse,
        std::string, ::executor::v1::InfoReadWrite,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> read_write_addresses_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr new_state_root_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr new_acc_input_hash_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr new_local_exit_root_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr prover_id_;
    uint64_t new_batch_num_;
    uint32_t cnt_keccak_hashes_;
    uint32_t cnt_poseidon_hashes_;
    uint32_t cnt_poseidon_paddings_;
    uint32_t cnt_mem_aligns_;
    uint32_t cnt_arithmetics_;
    uint32_t cnt_binaries_;
    uint64_t cumulative_gas_used_;
    uint32_t cnt_steps_;
    int error_;
    uint64_t flush_id_;
    uint64_t stored_flush_id_;
    uint64_t fork_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_executor_2eproto;
};
// -------------------------------------------------------------------

class GetFlushStatusResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:executor.v1.GetFlushStatusResponse) */ {
 public:
  inline GetFlushStatusResponse() : GetFlushStatusResponse(nullptr) {}
  ~GetFlushStatusResponse() override;
  explicit PROTOBUF_CONSTEXPR GetFlushStatusResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetFlushStatusResponse(const GetFlushStatusResponse& from);
  GetFlushStatusResponse(GetFlushStatusResponse&& from) noexcept
    : GetFlushStatusResponse() {
    *this = ::std::move(from);
  }

  inline GetFlushStatusResponse& operator=(const GetFlushStatusResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetFlushStatusResponse& operator=(GetFlushStatusResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetFlushStatusResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetFlushStatusResponse* internal_default_instance() {
    return reinterpret_cast<const GetFlushStatusResponse*>(
               &_GetFlushStatusResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(GetFlushStatusResponse& a, GetFlushStatusResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetFlushStatusResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetFlushStatusResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetFlushStatusResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetFlushStatusResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetFlushStatusResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetFlushStatusResponse& from) {
    GetFlushStatusResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetFlushStatusResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "executor.v1.GetFlushStatusResponse";
  }
  protected:
  explicit GetFlushStatusResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProverIdFieldNumber = 8,
    kStoredFlushIdFieldNumber = 1,
    kStoringFlushIdFieldNumber = 2,
    kLastFlushIdFieldNumber = 3,
    kPendingToFlushNodesFieldNumber = 4,
    kPendingToFlushProgramFieldNumber = 5,
    kStoringNodesFieldNumber = 6,
    kStoringProgramFieldNumber = 7,
  };
  // string prover_id = 8;
  void clear_prover_id();
  const std::string& prover_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_prover_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_prover_id();
  PROTOBUF_NODISCARD std::string* release_prover_id();
  void set_allocated_prover_id(std::string* prover_id);
  private:
  const std::string& _internal_prover_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_prover_id(const std::string& value);
  std::string* _internal_mutable_prover_id();
  public:

  // uint64 stored_flush_id = 1;
  void clear_stored_flush_id();
  uint64_t stored_flush_id() const;
  void set_stored_flush_id(uint64_t value);
  private:
  uint64_t _internal_stored_flush_id() const;
  void _internal_set_stored_flush_id(uint64_t value);
  public:

  // uint64 storing_flush_id = 2;
  void clear_storing_flush_id();
  uint64_t storing_flush_id() const;
  void set_storing_flush_id(uint64_t value);
  private:
  uint64_t _internal_storing_flush_id() const;
  void _internal_set_storing_flush_id(uint64_t value);
  public:

  // uint64 last_flush_id = 3;
  void clear_last_flush_id();
  uint64_t last_flush_id() const;
  void set_last_flush_id(uint64_t value);
  private:
  uint64_t _internal_last_flush_id() const;
  void _internal_set_last_flush_id(uint64_t value);
  public:

  // uint64 pending_to_flush_nodes = 4;
  void clear_pending_to_flush_nodes();
  uint64_t pending_to_flush_nodes() const;
  void set_pending_to_flush_nodes(uint64_t value);
  private:
  uint64_t _internal_pending_to_flush_nodes() const;
  void _internal_set_pending_to_flush_nodes(uint64_t value);
  public:

  // uint64 pending_to_flush_program = 5;
  void clear_pending_to_flush_program();
  uint64_t pending_to_flush_program() const;
  void set_pending_to_flush_program(uint64_t value);
  private:
  uint64_t _internal_pending_to_flush_program() const;
  void _internal_set_pending_to_flush_program(uint64_t value);
  public:

  // uint64 storing_nodes = 6;
  void clear_storing_nodes();
  uint64_t storing_nodes() const;
  void set_storing_nodes(uint64_t value);
  private:
  uint64_t _internal_storing_nodes() const;
  void _internal_set_storing_nodes(uint64_t value);
  public:

  // uint64 storing_program = 7;
  void clear_storing_program();
  uint64_t storing_program() const;
  void set_storing_program(uint64_t value);
  private:
  uint64_t _internal_storing_program() const;
  void _internal_set_storing_program(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:executor.v1.GetFlushStatusResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr prover_id_;
    uint64_t stored_flush_id_;
    uint64_t storing_flush_id_;
    uint64_t last_flush_id_;
    uint64_t pending_to_flush_nodes_;
    uint64_t pending_to_flush_program_;
    uint64_t storing_nodes_;
    uint64_t storing_program_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_executor_2eproto;
};
// -------------------------------------------------------------------

class TraceConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:executor.v1.TraceConfig) */ {
 public:
  inline TraceConfig() : TraceConfig(nullptr) {}
  ~TraceConfig() override;
  explicit PROTOBUF_CONSTEXPR TraceConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TraceConfig(const TraceConfig& from);
  TraceConfig(TraceConfig&& from) noexcept
    : TraceConfig() {
    *this = ::std::move(from);
  }

  inline TraceConfig& operator=(const TraceConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline TraceConfig& operator=(TraceConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TraceConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const TraceConfig* internal_default_instance() {
    return reinterpret_cast<const TraceConfig*>(
               &_TraceConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(TraceConfig& a, TraceConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(TraceConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TraceConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TraceConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TraceConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TraceConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TraceConfig& from) {
    TraceConfig::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TraceConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "executor.v1.TraceConfig";
  }
  protected:
  explicit TraceConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTxHashToGenerateFullTraceFieldNumber = 5,
    kDisableStorageFieldNumber = 1,
    kDisableStackFieldNumber = 2,
    kEnableMemoryFieldNumber = 3,
    kEnableReturnDataFieldNumber = 4,
  };
  // bytes tx_hash_to_generate_full_trace = 5;
  void clear_tx_hash_to_generate_full_trace();
  const std::string& tx_hash_to_generate_full_trace() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tx_hash_to_generate_full_trace(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tx_hash_to_generate_full_trace();
  PROTOBUF_NODISCARD std::string* release_tx_hash_to_generate_full_trace();
  void set_allocated_tx_hash_to_generate_full_trace(std::string* tx_hash_to_generate_full_trace);
  private:
  const std::string& _internal_tx_hash_to_generate_full_trace() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tx_hash_to_generate_full_trace(const std::string& value);
  std::string* _internal_mutable_tx_hash_to_generate_full_trace();
  public:

  // uint32 disable_storage = 1;
  void clear_disable_storage();
  uint32_t disable_storage() const;
  void set_disable_storage(uint32_t value);
  private:
  uint32_t _internal_disable_storage() const;
  void _internal_set_disable_storage(uint32_t value);
  public:

  // uint32 disable_stack = 2;
  void clear_disable_stack();
  uint32_t disable_stack() const;
  void set_disable_stack(uint32_t value);
  private:
  uint32_t _internal_disable_stack() const;
  void _internal_set_disable_stack(uint32_t value);
  public:

  // uint32 enable_memory = 3;
  void clear_enable_memory();
  uint32_t enable_memory() const;
  void set_enable_memory(uint32_t value);
  private:
  uint32_t _internal_enable_memory() const;
  void _internal_set_enable_memory(uint32_t value);
  public:

  // uint32 enable_return_data = 4;
  void clear_enable_return_data();
  uint32_t enable_return_data() const;
  void set_enable_return_data(uint32_t value);
  private:
  uint32_t _internal_enable_return_data() const;
  void _internal_set_enable_return_data(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:executor.v1.TraceConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tx_hash_to_generate_full_trace_;
    uint32_t disable_storage_;
    uint32_t disable_stack_;
    uint32_t enable_memory_;
    uint32_t enable_return_data_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_executor_2eproto;
};
// -------------------------------------------------------------------

class OverrideAccount_StateEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<OverrideAccount_StateEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<OverrideAccount_StateEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  OverrideAccount_StateEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR OverrideAccount_StateEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit OverrideAccount_StateEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const OverrideAccount_StateEntry_DoNotUse& other);
  static const OverrideAccount_StateEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const OverrideAccount_StateEntry_DoNotUse*>(&_OverrideAccount_StateEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "executor.v1.OverrideAccount.StateEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "executor.v1.OverrideAccount.StateEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_executor_2eproto;
};

// -------------------------------------------------------------------

class OverrideAccount_StateDiffEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<OverrideAccount_StateDiffEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<OverrideAccount_StateDiffEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  OverrideAccount_StateDiffEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR OverrideAccount_StateDiffEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit OverrideAccount_StateDiffEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const OverrideAccount_StateDiffEntry_DoNotUse& other);
  static const OverrideAccount_StateDiffEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const OverrideAccount_StateDiffEntry_DoNotUse*>(&_OverrideAccount_StateDiffEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "executor.v1.OverrideAccount.StateDiffEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "executor.v1.OverrideAccount.StateDiffEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_executor_2eproto;
};

// -------------------------------------------------------------------

class OverrideAccount final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:executor.v1.OverrideAccount) */ {
 public:
  inline OverrideAccount() : OverrideAccount(nullptr) {}
  ~OverrideAccount() override;
  explicit PROTOBUF_CONSTEXPR OverrideAccount(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OverrideAccount(const OverrideAccount& from);
  OverrideAccount(OverrideAccount&& from) noexcept
    : OverrideAccount() {
    *this = ::std::move(from);
  }

  inline OverrideAccount& operator=(const OverrideAccount& from) {
    CopyFrom(from);
    return *this;
  }
  inline OverrideAccount& operator=(OverrideAccount&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OverrideAccount& default_instance() {
    return *internal_default_instance();
  }
  static inline const OverrideAccount* internal_default_instance() {
    return reinterpret_cast<const OverrideAccount*>(
               &_OverrideAccount_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(OverrideAccount& a, OverrideAccount& b) {
    a.Swap(&b);
  }
  inline void Swap(OverrideAccount* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OverrideAccount* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OverrideAccount* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OverrideAccount>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OverrideAccount& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OverrideAccount& from) {
    OverrideAccount::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OverrideAccount* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "executor.v1.OverrideAccount";
  }
  protected:
  explicit OverrideAccount(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kStateFieldNumber = 4,
    kStateDiffFieldNumber = 5,
    kBalanceFieldNumber = 1,
    kCodeFieldNumber = 3,
    kNonceFieldNumber = 2,
  };
  // map<string, string> state = 4;
  int state_size() const;
  private:
  int _internal_state_size() const;
  public:
  void clear_state();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_state() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_state();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      state() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_state();

  // map<string, string> state_diff = 5;
  int state_diff_size() const;
  private:
  int _internal_state_diff_size() const;
  public:
  void clear_state_diff();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_state_diff() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_state_diff();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      state_diff() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_state_diff();

  // bytes balance = 1;
  void clear_balance();
  const std::string& balance() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_balance(ArgT0&& arg0, ArgT... args);
  std::string* mutable_balance();
  PROTOBUF_NODISCARD std::string* release_balance();
  void set_allocated_balance(std::string* balance);
  private:
  const std::string& _internal_balance() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_balance(const std::string& value);
  std::string* _internal_mutable_balance();
  public:

  // bytes code = 3;
  void clear_code();
  const std::string& code() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_code(ArgT0&& arg0, ArgT... args);
  std::string* mutable_code();
  PROTOBUF_NODISCARD std::string* release_code();
  void set_allocated_code(std::string* code);
  private:
  const std::string& _internal_code() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_code(const std::string& value);
  std::string* _internal_mutable_code();
  public:

  // uint64 nonce = 2;
  void clear_nonce();
  uint64_t nonce() const;
  void set_nonce(uint64_t value);
  private:
  uint64_t _internal_nonce() const;
  void _internal_set_nonce(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:executor.v1.OverrideAccount)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        OverrideAccount_StateEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> state_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        OverrideAccount_StateDiffEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> state_diff_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr balance_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr code_;
    uint64_t nonce_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_executor_2eproto;
};
// -------------------------------------------------------------------

class InfoReadWrite final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:executor.v1.InfoReadWrite) */ {
 public:
  inline InfoReadWrite() : InfoReadWrite(nullptr) {}
  ~InfoReadWrite() override;
  explicit PROTOBUF_CONSTEXPR InfoReadWrite(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InfoReadWrite(const InfoReadWrite& from);
  InfoReadWrite(InfoReadWrite&& from) noexcept
    : InfoReadWrite() {
    *this = ::std::move(from);
  }

  inline InfoReadWrite& operator=(const InfoReadWrite& from) {
    CopyFrom(from);
    return *this;
  }
  inline InfoReadWrite& operator=(InfoReadWrite&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InfoReadWrite& default_instance() {
    return *internal_default_instance();
  }
  static inline const InfoReadWrite* internal_default_instance() {
    return reinterpret_cast<const InfoReadWrite*>(
               &_InfoReadWrite_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(InfoReadWrite& a, InfoReadWrite& b) {
    a.Swap(&b);
  }
  inline void Swap(InfoReadWrite* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InfoReadWrite* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InfoReadWrite* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InfoReadWrite>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InfoReadWrite& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const InfoReadWrite& from) {
    InfoReadWrite::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InfoReadWrite* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "executor.v1.InfoReadWrite";
  }
  protected:
  explicit InfoReadWrite(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNonceFieldNumber = 1,
    kBalanceFieldNumber = 2,
  };
  // string nonce = 1;
  void clear_nonce();
  const std::string& nonce() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_nonce(ArgT0&& arg0, ArgT... args);
  std::string* mutable_nonce();
  PROTOBUF_NODISCARD std::string* release_nonce();
  void set_allocated_nonce(std::string* nonce);
  private:
  const std::string& _internal_nonce() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_nonce(const std::string& value);
  std::string* _internal_mutable_nonce();
  public:

  // string balance = 2;
  void clear_balance();
  const std::string& balance() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_balance(ArgT0&& arg0, ArgT... args);
  std::string* mutable_balance();
  PROTOBUF_NODISCARD std::string* release_balance();
  void set_allocated_balance(std::string* balance);
  private:
  const std::string& _internal_balance() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_balance(const std::string& value);
  std::string* _internal_mutable_balance();
  public:

  // @@protoc_insertion_point(class_scope:executor.v1.InfoReadWrite)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr nonce_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr balance_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_executor_2eproto;
};
// -------------------------------------------------------------------

class FullTrace final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:executor.v1.FullTrace) */ {
 public:
  inline FullTrace() : FullTrace(nullptr) {}
  ~FullTrace() override;
  explicit PROTOBUF_CONSTEXPR FullTrace(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FullTrace(const FullTrace& from);
  FullTrace(FullTrace&& from) noexcept
    : FullTrace() {
    *this = ::std::move(from);
  }

  inline FullTrace& operator=(const FullTrace& from) {
    CopyFrom(from);
    return *this;
  }
  inline FullTrace& operator=(FullTrace&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FullTrace& default_instance() {
    return *internal_default_instance();
  }
  static inline const FullTrace* internal_default_instance() {
    return reinterpret_cast<const FullTrace*>(
               &_FullTrace_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(FullTrace& a, FullTrace& b) {
    a.Swap(&b);
  }
  inline void Swap(FullTrace* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FullTrace* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FullTrace* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FullTrace>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FullTrace& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FullTrace& from) {
    FullTrace::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FullTrace* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "executor.v1.FullTrace";
  }
  protected:
  explicit FullTrace(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStepsFieldNumber = 2,
    kContextFieldNumber = 1,
  };
  // repeated .executor.v1.TransactionStep steps = 2;
  int steps_size() const;
  private:
  int _internal_steps_size() const;
  public:
  void clear_steps();
  ::executor::v1::TransactionStep* mutable_steps(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::executor::v1::TransactionStep >*
      mutable_steps();
  private:
  const ::executor::v1::TransactionStep& _internal_steps(int index) const;
  ::executor::v1::TransactionStep* _internal_add_steps();
  public:
  const ::executor::v1::TransactionStep& steps(int index) const;
  ::executor::v1::TransactionStep* add_steps();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::executor::v1::TransactionStep >&
      steps() const;

  // .executor.v1.TransactionContext context = 1;
  bool has_context() const;
  private:
  bool _internal_has_context() const;
  public:
  void clear_context();
  const ::executor::v1::TransactionContext& context() const;
  PROTOBUF_NODISCARD ::executor::v1::TransactionContext* release_context();
  ::executor::v1::TransactionContext* mutable_context();
  void set_allocated_context(::executor::v1::TransactionContext* context);
  private:
  const ::executor::v1::TransactionContext& _internal_context() const;
  ::executor::v1::TransactionContext* _internal_mutable_context();
  public:
  void unsafe_arena_set_allocated_context(
      ::executor::v1::TransactionContext* context);
  ::executor::v1::TransactionContext* unsafe_arena_release_context();

  // @@protoc_insertion_point(class_scope:executor.v1.FullTrace)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::executor::v1::TransactionStep > steps_;
    ::executor::v1::TransactionContext* context_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_executor_2eproto;
};
// -------------------------------------------------------------------

class TransactionContext final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:executor.v1.TransactionContext) */ {
 public:
  inline TransactionContext() : TransactionContext(nullptr) {}
  ~TransactionContext() override;
  explicit PROTOBUF_CONSTEXPR TransactionContext(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TransactionContext(const TransactionContext& from);
  TransactionContext(TransactionContext&& from) noexcept
    : TransactionContext() {
    *this = ::std::move(from);
  }

  inline TransactionContext& operator=(const TransactionContext& from) {
    CopyFrom(from);
    return *this;
  }
  inline TransactionContext& operator=(TransactionContext&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TransactionContext& default_instance() {
    return *internal_default_instance();
  }
  static inline const TransactionContext* internal_default_instance() {
    return reinterpret_cast<const TransactionContext*>(
               &_TransactionContext_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(TransactionContext& a, TransactionContext& b) {
    a.Swap(&b);
  }
  inline void Swap(TransactionContext* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TransactionContext* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TransactionContext* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TransactionContext>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TransactionContext& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TransactionContext& from) {
    TransactionContext::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TransactionContext* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "executor.v1.TransactionContext";
  }
  protected:
  explicit TransactionContext(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
    kFromFieldNumber = 2,
    kToFieldNumber = 3,
    kDataFieldNumber = 4,
    kValueFieldNumber = 6,
    kBatchFieldNumber = 7,
    kOutputFieldNumber = 8,
    kGasPriceFieldNumber = 10,
    kOldStateRootFieldNumber = 12,
    kGasFieldNumber = 5,
    kGasUsedFieldNumber = 9,
    kExecutionTimeFieldNumber = 11,
  };
  // string type = 1;
  void clear_type();
  const std::string& type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_type();
  PROTOBUF_NODISCARD std::string* release_type();
  void set_allocated_type(std::string* type);
  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(const std::string& value);
  std::string* _internal_mutable_type();
  public:

  // string from = 2;
  void clear_from();
  const std::string& from() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_from(ArgT0&& arg0, ArgT... args);
  std::string* mutable_from();
  PROTOBUF_NODISCARD std::string* release_from();
  void set_allocated_from(std::string* from);
  private:
  const std::string& _internal_from() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_from(const std::string& value);
  std::string* _internal_mutable_from();
  public:

  // string to = 3;
  void clear_to();
  const std::string& to() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_to(ArgT0&& arg0, ArgT... args);
  std::string* mutable_to();
  PROTOBUF_NODISCARD std::string* release_to();
  void set_allocated_to(std::string* to);
  private:
  const std::string& _internal_to() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_to(const std::string& value);
  std::string* _internal_mutable_to();
  public:

  // bytes data = 4;
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // string value = 6;
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // bytes batch = 7;
  void clear_batch();
  const std::string& batch() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_batch(ArgT0&& arg0, ArgT... args);
  std::string* mutable_batch();
  PROTOBUF_NODISCARD std::string* release_batch();
  void set_allocated_batch(std::string* batch);
  private:
  const std::string& _internal_batch() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_batch(const std::string& value);
  std::string* _internal_mutable_batch();
  public:

  // bytes output = 8;
  void clear_output();
  const std::string& output() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_output(ArgT0&& arg0, ArgT... args);
  std::string* mutable_output();
  PROTOBUF_NODISCARD std::string* release_output();
  void set_allocated_output(std::string* output);
  private:
  const std::string& _internal_output() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_output(const std::string& value);
  std::string* _internal_mutable_output();
  public:

  // string gas_price = 10;
  void clear_gas_price();
  const std::string& gas_price() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_gas_price(ArgT0&& arg0, ArgT... args);
  std::string* mutable_gas_price();
  PROTOBUF_NODISCARD std::string* release_gas_price();
  void set_allocated_gas_price(std::string* gas_price);
  private:
  const std::string& _internal_gas_price() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_gas_price(const std::string& value);
  std::string* _internal_mutable_gas_price();
  public:

  // bytes old_state_root = 12;
  void clear_old_state_root();
  const std::string& old_state_root() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_old_state_root(ArgT0&& arg0, ArgT... args);
  std::string* mutable_old_state_root();
  PROTOBUF_NODISCARD std::string* release_old_state_root();
  void set_allocated_old_state_root(std::string* old_state_root);
  private:
  const std::string& _internal_old_state_root() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_old_state_root(const std::string& value);
  std::string* _internal_mutable_old_state_root();
  public:

  // uint64 gas = 5;
  void clear_gas();
  uint64_t gas() const;
  void set_gas(uint64_t value);
  private:
  uint64_t _internal_gas() const;
  void _internal_set_gas(uint64_t value);
  public:

  // uint64 gas_used = 9;
  void clear_gas_used();
  uint64_t gas_used() const;
  void set_gas_used(uint64_t value);
  private:
  uint64_t _internal_gas_used() const;
  void _internal_set_gas_used(uint64_t value);
  public:

  // uint32 execution_time = 11;
  void clear_execution_time();
  uint32_t execution_time() const;
  void set_execution_time(uint32_t value);
  private:
  uint32_t _internal_execution_time() const;
  void _internal_set_execution_time(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:executor.v1.TransactionContext)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr from_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr to_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr batch_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr output_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr gas_price_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr old_state_root_;
    uint64_t gas_;
    uint64_t gas_used_;
    uint32_t execution_time_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_executor_2eproto;
};
// -------------------------------------------------------------------

class TransactionStep_StorageEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<TransactionStep_StorageEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<TransactionStep_StorageEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  TransactionStep_StorageEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR TransactionStep_StorageEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit TransactionStep_StorageEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const TransactionStep_StorageEntry_DoNotUse& other);
  static const TransactionStep_StorageEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const TransactionStep_StorageEntry_DoNotUse*>(&_TransactionStep_StorageEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "executor.v1.TransactionStep.StorageEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "executor.v1.TransactionStep.StorageEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_executor_2eproto;
};

// -------------------------------------------------------------------

class TransactionStep final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:executor.v1.TransactionStep) */ {
 public:
  inline TransactionStep() : TransactionStep(nullptr) {}
  ~TransactionStep() override;
  explicit PROTOBUF_CONSTEXPR TransactionStep(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TransactionStep(const TransactionStep& from);
  TransactionStep(TransactionStep&& from) noexcept
    : TransactionStep() {
    *this = ::std::move(from);
  }

  inline TransactionStep& operator=(const TransactionStep& from) {
    CopyFrom(from);
    return *this;
  }
  inline TransactionStep& operator=(TransactionStep&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TransactionStep& default_instance() {
    return *internal_default_instance();
  }
  static inline const TransactionStep* internal_default_instance() {
    return reinterpret_cast<const TransactionStep*>(
               &_TransactionStep_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(TransactionStep& a, TransactionStep& b) {
    a.Swap(&b);
  }
  inline void Swap(TransactionStep* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TransactionStep* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TransactionStep* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TransactionStep>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TransactionStep& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TransactionStep& from) {
    TransactionStep::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TransactionStep* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "executor.v1.TransactionStep";
  }
  protected:
  explicit TransactionStep(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kStackFieldNumber = 8,
    kStorageFieldNumber = 15,
    kStateRootFieldNumber = 1,
    kMemoryFieldNumber = 9,
    kReturnDataFieldNumber = 12,
    kContractFieldNumber = 13,
    kPcFieldNumber = 3,
    kGasFieldNumber = 4,
    kDepthFieldNumber = 2,
    kOpFieldNumber = 7,
    kGasCostFieldNumber = 5,
    kGasRefundFieldNumber = 6,
    kMemorySizeFieldNumber = 10,
    kMemoryOffsetFieldNumber = 11,
    kErrorFieldNumber = 14,
  };
  // repeated string stack = 8;
  int stack_size() const;
  private:
  int _internal_stack_size() const;
  public:
  void clear_stack();
  const std::string& stack(int index) const;
  std::string* mutable_stack(int index);
  void set_stack(int index, const std::string& value);
  void set_stack(int index, std::string&& value);
  void set_stack(int index, const char* value);
  void set_stack(int index, const char* value, size_t size);
  std::string* add_stack();
  void add_stack(const std::string& value);
  void add_stack(std::string&& value);
  void add_stack(const char* value);
  void add_stack(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& stack() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_stack();
  private:
  const std::string& _internal_stack(int index) const;
  std::string* _internal_add_stack();
  public:

  // map<string, string> storage = 15;
  int storage_size() const;
  private:
  int _internal_storage_size() const;
  public:
  void clear_storage();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_storage() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_storage();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      storage() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_storage();

  // bytes state_root = 1;
  void clear_state_root();
  const std::string& state_root() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_state_root(ArgT0&& arg0, ArgT... args);
  std::string* mutable_state_root();
  PROTOBUF_NODISCARD std::string* release_state_root();
  void set_allocated_state_root(std::string* state_root);
  private:
  const std::string& _internal_state_root() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_state_root(const std::string& value);
  std::string* _internal_mutable_state_root();
  public:

  // bytes memory = 9;
  void clear_memory();
  const std::string& memory() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_memory(ArgT0&& arg0, ArgT... args);
  std::string* mutable_memory();
  PROTOBUF_NODISCARD std::string* release_memory();
  void set_allocated_memory(std::string* memory);
  private:
  const std::string& _internal_memory() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_memory(const std::string& value);
  std::string* _internal_mutable_memory();
  public:

  // bytes return_data = 12;
  void clear_return_data();
  const std::string& return_data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_return_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_return_data();
  PROTOBUF_NODISCARD std::string* release_return_data();
  void set_allocated_return_data(std::string* return_data);
  private:
  const std::string& _internal_return_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_return_data(const std::string& value);
  std::string* _internal_mutable_return_data();
  public:

  // .executor.v1.Contract contract = 13;
  bool has_contract() const;
  private:
  bool _internal_has_contract() const;
  public:
  void clear_contract();
  const ::executor::v1::Contract& contract() const;
  PROTOBUF_NODISCARD ::executor::v1::Contract* release_contract();
  ::executor::v1::Contract* mutable_contract();
  void set_allocated_contract(::executor::v1::Contract* contract);
  private:
  const ::executor::v1::Contract& _internal_contract() const;
  ::executor::v1::Contract* _internal_mutable_contract();
  public:
  void unsafe_arena_set_allocated_contract(
      ::executor::v1::Contract* contract);
  ::executor::v1::Contract* unsafe_arena_release_contract();

  // uint64 pc = 3;
  void clear_pc();
  uint64_t pc() const;
  void set_pc(uint64_t value);
  private:
  uint64_t _internal_pc() const;
  void _internal_set_pc(uint64_t value);
  public:

  // uint64 gas = 4;
  void clear_gas();
  uint64_t gas() const;
  void set_gas(uint64_t value);
  private:
  uint64_t _internal_gas() const;
  void _internal_set_gas(uint64_t value);
  public:

  // uint32 depth = 2;
  void clear_depth();
  uint32_t depth() const;
  void set_depth(uint32_t value);
  private:
  uint32_t _internal_depth() const;
  void _internal_set_depth(uint32_t value);
  public:

  // uint32 op = 7;
  void clear_op();
  uint32_t op() const;
  void set_op(uint32_t value);
  private:
  uint32_t _internal_op() const;
  void _internal_set_op(uint32_t value);
  public:

  // uint64 gas_cost = 5;
  void clear_gas_cost();
  uint64_t gas_cost() const;
  void set_gas_cost(uint64_t value);
  private:
  uint64_t _internal_gas_cost() const;
  void _internal_set_gas_cost(uint64_t value);
  public:

  // uint64 gas_refund = 6;
  void clear_gas_refund();
  uint64_t gas_refund() const;
  void set_gas_refund(uint64_t value);
  private:
  uint64_t _internal_gas_refund() const;
  void _internal_set_gas_refund(uint64_t value);
  public:

  // uint32 memory_size = 10;
  void clear_memory_size();
  uint32_t memory_size() const;
  void set_memory_size(uint32_t value);
  private:
  uint32_t _internal_memory_size() const;
  void _internal_set_memory_size(uint32_t value);
  public:

  // uint32 memory_offset = 11;
  void clear_memory_offset();
  uint32_t memory_offset() const;
  void set_memory_offset(uint32_t value);
  private:
  uint32_t _internal_memory_offset() const;
  void _internal_set_memory_offset(uint32_t value);
  public:

  // .executor.v1.RomError error = 14;
  void clear_error();
  ::executor::v1::RomError error() const;
  void set_error(::executor::v1::RomError value);
  private:
  ::executor::v1::RomError _internal_error() const;
  void _internal_set_error(::executor::v1::RomError value);
  public:

  // @@protoc_insertion_point(class_scope:executor.v1.TransactionStep)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> stack_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        TransactionStep_StorageEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> storage_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr state_root_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr memory_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr return_data_;
    ::executor::v1::Contract* contract_;
    uint64_t pc_;
    uint64_t gas_;
    uint32_t depth_;
    uint32_t op_;
    uint64_t gas_cost_;
    uint64_t gas_refund_;
    uint32_t memory_size_;
    uint32_t memory_offset_;
    int error_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_executor_2eproto;
};
// -------------------------------------------------------------------

class Contract final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:executor.v1.Contract) */ {
 public:
  inline Contract() : Contract(nullptr) {}
  ~Contract() override;
  explicit PROTOBUF_CONSTEXPR Contract(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Contract(const Contract& from);
  Contract(Contract&& from) noexcept
    : Contract() {
    *this = ::std::move(from);
  }

  inline Contract& operator=(const Contract& from) {
    CopyFrom(from);
    return *this;
  }
  inline Contract& operator=(Contract&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Contract& default_instance() {
    return *internal_default_instance();
  }
  static inline const Contract* internal_default_instance() {
    return reinterpret_cast<const Contract*>(
               &_Contract_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(Contract& a, Contract& b) {
    a.Swap(&b);
  }
  inline void Swap(Contract* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Contract* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Contract* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Contract>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Contract& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Contract& from) {
    Contract::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Contract* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "executor.v1.Contract";
  }
  protected:
  explicit Contract(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddressFieldNumber = 1,
    kCallerFieldNumber = 2,
    kValueFieldNumber = 3,
    kDataFieldNumber = 4,
    kTypeFieldNumber = 6,
    kGasFieldNumber = 5,
  };
  // string address = 1;
  void clear_address();
  const std::string& address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_address();
  PROTOBUF_NODISCARD std::string* release_address();
  void set_allocated_address(std::string* address);
  private:
  const std::string& _internal_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_address(const std::string& value);
  std::string* _internal_mutable_address();
  public:

  // string caller = 2;
  void clear_caller();
  const std::string& caller() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_caller(ArgT0&& arg0, ArgT... args);
  std::string* mutable_caller();
  PROTOBUF_NODISCARD std::string* release_caller();
  void set_allocated_caller(std::string* caller);
  private:
  const std::string& _internal_caller() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_caller(const std::string& value);
  std::string* _internal_mutable_caller();
  public:

  // string value = 3;
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // bytes data = 4;
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // string type = 6;
  void clear_type();
  const std::string& type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_type();
  PROTOBUF_NODISCARD std::string* release_type();
  void set_allocated_type(std::string* type);
  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(const std::string& value);
  std::string* _internal_mutable_type();
  public:

  // uint64 gas = 5;
  void clear_gas();
  uint64_t gas() const;
  void set_gas(uint64_t value);
  private:
  uint64_t _internal_gas() const;
  void _internal_set_gas(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:executor.v1.Contract)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr address_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr caller_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
    uint64_t gas_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_executor_2eproto;
};
// -------------------------------------------------------------------

class ProcessTransactionResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:executor.v1.ProcessTransactionResponse) */ {
 public:
  inline ProcessTransactionResponse() : ProcessTransactionResponse(nullptr) {}
  ~ProcessTransactionResponse() override;
  explicit PROTOBUF_CONSTEXPR ProcessTransactionResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ProcessTransactionResponse(const ProcessTransactionResponse& from);
  ProcessTransactionResponse(ProcessTransactionResponse&& from) noexcept
    : ProcessTransactionResponse() {
    *this = ::std::move(from);
  }

  inline ProcessTransactionResponse& operator=(const ProcessTransactionResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProcessTransactionResponse& operator=(ProcessTransactionResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ProcessTransactionResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ProcessTransactionResponse* internal_default_instance() {
    return reinterpret_cast<const ProcessTransactionResponse*>(
               &_ProcessTransactionResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(ProcessTransactionResponse& a, ProcessTransactionResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ProcessTransactionResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProcessTransactionResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ProcessTransactionResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ProcessTransactionResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ProcessTransactionResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ProcessTransactionResponse& from) {
    ProcessTransactionResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProcessTransactionResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "executor.v1.ProcessTransactionResponse";
  }
  protected:
  explicit ProcessTransactionResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLogsFieldNumber = 11,
    kTxHashFieldNumber = 1,
    kRlpTxFieldNumber = 2,
    kReturnValueFieldNumber = 4,
    kCreateAddressFieldNumber = 9,
    kStateRootFieldNumber = 10,
    kEffectiveGasPriceFieldNumber = 15,
    kFullTraceFieldNumber = 14,
    kGasLeftFieldNumber = 5,
    kTypeFieldNumber = 3,
    kErrorFieldNumber = 8,
    kGasUsedFieldNumber = 6,
    kGasRefundedFieldNumber = 7,
    kEffectivePercentageFieldNumber = 16,
    kHasGaspriceOpcodeFieldNumber = 17,
    kHasBalanceOpcodeFieldNumber = 18,
  };
  // repeated .executor.v1.Log logs = 11;
  int logs_size() const;
  private:
  int _internal_logs_size() const;
  public:
  void clear_logs();
  ::executor::v1::Log* mutable_logs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::executor::v1::Log >*
      mutable_logs();
  private:
  const ::executor::v1::Log& _internal_logs(int index) const;
  ::executor::v1::Log* _internal_add_logs();
  public:
  const ::executor::v1::Log& logs(int index) const;
  ::executor::v1::Log* add_logs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::executor::v1::Log >&
      logs() const;

  // bytes tx_hash = 1;
  void clear_tx_hash();
  const std::string& tx_hash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tx_hash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tx_hash();
  PROTOBUF_NODISCARD std::string* release_tx_hash();
  void set_allocated_tx_hash(std::string* tx_hash);
  private:
  const std::string& _internal_tx_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tx_hash(const std::string& value);
  std::string* _internal_mutable_tx_hash();
  public:

  // bytes rlp_tx = 2;
  void clear_rlp_tx();
  const std::string& rlp_tx() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_rlp_tx(ArgT0&& arg0, ArgT... args);
  std::string* mutable_rlp_tx();
  PROTOBUF_NODISCARD std::string* release_rlp_tx();
  void set_allocated_rlp_tx(std::string* rlp_tx);
  private:
  const std::string& _internal_rlp_tx() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_rlp_tx(const std::string& value);
  std::string* _internal_mutable_rlp_tx();
  public:

  // bytes return_value = 4;
  void clear_return_value();
  const std::string& return_value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_return_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_return_value();
  PROTOBUF_NODISCARD std::string* release_return_value();
  void set_allocated_return_value(std::string* return_value);
  private:
  const std::string& _internal_return_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_return_value(const std::string& value);
  std::string* _internal_mutable_return_value();
  public:

  // string create_address = 9;
  void clear_create_address();
  const std::string& create_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_create_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_create_address();
  PROTOBUF_NODISCARD std::string* release_create_address();
  void set_allocated_create_address(std::string* create_address);
  private:
  const std::string& _internal_create_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_create_address(const std::string& value);
  std::string* _internal_mutable_create_address();
  public:

  // bytes state_root = 10;
  void clear_state_root();
  const std::string& state_root() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_state_root(ArgT0&& arg0, ArgT... args);
  std::string* mutable_state_root();
  PROTOBUF_NODISCARD std::string* release_state_root();
  void set_allocated_state_root(std::string* state_root);
  private:
  const std::string& _internal_state_root() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_state_root(const std::string& value);
  std::string* _internal_mutable_state_root();
  public:

  // string effective_gas_price = 15;
  void clear_effective_gas_price();
  const std::string& effective_gas_price() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_effective_gas_price(ArgT0&& arg0, ArgT... args);
  std::string* mutable_effective_gas_price();
  PROTOBUF_NODISCARD std::string* release_effective_gas_price();
  void set_allocated_effective_gas_price(std::string* effective_gas_price);
  private:
  const std::string& _internal_effective_gas_price() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_effective_gas_price(const std::string& value);
  std::string* _internal_mutable_effective_gas_price();
  public:

  // .executor.v1.FullTrace full_trace = 14;
  bool has_full_trace() const;
  private:
  bool _internal_has_full_trace() const;
  public:
  void clear_full_trace();
  const ::executor::v1::FullTrace& full_trace() const;
  PROTOBUF_NODISCARD ::executor::v1::FullTrace* release_full_trace();
  ::executor::v1::FullTrace* mutable_full_trace();
  void set_allocated_full_trace(::executor::v1::FullTrace* full_trace);
  private:
  const ::executor::v1::FullTrace& _internal_full_trace() const;
  ::executor::v1::FullTrace* _internal_mutable_full_trace();
  public:
  void unsafe_arena_set_allocated_full_trace(
      ::executor::v1::FullTrace* full_trace);
  ::executor::v1::FullTrace* unsafe_arena_release_full_trace();

  // uint64 gas_left = 5;
  void clear_gas_left();
  uint64_t gas_left() const;
  void set_gas_left(uint64_t value);
  private:
  uint64_t _internal_gas_left() const;
  void _internal_set_gas_left(uint64_t value);
  public:

  // uint32 type = 3;
  void clear_type();
  uint32_t type() const;
  void set_type(uint32_t value);
  private:
  uint32_t _internal_type() const;
  void _internal_set_type(uint32_t value);
  public:

  // .executor.v1.RomError error = 8;
  void clear_error();
  ::executor::v1::RomError error() const;
  void set_error(::executor::v1::RomError value);
  private:
  ::executor::v1::RomError _internal_error() const;
  void _internal_set_error(::executor::v1::RomError value);
  public:

  // uint64 gas_used = 6;
  void clear_gas_used();
  uint64_t gas_used() const;
  void set_gas_used(uint64_t value);
  private:
  uint64_t _internal_gas_used() const;
  void _internal_set_gas_used(uint64_t value);
  public:

  // uint64 gas_refunded = 7;
  void clear_gas_refunded();
  uint64_t gas_refunded() const;
  void set_gas_refunded(uint64_t value);
  private:
  uint64_t _internal_gas_refunded() const;
  void _internal_set_gas_refunded(uint64_t value);
  public:

  // uint32 effective_percentage = 16;
  void clear_effective_percentage();
  uint32_t effective_percentage() const;
  void set_effective_percentage(uint32_t value);
  private:
  uint32_t _internal_effective_percentage() const;
  void _internal_set_effective_percentage(uint32_t value);
  public:

  // uint32 has_gasprice_opcode = 17;
  void clear_has_gasprice_opcode();
  uint32_t has_gasprice_opcode() const;
  void set_has_gasprice_opcode(uint32_t value);
  private:
  uint32_t _internal_has_gasprice_opcode() const;
  void _internal_set_has_gasprice_opcode(uint32_t value);
  public:

  // uint32 has_balance_opcode = 18;
  void clear_has_balance_opcode();
  uint32_t has_balance_opcode() const;
  void set_has_balance_opcode(uint32_t value);
  private:
  uint32_t _internal_has_balance_opcode() const;
  void _internal_set_has_balance_opcode(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:executor.v1.ProcessTransactionResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::executor::v1::Log > logs_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tx_hash_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr rlp_tx_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr return_value_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr create_address_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr state_root_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr effective_gas_price_;
    ::executor::v1::FullTrace* full_trace_;
    uint64_t gas_left_;
    uint32_t type_;
    int error_;
    uint64_t gas_used_;
    uint64_t gas_refunded_;
    uint32_t effective_percentage_;
    uint32_t has_gasprice_opcode_;
    uint32_t has_balance_opcode_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_executor_2eproto;
};
// -------------------------------------------------------------------

class Log final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:executor.v1.Log) */ {
 public:
  inline Log() : Log(nullptr) {}
  ~Log() override;
  explicit PROTOBUF_CONSTEXPR Log(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Log(const Log& from);
  Log(Log&& from) noexcept
    : Log() {
    *this = ::std::move(from);
  }

  inline Log& operator=(const Log& from) {
    CopyFrom(from);
    return *this;
  }
  inline Log& operator=(Log&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Log& default_instance() {
    return *internal_default_instance();
  }
  static inline const Log* internal_default_instance() {
    return reinterpret_cast<const Log*>(
               &_Log_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(Log& a, Log& b) {
    a.Swap(&b);
  }
  inline void Swap(Log* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Log* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Log* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Log>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Log& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Log& from) {
    Log::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Log* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "executor.v1.Log";
  }
  protected:
  explicit Log(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTopicsFieldNumber = 2,
    kAddressFieldNumber = 1,
    kDataFieldNumber = 3,
    kTxHashFieldNumber = 5,
    kBatchHashFieldNumber = 7,
    kBatchNumberFieldNumber = 4,
    kTxIndexFieldNumber = 6,
    kIndexFieldNumber = 8,
  };
  // repeated bytes topics = 2;
  int topics_size() const;
  private:
  int _internal_topics_size() const;
  public:
  void clear_topics();
  const std::string& topics(int index) const;
  std::string* mutable_topics(int index);
  void set_topics(int index, const std::string& value);
  void set_topics(int index, std::string&& value);
  void set_topics(int index, const char* value);
  void set_topics(int index, const void* value, size_t size);
  std::string* add_topics();
  void add_topics(const std::string& value);
  void add_topics(std::string&& value);
  void add_topics(const char* value);
  void add_topics(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& topics() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_topics();
  private:
  const std::string& _internal_topics(int index) const;
  std::string* _internal_add_topics();
  public:

  // string address = 1;
  void clear_address();
  const std::string& address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_address();
  PROTOBUF_NODISCARD std::string* release_address();
  void set_allocated_address(std::string* address);
  private:
  const std::string& _internal_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_address(const std::string& value);
  std::string* _internal_mutable_address();
  public:

  // bytes data = 3;
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // bytes tx_hash = 5;
  void clear_tx_hash();
  const std::string& tx_hash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tx_hash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tx_hash();
  PROTOBUF_NODISCARD std::string* release_tx_hash();
  void set_allocated_tx_hash(std::string* tx_hash);
  private:
  const std::string& _internal_tx_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tx_hash(const std::string& value);
  std::string* _internal_mutable_tx_hash();
  public:

  // bytes batch_hash = 7;
  void clear_batch_hash();
  const std::string& batch_hash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_batch_hash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_batch_hash();
  PROTOBUF_NODISCARD std::string* release_batch_hash();
  void set_allocated_batch_hash(std::string* batch_hash);
  private:
  const std::string& _internal_batch_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_batch_hash(const std::string& value);
  std::string* _internal_mutable_batch_hash();
  public:

  // uint64 batch_number = 4;
  void clear_batch_number();
  uint64_t batch_number() const;
  void set_batch_number(uint64_t value);
  private:
  uint64_t _internal_batch_number() const;
  void _internal_set_batch_number(uint64_t value);
  public:

  // uint32 tx_index = 6;
  void clear_tx_index();
  uint32_t tx_index() const;
  void set_tx_index(uint32_t value);
  private:
  uint32_t _internal_tx_index() const;
  void _internal_set_tx_index(uint32_t value);
  public:

  // uint32 index = 8;
  void clear_index();
  uint32_t index() const;
  void set_index(uint32_t value);
  private:
  uint32_t _internal_index() const;
  void _internal_set_index(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:executor.v1.Log)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> topics_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr address_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tx_hash_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr batch_hash_;
    uint64_t batch_number_;
    uint32_t tx_index_;
    uint32_t index_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_executor_2eproto;
};
// -------------------------------------------------------------------

class ProcessBatchRequestV2_L1InfoTreeDataEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ProcessBatchRequestV2_L1InfoTreeDataEntry_DoNotUse, 
    uint32_t, ::executor::v1::L1DataV2,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ProcessBatchRequestV2_L1InfoTreeDataEntry_DoNotUse, 
    uint32_t, ::executor::v1::L1DataV2,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  ProcessBatchRequestV2_L1InfoTreeDataEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR ProcessBatchRequestV2_L1InfoTreeDataEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit ProcessBatchRequestV2_L1InfoTreeDataEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const ProcessBatchRequestV2_L1InfoTreeDataEntry_DoNotUse& other);
  static const ProcessBatchRequestV2_L1InfoTreeDataEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const ProcessBatchRequestV2_L1InfoTreeDataEntry_DoNotUse*>(&_ProcessBatchRequestV2_L1InfoTreeDataEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(void*) { return true; }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_executor_2eproto;
};

// -------------------------------------------------------------------

class ProcessBatchRequestV2_DbEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ProcessBatchRequestV2_DbEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ProcessBatchRequestV2_DbEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  ProcessBatchRequestV2_DbEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR ProcessBatchRequestV2_DbEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit ProcessBatchRequestV2_DbEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const ProcessBatchRequestV2_DbEntry_DoNotUse& other);
  static const ProcessBatchRequestV2_DbEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const ProcessBatchRequestV2_DbEntry_DoNotUse*>(&_ProcessBatchRequestV2_DbEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "executor.v1.ProcessBatchRequestV2.DbEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "executor.v1.ProcessBatchRequestV2.DbEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_executor_2eproto;
};

// -------------------------------------------------------------------

class ProcessBatchRequestV2_ContractsBytecodeEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ProcessBatchRequestV2_ContractsBytecodeEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ProcessBatchRequestV2_ContractsBytecodeEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  ProcessBatchRequestV2_ContractsBytecodeEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR ProcessBatchRequestV2_ContractsBytecodeEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit ProcessBatchRequestV2_ContractsBytecodeEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const ProcessBatchRequestV2_ContractsBytecodeEntry_DoNotUse& other);
  static const ProcessBatchRequestV2_ContractsBytecodeEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const ProcessBatchRequestV2_ContractsBytecodeEntry_DoNotUse*>(&_ProcessBatchRequestV2_ContractsBytecodeEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "executor.v1.ProcessBatchRequestV2.ContractsBytecodeEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "executor.v1.ProcessBatchRequestV2.ContractsBytecodeEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_executor_2eproto;
};

// -------------------------------------------------------------------

class ProcessBatchRequestV2_StateOverrideEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ProcessBatchRequestV2_StateOverrideEntry_DoNotUse, 
    std::string, ::executor::v1::OverrideAccountV2,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ProcessBatchRequestV2_StateOverrideEntry_DoNotUse, 
    std::string, ::executor::v1::OverrideAccountV2,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  ProcessBatchRequestV2_StateOverrideEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR ProcessBatchRequestV2_StateOverrideEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit ProcessBatchRequestV2_StateOverrideEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const ProcessBatchRequestV2_StateOverrideEntry_DoNotUse& other);
  static const ProcessBatchRequestV2_StateOverrideEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const ProcessBatchRequestV2_StateOverrideEntry_DoNotUse*>(&_ProcessBatchRequestV2_StateOverrideEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "executor.v1.ProcessBatchRequestV2.StateOverrideEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_executor_2eproto;
};

// -------------------------------------------------------------------

class ProcessBatchRequestV2 final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:executor.v1.ProcessBatchRequestV2) */ {
 public:
  inline ProcessBatchRequestV2() : ProcessBatchRequestV2(nullptr) {}
  ~ProcessBatchRequestV2() override;
  explicit PROTOBUF_CONSTEXPR ProcessBatchRequestV2(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ProcessBatchRequestV2(const ProcessBatchRequestV2& from);
  ProcessBatchRequestV2(ProcessBatchRequestV2&& from) noexcept
    : ProcessBatchRequestV2() {
    *this = ::std::move(from);
  }

  inline ProcessBatchRequestV2& operator=(const ProcessBatchRequestV2& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProcessBatchRequestV2& operator=(ProcessBatchRequestV2&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ProcessBatchRequestV2& default_instance() {
    return *internal_default_instance();
  }
  static inline const ProcessBatchRequestV2* internal_default_instance() {
    return reinterpret_cast<const ProcessBatchRequestV2*>(
               &_ProcessBatchRequestV2_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(ProcessBatchRequestV2& a, ProcessBatchRequestV2& b) {
    a.Swap(&b);
  }
  inline void Swap(ProcessBatchRequestV2* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProcessBatchRequestV2* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ProcessBatchRequestV2* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ProcessBatchRequestV2>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ProcessBatchRequestV2& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ProcessBatchRequestV2& from) {
    ProcessBatchRequestV2::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProcessBatchRequestV2* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "executor.v1.ProcessBatchRequestV2";
  }
  protected:
  explicit ProcessBatchRequestV2(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kL1InfoTreeDataFieldNumber = 17,
    kDbFieldNumber = 18,
    kContractsBytecodeFieldNumber = 19,
    kStateOverrideFieldNumber = 23,
    kOldStateRootFieldNumber = 1,
    kOldAccInputHashFieldNumber = 2,
    kBatchL2DataFieldNumber = 6,
    kL1InfoRootFieldNumber = 7,
    kCoinbaseFieldNumber = 9,
    kForcedBlockhashL1FieldNumber = 10,
    kFromFieldNumber = 13,
    kContextIdFieldNumber = 21,
    kTraceConfigFieldNumber = 20,
    kDebugFieldNumber = 24,
    kOldBatchNumFieldNumber = 3,
    kChainIdFieldNumber = 4,
    kForkIdFieldNumber = 5,
    kTimestampLimitFieldNumber = 8,
    kUpdateMerkleTreeFieldNumber = 11,
    kNoCountersFieldNumber = 12,
    kSkipVerifyL1InfoRootFieldNumber = 14,
    kSkipFirstChangeL2BlockFieldNumber = 15,
    kSkipWriteBlockInfoRootFieldNumber = 16,
    kGetKeysFieldNumber = 22,
  };
  // map<uint32, .executor.v1.L1DataV2> l1_info_tree_data = 17;
  int l1_info_tree_data_size() const;
  private:
  int _internal_l1_info_tree_data_size() const;
  public:
  void clear_l1_info_tree_data();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< uint32_t, ::executor::v1::L1DataV2 >&
      _internal_l1_info_tree_data() const;
  ::PROTOBUF_NAMESPACE_ID::Map< uint32_t, ::executor::v1::L1DataV2 >*
      _internal_mutable_l1_info_tree_data();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< uint32_t, ::executor::v1::L1DataV2 >&
      l1_info_tree_data() const;
  ::PROTOBUF_NAMESPACE_ID::Map< uint32_t, ::executor::v1::L1DataV2 >*
      mutable_l1_info_tree_data();

  // map<string, string> db = 18;
  int db_size() const;
  private:
  int _internal_db_size() const;
  public:
  void clear_db();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_db() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_db();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      db() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_db();

  // map<string, string> contracts_bytecode = 19;
  int contracts_bytecode_size() const;
  private:
  int _internal_contracts_bytecode_size() const;
  public:
  void clear_contracts_bytecode();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_contracts_bytecode() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_contracts_bytecode();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      contracts_bytecode() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_contracts_bytecode();

  // map<string, .executor.v1.OverrideAccountV2> state_override = 23;
  int state_override_size() const;
  private:
  int _internal_state_override_size() const;
  public:
  void clear_state_override();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::executor::v1::OverrideAccountV2 >&
      _internal_state_override() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::executor::v1::OverrideAccountV2 >*
      _internal_mutable_state_override();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::executor::v1::OverrideAccountV2 >&
      state_override() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::executor::v1::OverrideAccountV2 >*
      mutable_state_override();

  // bytes old_state_root = 1;
  void clear_old_state_root();
  const std::string& old_state_root() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_old_state_root(ArgT0&& arg0, ArgT... args);
  std::string* mutable_old_state_root();
  PROTOBUF_NODISCARD std::string* release_old_state_root();
  void set_allocated_old_state_root(std::string* old_state_root);
  private:
  const std::string& _internal_old_state_root() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_old_state_root(const std::string& value);
  std::string* _internal_mutable_old_state_root();
  public:

  // bytes old_acc_input_hash = 2;
  void clear_old_acc_input_hash();
  const std::string& old_acc_input_hash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_old_acc_input_hash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_old_acc_input_hash();
  PROTOBUF_NODISCARD std::string* release_old_acc_input_hash();
  void set_allocated_old_acc_input_hash(std::string* old_acc_input_hash);
  private:
  const std::string& _internal_old_acc_input_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_old_acc_input_hash(const std::string& value);
  std::string* _internal_mutable_old_acc_input_hash();
  public:

  // bytes batch_l2_data = 6;
  void clear_batch_l2_data();
  const std::string& batch_l2_data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_batch_l2_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_batch_l2_data();
  PROTOBUF_NODISCARD std::string* release_batch_l2_data();
  void set_allocated_batch_l2_data(std::string* batch_l2_data);
  private:
  const std::string& _internal_batch_l2_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_batch_l2_data(const std::string& value);
  std::string* _internal_mutable_batch_l2_data();
  public:

  // bytes l1_info_root = 7;
  void clear_l1_info_root();
  const std::string& l1_info_root() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_l1_info_root(ArgT0&& arg0, ArgT... args);
  std::string* mutable_l1_info_root();
  PROTOBUF_NODISCARD std::string* release_l1_info_root();
  void set_allocated_l1_info_root(std::string* l1_info_root);
  private:
  const std::string& _internal_l1_info_root() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_l1_info_root(const std::string& value);
  std::string* _internal_mutable_l1_info_root();
  public:

  // string coinbase = 9;
  void clear_coinbase();
  const std::string& coinbase() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_coinbase(ArgT0&& arg0, ArgT... args);
  std::string* mutable_coinbase();
  PROTOBUF_NODISCARD std::string* release_coinbase();
  void set_allocated_coinbase(std::string* coinbase);
  private:
  const std::string& _internal_coinbase() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_coinbase(const std::string& value);
  std::string* _internal_mutable_coinbase();
  public:

  // bytes forced_blockhash_l1 = 10;
  void clear_forced_blockhash_l1();
  const std::string& forced_blockhash_l1() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_forced_blockhash_l1(ArgT0&& arg0, ArgT... args);
  std::string* mutable_forced_blockhash_l1();
  PROTOBUF_NODISCARD std::string* release_forced_blockhash_l1();
  void set_allocated_forced_blockhash_l1(std::string* forced_blockhash_l1);
  private:
  const std::string& _internal_forced_blockhash_l1() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_forced_blockhash_l1(const std::string& value);
  std::string* _internal_mutable_forced_blockhash_l1();
  public:

  // string from = 13;
  void clear_from();
  const std::string& from() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_from(ArgT0&& arg0, ArgT... args);
  std::string* mutable_from();
  PROTOBUF_NODISCARD std::string* release_from();
  void set_allocated_from(std::string* from);
  private:
  const std::string& _internal_from() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_from(const std::string& value);
  std::string* _internal_mutable_from();
  public:

  // string context_id = 21;
  void clear_context_id();
  const std::string& context_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_context_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_context_id();
  PROTOBUF_NODISCARD std::string* release_context_id();
  void set_allocated_context_id(std::string* context_id);
  private:
  const std::string& _internal_context_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_context_id(const std::string& value);
  std::string* _internal_mutable_context_id();
  public:

  // .executor.v1.TraceConfigV2 trace_config = 20;
  bool has_trace_config() const;
  private:
  bool _internal_has_trace_config() const;
  public:
  void clear_trace_config();
  const ::executor::v1::TraceConfigV2& trace_config() const;
  PROTOBUF_NODISCARD ::executor::v1::TraceConfigV2* release_trace_config();
  ::executor::v1::TraceConfigV2* mutable_trace_config();
  void set_allocated_trace_config(::executor::v1::TraceConfigV2* trace_config);
  private:
  const ::executor::v1::TraceConfigV2& _internal_trace_config() const;
  ::executor::v1::TraceConfigV2* _internal_mutable_trace_config();
  public:
  void unsafe_arena_set_allocated_trace_config(
      ::executor::v1::TraceConfigV2* trace_config);
  ::executor::v1::TraceConfigV2* unsafe_arena_release_trace_config();

  // .executor.v1.DebugV2 debug = 24;
  bool has_debug() const;
  private:
  bool _internal_has_debug() const;
  public:
  void clear_debug();
  const ::executor::v1::DebugV2& debug() const;
  ::executor::v1::DebugV2* release_debug();
  ::executor::v1::DebugV2* mutable_debug();
  void set_allocated_debug(::executor::v1::DebugV2* debug);
  private:
  const ::executor::v1::DebugV2& _internal_debug() const;
  ::executor::v1::DebugV2* _internal_mutable_debug();
  public:
  void unsafe_arena_set_allocated_debug(
      ::executor::v1::DebugV2* debug);
  ::executor::v1::DebugV2* unsafe_arena_release_debug();

  // uint64 old_batch_num = 3;
  void clear_old_batch_num();
  uint64_t old_batch_num() const;
  void set_old_batch_num(uint64_t value);
  private:
  uint64_t _internal_old_batch_num() const;
  void _internal_set_old_batch_num(uint64_t value);
  public:

  // uint64 chain_id = 4;
  void clear_chain_id();
  uint64_t chain_id() const;
  void set_chain_id(uint64_t value);
  private:
  uint64_t _internal_chain_id() const;
  void _internal_set_chain_id(uint64_t value);
  public:

  // uint64 fork_id = 5;
  void clear_fork_id();
  uint64_t fork_id() const;
  void set_fork_id(uint64_t value);
  private:
  uint64_t _internal_fork_id() const;
  void _internal_set_fork_id(uint64_t value);
  public:

  // uint64 timestamp_limit = 8;
  void clear_timestamp_limit();
  uint64_t timestamp_limit() const;
  void set_timestamp_limit(uint64_t value);
  private:
  uint64_t _internal_timestamp_limit() const;
  void _internal_set_timestamp_limit(uint64_t value);
  public:

  // uint32 update_merkle_tree = 11;
  void clear_update_merkle_tree();
  uint32_t update_merkle_tree() const;
  void set_update_merkle_tree(uint32_t value);
  private:
  uint32_t _internal_update_merkle_tree() const;
  void _internal_set_update_merkle_tree(uint32_t value);
  public:

  // uint32 no_counters = 12;
  void clear_no_counters();
  uint32_t no_counters() const;
  void set_no_counters(uint32_t value);
  private:
  uint32_t _internal_no_counters() const;
  void _internal_set_no_counters(uint32_t value);
  public:

  // uint32 skip_verify_l1_info_root = 14;
  void clear_skip_verify_l1_info_root();
  uint32_t skip_verify_l1_info_root() const;
  void set_skip_verify_l1_info_root(uint32_t value);
  private:
  uint32_t _internal_skip_verify_l1_info_root() const;
  void _internal_set_skip_verify_l1_info_root(uint32_t value);
  public:

  // uint32 skip_first_change_l2_block = 15;
  void clear_skip_first_change_l2_block();
  uint32_t skip_first_change_l2_block() const;
  void set_skip_first_change_l2_block(uint32_t value);
  private:
  uint32_t _internal_skip_first_change_l2_block() const;
  void _internal_set_skip_first_change_l2_block(uint32_t value);
  public:

  // uint32 skip_write_block_info_root = 16;
  void clear_skip_write_block_info_root();
  ::PROTOBUF_NAMESPACE_ID::uint32 skip_write_block_info_root() const;
  void set_skip_write_block_info_root(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_skip_write_block_info_root() const;
  void _internal_set_skip_write_block_info_root(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 get_keys = 22;
  void clear_get_keys();
  uint32_t get_keys() const;
  void set_get_keys(uint32_t value);
  private:
  uint32_t _internal_get_keys() const;
  void _internal_set_get_keys(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:executor.v1.ProcessBatchRequestV2)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      ProcessBatchRequestV2_L1InfoTreeDataEntry_DoNotUse,
      ::PROTOBUF_NAMESPACE_ID::uint32, ::executor::v1::L1DataV2,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE,
      0 > l1_info_tree_data_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      ProcessBatchRequestV2_DbEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      0 > db_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      ProcessBatchRequestV2_ContractsBytecodeEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      0 > contracts_bytecode_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      ProcessBatchRequestV2_StateOverrideEntry_DoNotUse,
      std::string, ::executor::v1::OverrideAccountV2,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE,
      0 > state_override_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr old_state_root_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr old_acc_input_hash_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr batch_l2_data_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr l1_info_root_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr coinbase_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr forced_blockhash_l1_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr from_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr context_id_;
  ::executor::v1::TraceConfigV2* trace_config_;
  ::executor::v1::DebugV2* debug_;
  ::PROTOBUF_NAMESPACE_ID::uint64 old_batch_num_;
  ::PROTOBUF_NAMESPACE_ID::uint64 chain_id_;
  ::PROTOBUF_NAMESPACE_ID::uint64 fork_id_;
  ::PROTOBUF_NAMESPACE_ID::uint64 timestamp_limit_;
  ::PROTOBUF_NAMESPACE_ID::uint32 update_merkle_tree_;
  ::PROTOBUF_NAMESPACE_ID::uint32 no_counters_;
  ::PROTOBUF_NAMESPACE_ID::uint32 skip_verify_l1_info_root_;
  ::PROTOBUF_NAMESPACE_ID::uint32 skip_first_change_l2_block_;
  ::PROTOBUF_NAMESPACE_ID::uint32 skip_write_block_info_root_;
  ::PROTOBUF_NAMESPACE_ID::uint32 get_keys_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_executor_2eproto;
};
// -------------------------------------------------------------------

class L1DataV2 final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:executor.v1.L1DataV2) */ {
 public:
  inline L1DataV2() : L1DataV2(nullptr) {}
  ~L1DataV2() override;
  explicit PROTOBUF_CONSTEXPR L1DataV2(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  L1DataV2(const L1DataV2& from);
  L1DataV2(L1DataV2&& from) noexcept
    : L1DataV2() {
    *this = ::std::move(from);
  }

  inline L1DataV2& operator=(const L1DataV2& from) {
    CopyFrom(from);
    return *this;
  }
  inline L1DataV2& operator=(L1DataV2&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const L1DataV2& default_instance() {
    return *internal_default_instance();
  }
  static inline const L1DataV2* internal_default_instance() {
    return reinterpret_cast<const L1DataV2*>(
               &_L1DataV2_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(L1DataV2& a, L1DataV2& b) {
    a.Swap(&b);
  }
  inline void Swap(L1DataV2* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(L1DataV2* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  L1DataV2* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<L1DataV2>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const L1DataV2& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const L1DataV2& from) {
    L1DataV2::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(L1DataV2* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "executor.v1.L1DataV2";
  }
  protected:
  explicit L1DataV2(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSmtProofFieldNumber = 4,
    kGlobalExitRootFieldNumber = 1,
    kBlockHashL1FieldNumber = 2,
    kMinTimestampFieldNumber = 3,
  };
  // repeated bytes smt_proof = 4;
  int smt_proof_size() const;
  private:
  int _internal_smt_proof_size() const;
  public:
  void clear_smt_proof();
  const std::string& smt_proof(int index) const;
  std::string* mutable_smt_proof(int index);
  void set_smt_proof(int index, const std::string& value);
  void set_smt_proof(int index, std::string&& value);
  void set_smt_proof(int index, const char* value);
  void set_smt_proof(int index, const void* value, size_t size);
  std::string* add_smt_proof();
  void add_smt_proof(const std::string& value);
  void add_smt_proof(std::string&& value);
  void add_smt_proof(const char* value);
  void add_smt_proof(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& smt_proof() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_smt_proof();
  private:
  const std::string& _internal_smt_proof(int index) const;
  std::string* _internal_add_smt_proof();
  public:

  // bytes global_exit_root = 1;
  void clear_global_exit_root();
  const std::string& global_exit_root() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_global_exit_root(ArgT0&& arg0, ArgT... args);
  std::string* mutable_global_exit_root();
  PROTOBUF_NODISCARD std::string* release_global_exit_root();
  void set_allocated_global_exit_root(std::string* global_exit_root);
  private:
  const std::string& _internal_global_exit_root() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_global_exit_root(const std::string& value);
  std::string* _internal_mutable_global_exit_root();
  public:

  // bytes block_hash_l1 = 2;
  void clear_block_hash_l1();
  const std::string& block_hash_l1() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_block_hash_l1(ArgT0&& arg0, ArgT... args);
  std::string* mutable_block_hash_l1();
  PROTOBUF_NODISCARD std::string* release_block_hash_l1();
  void set_allocated_block_hash_l1(std::string* block_hash_l1);
  private:
  const std::string& _internal_block_hash_l1() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_block_hash_l1(const std::string& value);
  std::string* _internal_mutable_block_hash_l1();
  public:

  // uint64 min_timestamp = 3;
  void clear_min_timestamp();
  uint64_t min_timestamp() const;
  void set_min_timestamp(uint64_t value);
  private:
  uint64_t _internal_min_timestamp() const;
  void _internal_set_min_timestamp(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:executor.v1.L1DataV2)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> smt_proof_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr global_exit_root_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr block_hash_l1_;
    uint64_t min_timestamp_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_executor_2eproto;
};
// -------------------------------------------------------------------

class DebugV2 PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:executor.v1.DebugV2) */ {
 public:
  inline DebugV2() : DebugV2(nullptr) {};
  virtual ~DebugV2();

  DebugV2(const DebugV2& from);
  DebugV2(DebugV2&& from) noexcept
    : DebugV2() {
    *this = ::std::move(from);
  }

  inline DebugV2& operator=(const DebugV2& from) {
    CopyFrom(from);
    return *this;
  }
  inline DebugV2& operator=(DebugV2&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DebugV2& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DebugV2* internal_default_instance() {
    return reinterpret_cast<const DebugV2*>(
               &_DebugV2_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(DebugV2& a, DebugV2& b) {
    a.Swap(&b);
  }
  inline void Swap(DebugV2* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DebugV2* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DebugV2* New() const final {
    return CreateMaybeMessage<DebugV2>(nullptr);
  }

  DebugV2* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DebugV2>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DebugV2& from);
  void MergeFrom(const DebugV2& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DebugV2* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "executor.v1.DebugV2";
  }
  protected:
  explicit DebugV2(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_executor_2eproto);
    return ::descriptor_table_executor_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGasLimitFieldNumber = 1,
  };
  // uint64 gas_limit = 1;
  void clear_gas_limit();
  ::PROTOBUF_NAMESPACE_ID::uint64 gas_limit() const;
  void set_gas_limit(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_gas_limit() const;
  void _internal_set_gas_limit(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:executor.v1.DebugV2)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint64 gas_limit_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_executor_2eproto;
};
// -------------------------------------------------------------------

class ProcessBatchResponseV2_ReadWriteAddressesEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ProcessBatchResponseV2_ReadWriteAddressesEntry_DoNotUse, 
    std::string, ::executor::v1::InfoReadWriteV2,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ProcessBatchResponseV2_ReadWriteAddressesEntry_DoNotUse, 
    std::string, ::executor::v1::InfoReadWriteV2,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  ProcessBatchResponseV2_ReadWriteAddressesEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR ProcessBatchResponseV2_ReadWriteAddressesEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit ProcessBatchResponseV2_ReadWriteAddressesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const ProcessBatchResponseV2_ReadWriteAddressesEntry_DoNotUse& other);
  static const ProcessBatchResponseV2_ReadWriteAddressesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const ProcessBatchResponseV2_ReadWriteAddressesEntry_DoNotUse*>(&_ProcessBatchResponseV2_ReadWriteAddressesEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "executor.v1.ProcessBatchResponseV2.ReadWriteAddressesEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_executor_2eproto);
    return ::descriptor_table_executor_2eproto.file_level_metadata[26];
  }

  public:
};

// -------------------------------------------------------------------

class ProcessBatchResponseV2 final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:executor.v1.ProcessBatchResponseV2) */ {
 public:
  inline ProcessBatchResponseV2() : ProcessBatchResponseV2(nullptr) {}
  ~ProcessBatchResponseV2() override;
  explicit PROTOBUF_CONSTEXPR ProcessBatchResponseV2(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ProcessBatchResponseV2(const ProcessBatchResponseV2& from);
  ProcessBatchResponseV2(ProcessBatchResponseV2&& from) noexcept
    : ProcessBatchResponseV2() {
    *this = ::std::move(from);
  }

  inline ProcessBatchResponseV2& operator=(const ProcessBatchResponseV2& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProcessBatchResponseV2& operator=(ProcessBatchResponseV2&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ProcessBatchResponseV2& default_instance() {
    return *internal_default_instance();
  }
  static inline const ProcessBatchResponseV2* internal_default_instance() {
    return reinterpret_cast<const ProcessBatchResponseV2*>(
               &_ProcessBatchResponseV2_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(ProcessBatchResponseV2& a, ProcessBatchResponseV2& b) {
    a.Swap(&b);
  }
  inline void Swap(ProcessBatchResponseV2* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProcessBatchResponseV2* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ProcessBatchResponseV2* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ProcessBatchResponseV2>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ProcessBatchResponseV2& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ProcessBatchResponseV2& from) {
    ProcessBatchResponseV2::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProcessBatchResponseV2* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "executor.v1.ProcessBatchResponseV2";
  }
  protected:
  explicit ProcessBatchResponseV2(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kBlockResponsesFieldNumber = 13,
    kReadWriteAddressesFieldNumber = 15,
    kSmtKeysFieldNumber = 20,
    kProgramKeysFieldNumber = 21,
    kNewStateRootFieldNumber = 1,
    kNewAccInputHashFieldNumber = 2,
    kNewLocalExitRootFieldNumber = 3,
    kProverIdFieldNumber = 18,
    kNewBatchNumFieldNumber = 4,
    kCntKeccakHashesFieldNumber = 5,
    kCntPoseidonHashesFieldNumber = 6,
    kCntPoseidonPaddingsFieldNumber = 7,
    kCntMemAlignsFieldNumber = 8,
    kCntArithmeticsFieldNumber = 9,
    kCntBinariesFieldNumber = 10,
    kCntStepsFieldNumber = 11,
    kCntSha256HashesFieldNumber = 12,
    kFlushIdFieldNumber = 16,
    kStoredFlushIdFieldNumber = 17,
    kGasUsedFieldNumber = 19,
    kForkIdFieldNumber = 22,
    kErrorFieldNumber = 14,
  };
  // repeated .executor.v1.ProcessBlockResponseV2 block_responses = 13;
  int block_responses_size() const;
  private:
  int _internal_block_responses_size() const;
  public:
  void clear_block_responses();
  ::executor::v1::ProcessBlockResponseV2* mutable_block_responses(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::executor::v1::ProcessBlockResponseV2 >*
      mutable_block_responses();
  private:
  const ::executor::v1::ProcessBlockResponseV2& _internal_block_responses(int index) const;
  ::executor::v1::ProcessBlockResponseV2* _internal_add_block_responses();
  public:
  const ::executor::v1::ProcessBlockResponseV2& block_responses(int index) const;
  ::executor::v1::ProcessBlockResponseV2* add_block_responses();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::executor::v1::ProcessBlockResponseV2 >&
      block_responses() const;

  // map<string, .executor.v1.InfoReadWriteV2> read_write_addresses = 15;
  int read_write_addresses_size() const;
  private:
  int _internal_read_write_addresses_size() const;
  public:
  void clear_read_write_addresses();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::executor::v1::InfoReadWriteV2 >&
      _internal_read_write_addresses() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::executor::v1::InfoReadWriteV2 >*
      _internal_mutable_read_write_addresses();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::executor::v1::InfoReadWriteV2 >&
      read_write_addresses() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::executor::v1::InfoReadWriteV2 >*
      mutable_read_write_addresses();

  // repeated bytes smt_keys = 20;
  int smt_keys_size() const;
  private:
  int _internal_smt_keys_size() const;
  public:
  void clear_smt_keys();
  const std::string& smt_keys(int index) const;
  std::string* mutable_smt_keys(int index);
  void set_smt_keys(int index, const std::string& value);
  void set_smt_keys(int index, std::string&& value);
  void set_smt_keys(int index, const char* value);
  void set_smt_keys(int index, const void* value, size_t size);
  std::string* add_smt_keys();
  void add_smt_keys(const std::string& value);
  void add_smt_keys(std::string&& value);
  void add_smt_keys(const char* value);
  void add_smt_keys(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& smt_keys() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_smt_keys();
  private:
  const std::string& _internal_smt_keys(int index) const;
  std::string* _internal_add_smt_keys();
  public:

  // repeated bytes program_keys = 21;
  int program_keys_size() const;
  private:
  int _internal_program_keys_size() const;
  public:
  void clear_program_keys();
  const std::string& program_keys(int index) const;
  std::string* mutable_program_keys(int index);
  void set_program_keys(int index, const std::string& value);
  void set_program_keys(int index, std::string&& value);
  void set_program_keys(int index, const char* value);
  void set_program_keys(int index, const void* value, size_t size);
  std::string* add_program_keys();
  void add_program_keys(const std::string& value);
  void add_program_keys(std::string&& value);
  void add_program_keys(const char* value);
  void add_program_keys(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& program_keys() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_program_keys();
  private:
  const std::string& _internal_program_keys(int index) const;
  std::string* _internal_add_program_keys();
  public:

  // bytes new_state_root = 1;
  void clear_new_state_root();
  const std::string& new_state_root() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_new_state_root(ArgT0&& arg0, ArgT... args);
  std::string* mutable_new_state_root();
  PROTOBUF_NODISCARD std::string* release_new_state_root();
  void set_allocated_new_state_root(std::string* new_state_root);
  private:
  const std::string& _internal_new_state_root() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_new_state_root(const std::string& value);
  std::string* _internal_mutable_new_state_root();
  public:

  // bytes new_acc_input_hash = 2;
  void clear_new_acc_input_hash();
  const std::string& new_acc_input_hash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_new_acc_input_hash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_new_acc_input_hash();
  PROTOBUF_NODISCARD std::string* release_new_acc_input_hash();
  void set_allocated_new_acc_input_hash(std::string* new_acc_input_hash);
  private:
  const std::string& _internal_new_acc_input_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_new_acc_input_hash(const std::string& value);
  std::string* _internal_mutable_new_acc_input_hash();
  public:

  // bytes new_local_exit_root = 3;
  void clear_new_local_exit_root();
  const std::string& new_local_exit_root() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_new_local_exit_root(ArgT0&& arg0, ArgT... args);
  std::string* mutable_new_local_exit_root();
  PROTOBUF_NODISCARD std::string* release_new_local_exit_root();
  void set_allocated_new_local_exit_root(std::string* new_local_exit_root);
  private:
  const std::string& _internal_new_local_exit_root() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_new_local_exit_root(const std::string& value);
  std::string* _internal_mutable_new_local_exit_root();
  public:

  // string prover_id = 18;
  void clear_prover_id();
  const std::string& prover_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_prover_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_prover_id();
  PROTOBUF_NODISCARD std::string* release_prover_id();
  void set_allocated_prover_id(std::string* prover_id);
  private:
  const std::string& _internal_prover_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_prover_id(const std::string& value);
  std::string* _internal_mutable_prover_id();
  public:

  // uint64 new_batch_num = 4;
  void clear_new_batch_num();
  uint64_t new_batch_num() const;
  void set_new_batch_num(uint64_t value);
  private:
  uint64_t _internal_new_batch_num() const;
  void _internal_set_new_batch_num(uint64_t value);
  public:

  // uint32 cnt_keccak_hashes = 5;
  void clear_cnt_keccak_hashes();
  uint32_t cnt_keccak_hashes() const;
  void set_cnt_keccak_hashes(uint32_t value);
  private:
  uint32_t _internal_cnt_keccak_hashes() const;
  void _internal_set_cnt_keccak_hashes(uint32_t value);
  public:

  // uint32 cnt_poseidon_hashes = 6;
  void clear_cnt_poseidon_hashes();
  uint32_t cnt_poseidon_hashes() const;
  void set_cnt_poseidon_hashes(uint32_t value);
  private:
  uint32_t _internal_cnt_poseidon_hashes() const;
  void _internal_set_cnt_poseidon_hashes(uint32_t value);
  public:

  // uint32 cnt_poseidon_paddings = 7;
  void clear_cnt_poseidon_paddings();
  uint32_t cnt_poseidon_paddings() const;
  void set_cnt_poseidon_paddings(uint32_t value);
  private:
  uint32_t _internal_cnt_poseidon_paddings() const;
  void _internal_set_cnt_poseidon_paddings(uint32_t value);
  public:

  // uint32 cnt_mem_aligns = 8;
  void clear_cnt_mem_aligns();
  uint32_t cnt_mem_aligns() const;
  void set_cnt_mem_aligns(uint32_t value);
  private:
  uint32_t _internal_cnt_mem_aligns() const;
  void _internal_set_cnt_mem_aligns(uint32_t value);
  public:

  // uint32 cnt_arithmetics = 9;
  void clear_cnt_arithmetics();
  uint32_t cnt_arithmetics() const;
  void set_cnt_arithmetics(uint32_t value);
  private:
  uint32_t _internal_cnt_arithmetics() const;
  void _internal_set_cnt_arithmetics(uint32_t value);
  public:

  // uint32 cnt_binaries = 10;
  void clear_cnt_binaries();
  uint32_t cnt_binaries() const;
  void set_cnt_binaries(uint32_t value);
  private:
  uint32_t _internal_cnt_binaries() const;
  void _internal_set_cnt_binaries(uint32_t value);
  public:

  // uint32 cnt_steps = 11;
  void clear_cnt_steps();
  uint32_t cnt_steps() const;
  void set_cnt_steps(uint32_t value);
  private:
  uint32_t _internal_cnt_steps() const;
  void _internal_set_cnt_steps(uint32_t value);
  public:

  // uint32 cnt_sha256_hashes = 12;
  void clear_cnt_sha256_hashes();
  uint32_t cnt_sha256_hashes() const;
  void set_cnt_sha256_hashes(uint32_t value);
  private:
  uint32_t _internal_cnt_sha256_hashes() const;
  void _internal_set_cnt_sha256_hashes(uint32_t value);
  public:

  // uint64 flush_id = 16;
  void clear_flush_id();
  uint64_t flush_id() const;
  void set_flush_id(uint64_t value);
  private:
  uint64_t _internal_flush_id() const;
  void _internal_set_flush_id(uint64_t value);
  public:

  // uint64 stored_flush_id = 17;
  void clear_stored_flush_id();
  uint64_t stored_flush_id() const;
  void set_stored_flush_id(uint64_t value);
  private:
  uint64_t _internal_stored_flush_id() const;
  void _internal_set_stored_flush_id(uint64_t value);
  public:

  // uint64 gas_used = 19;
  void clear_gas_used();
  uint64_t gas_used() const;
  void set_gas_used(uint64_t value);
  private:
  uint64_t _internal_gas_used() const;
  void _internal_set_gas_used(uint64_t value);
  public:

  // uint64 fork_id = 22;
  void clear_fork_id();
  uint64_t fork_id() const;
  void set_fork_id(uint64_t value);
  private:
  uint64_t _internal_fork_id() const;
  void _internal_set_fork_id(uint64_t value);
  public:

  // .executor.v1.ExecutorError error = 14;
  void clear_error();
  ::executor::v1::ExecutorError error() const;
  void set_error(::executor::v1::ExecutorError value);
  private:
  ::executor::v1::ExecutorError _internal_error() const;
  void _internal_set_error(::executor::v1::ExecutorError value);
  public:

  // @@protoc_insertion_point(class_scope:executor.v1.ProcessBatchResponseV2)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::executor::v1::ProcessBlockResponseV2 > block_responses_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        ProcessBatchResponseV2_ReadWriteAddressesEntry_DoNotUse,
        std::string, ::executor::v1::InfoReadWriteV2,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> read_write_addresses_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> smt_keys_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> program_keys_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr new_state_root_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr new_acc_input_hash_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr new_local_exit_root_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr prover_id_;
    uint64_t new_batch_num_;
    uint32_t cnt_keccak_hashes_;
    uint32_t cnt_poseidon_hashes_;
    uint32_t cnt_poseidon_paddings_;
    uint32_t cnt_mem_aligns_;
    uint32_t cnt_arithmetics_;
    uint32_t cnt_binaries_;
    uint32_t cnt_steps_;
    uint32_t cnt_sha256_hashes_;
    uint64_t flush_id_;
    uint64_t stored_flush_id_;
    uint64_t gas_used_;
    uint64_t fork_id_;
    int error_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_executor_2eproto;
};
// -------------------------------------------------------------------

class TraceConfigV2 final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:executor.v1.TraceConfigV2) */ {
 public:
  inline TraceConfigV2() : TraceConfigV2(nullptr) {}
  ~TraceConfigV2() override;
  explicit PROTOBUF_CONSTEXPR TraceConfigV2(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TraceConfigV2(const TraceConfigV2& from);
  TraceConfigV2(TraceConfigV2&& from) noexcept
    : TraceConfigV2() {
    *this = ::std::move(from);
  }

  inline TraceConfigV2& operator=(const TraceConfigV2& from) {
    CopyFrom(from);
    return *this;
  }
  inline TraceConfigV2& operator=(TraceConfigV2&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TraceConfigV2& default_instance() {
    return *internal_default_instance();
  }
  static inline const TraceConfigV2* internal_default_instance() {
    return reinterpret_cast<const TraceConfigV2*>(
               &_TraceConfigV2_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(TraceConfigV2& a, TraceConfigV2& b) {
    a.Swap(&b);
  }
  inline void Swap(TraceConfigV2* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TraceConfigV2* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TraceConfigV2* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TraceConfigV2>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TraceConfigV2& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TraceConfigV2& from) {
    TraceConfigV2::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TraceConfigV2* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "executor.v1.TraceConfigV2";
  }
  protected:
  explicit TraceConfigV2(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTxHashToGenerateFullTraceFieldNumber = 5,
    kDisableStorageFieldNumber = 1,
    kDisableStackFieldNumber = 2,
    kEnableMemoryFieldNumber = 3,
    kEnableReturnDataFieldNumber = 4,
  };
  // bytes tx_hash_to_generate_full_trace = 5;
  void clear_tx_hash_to_generate_full_trace();
  const std::string& tx_hash_to_generate_full_trace() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tx_hash_to_generate_full_trace(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tx_hash_to_generate_full_trace();
  PROTOBUF_NODISCARD std::string* release_tx_hash_to_generate_full_trace();
  void set_allocated_tx_hash_to_generate_full_trace(std::string* tx_hash_to_generate_full_trace);
  private:
  const std::string& _internal_tx_hash_to_generate_full_trace() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tx_hash_to_generate_full_trace(const std::string& value);
  std::string* _internal_mutable_tx_hash_to_generate_full_trace();
  public:

  // uint32 disable_storage = 1;
  void clear_disable_storage();
  uint32_t disable_storage() const;
  void set_disable_storage(uint32_t value);
  private:
  uint32_t _internal_disable_storage() const;
  void _internal_set_disable_storage(uint32_t value);
  public:

  // uint32 disable_stack = 2;
  void clear_disable_stack();
  uint32_t disable_stack() const;
  void set_disable_stack(uint32_t value);
  private:
  uint32_t _internal_disable_stack() const;
  void _internal_set_disable_stack(uint32_t value);
  public:

  // uint32 enable_memory = 3;
  void clear_enable_memory();
  uint32_t enable_memory() const;
  void set_enable_memory(uint32_t value);
  private:
  uint32_t _internal_enable_memory() const;
  void _internal_set_enable_memory(uint32_t value);
  public:

  // uint32 enable_return_data = 4;
  void clear_enable_return_data();
  uint32_t enable_return_data() const;
  void set_enable_return_data(uint32_t value);
  private:
  uint32_t _internal_enable_return_data() const;
  void _internal_set_enable_return_data(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:executor.v1.TraceConfigV2)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tx_hash_to_generate_full_trace_;
    uint32_t disable_storage_;
    uint32_t disable_stack_;
    uint32_t enable_memory_;
    uint32_t enable_return_data_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_executor_2eproto;
};
// -------------------------------------------------------------------

class OverrideAccountV2_StateEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<OverrideAccountV2_StateEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<OverrideAccountV2_StateEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  OverrideAccountV2_StateEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR OverrideAccountV2_StateEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit OverrideAccountV2_StateEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const OverrideAccountV2_StateEntry_DoNotUse& other);
  static const OverrideAccountV2_StateEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const OverrideAccountV2_StateEntry_DoNotUse*>(&_OverrideAccountV2_StateEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "executor.v1.OverrideAccountV2.StateEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "executor.v1.OverrideAccountV2.StateEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_executor_2eproto);
    return ::descriptor_table_executor_2eproto.file_level_metadata[29];
  }

  public:
};

// -------------------------------------------------------------------

class OverrideAccountV2_StateDiffEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<OverrideAccountV2_StateDiffEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<OverrideAccountV2_StateDiffEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  OverrideAccountV2_StateDiffEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR OverrideAccountV2_StateDiffEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit OverrideAccountV2_StateDiffEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const OverrideAccountV2_StateDiffEntry_DoNotUse& other);
  static const OverrideAccountV2_StateDiffEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const OverrideAccountV2_StateDiffEntry_DoNotUse*>(&_OverrideAccountV2_StateDiffEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "executor.v1.OverrideAccountV2.StateDiffEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "executor.v1.OverrideAccountV2.StateDiffEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_executor_2eproto);
    return ::descriptor_table_executor_2eproto.file_level_metadata[30];
  }

  public:
};

// -------------------------------------------------------------------

class OverrideAccountV2 final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:executor.v1.OverrideAccountV2) */ {
 public:
  inline OverrideAccountV2() : OverrideAccountV2(nullptr) {}
  ~OverrideAccountV2() override;
  explicit PROTOBUF_CONSTEXPR OverrideAccountV2(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OverrideAccountV2(const OverrideAccountV2& from);
  OverrideAccountV2(OverrideAccountV2&& from) noexcept
    : OverrideAccountV2() {
    *this = ::std::move(from);
  }

  inline OverrideAccountV2& operator=(const OverrideAccountV2& from) {
    CopyFrom(from);
    return *this;
  }
  inline OverrideAccountV2& operator=(OverrideAccountV2&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OverrideAccountV2& default_instance() {
    return *internal_default_instance();
  }
  static inline const OverrideAccountV2* internal_default_instance() {
    return reinterpret_cast<const OverrideAccountV2*>(
               &_OverrideAccountV2_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(OverrideAccountV2& a, OverrideAccountV2& b) {
    a.Swap(&b);
  }
  inline void Swap(OverrideAccountV2* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OverrideAccountV2* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OverrideAccountV2* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OverrideAccountV2>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OverrideAccountV2& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OverrideAccountV2& from) {
    OverrideAccountV2::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OverrideAccountV2* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "executor.v1.OverrideAccountV2";
  }
  protected:
  explicit OverrideAccountV2(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kStateFieldNumber = 4,
    kStateDiffFieldNumber = 5,
    kBalanceFieldNumber = 1,
    kCodeFieldNumber = 3,
    kNonceFieldNumber = 2,
  };
  // map<string, string> state = 4;
  int state_size() const;
  private:
  int _internal_state_size() const;
  public:
  void clear_state();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_state() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_state();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      state() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_state();

  // map<string, string> state_diff = 5;
  int state_diff_size() const;
  private:
  int _internal_state_diff_size() const;
  public:
  void clear_state_diff();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_state_diff() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_state_diff();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      state_diff() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_state_diff();

  // bytes balance = 1;
  void clear_balance();
  const std::string& balance() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_balance(ArgT0&& arg0, ArgT... args);
  std::string* mutable_balance();
  PROTOBUF_NODISCARD std::string* release_balance();
  void set_allocated_balance(std::string* balance);
  private:
  const std::string& _internal_balance() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_balance(const std::string& value);
  std::string* _internal_mutable_balance();
  public:

  // bytes code = 3;
  void clear_code();
  const std::string& code() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_code(ArgT0&& arg0, ArgT... args);
  std::string* mutable_code();
  PROTOBUF_NODISCARD std::string* release_code();
  void set_allocated_code(std::string* code);
  private:
  const std::string& _internal_code() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_code(const std::string& value);
  std::string* _internal_mutable_code();
  public:

  // uint64 nonce = 2;
  void clear_nonce();
  uint64_t nonce() const;
  void set_nonce(uint64_t value);
  private:
  uint64_t _internal_nonce() const;
  void _internal_set_nonce(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:executor.v1.OverrideAccountV2)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        OverrideAccountV2_StateEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> state_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        OverrideAccountV2_StateDiffEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> state_diff_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr balance_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr code_;
    uint64_t nonce_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_executor_2eproto;
};
// -------------------------------------------------------------------

class InfoReadWriteV2 final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:executor.v1.InfoReadWriteV2) */ {
 public:
  inline InfoReadWriteV2() : InfoReadWriteV2(nullptr) {}
  ~InfoReadWriteV2() override;
  explicit PROTOBUF_CONSTEXPR InfoReadWriteV2(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InfoReadWriteV2(const InfoReadWriteV2& from);
  InfoReadWriteV2(InfoReadWriteV2&& from) noexcept
    : InfoReadWriteV2() {
    *this = ::std::move(from);
  }

  inline InfoReadWriteV2& operator=(const InfoReadWriteV2& from) {
    CopyFrom(from);
    return *this;
  }
  inline InfoReadWriteV2& operator=(InfoReadWriteV2&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InfoReadWriteV2& default_instance() {
    return *internal_default_instance();
  }
  static inline const InfoReadWriteV2* internal_default_instance() {
    return reinterpret_cast<const InfoReadWriteV2*>(
               &_InfoReadWriteV2_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(InfoReadWriteV2& a, InfoReadWriteV2& b) {
    a.Swap(&b);
  }
  inline void Swap(InfoReadWriteV2* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InfoReadWriteV2* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InfoReadWriteV2* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InfoReadWriteV2>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InfoReadWriteV2& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const InfoReadWriteV2& from) {
    InfoReadWriteV2::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InfoReadWriteV2* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "executor.v1.InfoReadWriteV2";
  }
  protected:
  explicit InfoReadWriteV2(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNonceFieldNumber = 1,
    kBalanceFieldNumber = 2,
  };
  // string nonce = 1;
  void clear_nonce();
  const std::string& nonce() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_nonce(ArgT0&& arg0, ArgT... args);
  std::string* mutable_nonce();
  PROTOBUF_NODISCARD std::string* release_nonce();
  void set_allocated_nonce(std::string* nonce);
  private:
  const std::string& _internal_nonce() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_nonce(const std::string& value);
  std::string* _internal_mutable_nonce();
  public:

  // string balance = 2;
  void clear_balance();
  const std::string& balance() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_balance(ArgT0&& arg0, ArgT... args);
  std::string* mutable_balance();
  PROTOBUF_NODISCARD std::string* release_balance();
  void set_allocated_balance(std::string* balance);
  private:
  const std::string& _internal_balance() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_balance(const std::string& value);
  std::string* _internal_mutable_balance();
  public:

  // @@protoc_insertion_point(class_scope:executor.v1.InfoReadWriteV2)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr nonce_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr balance_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_executor_2eproto;
};
// -------------------------------------------------------------------

class FullTraceV2 final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:executor.v1.FullTraceV2) */ {
 public:
  inline FullTraceV2() : FullTraceV2(nullptr) {}
  ~FullTraceV2() override;
  explicit PROTOBUF_CONSTEXPR FullTraceV2(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FullTraceV2(const FullTraceV2& from);
  FullTraceV2(FullTraceV2&& from) noexcept
    : FullTraceV2() {
    *this = ::std::move(from);
  }

  inline FullTraceV2& operator=(const FullTraceV2& from) {
    CopyFrom(from);
    return *this;
  }
  inline FullTraceV2& operator=(FullTraceV2&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FullTraceV2& default_instance() {
    return *internal_default_instance();
  }
  static inline const FullTraceV2* internal_default_instance() {
    return reinterpret_cast<const FullTraceV2*>(
               &_FullTraceV2_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(FullTraceV2& a, FullTraceV2& b) {
    a.Swap(&b);
  }
  inline void Swap(FullTraceV2* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FullTraceV2* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FullTraceV2* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FullTraceV2>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FullTraceV2& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FullTraceV2& from) {
    FullTraceV2::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FullTraceV2* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "executor.v1.FullTraceV2";
  }
  protected:
  explicit FullTraceV2(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStepsFieldNumber = 2,
    kContextFieldNumber = 1,
  };
  // repeated .executor.v1.TransactionStepV2 steps = 2;
  int steps_size() const;
  private:
  int _internal_steps_size() const;
  public:
  void clear_steps();
  ::executor::v1::TransactionStepV2* mutable_steps(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::executor::v1::TransactionStepV2 >*
      mutable_steps();
  private:
  const ::executor::v1::TransactionStepV2& _internal_steps(int index) const;
  ::executor::v1::TransactionStepV2* _internal_add_steps();
  public:
  const ::executor::v1::TransactionStepV2& steps(int index) const;
  ::executor::v1::TransactionStepV2* add_steps();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::executor::v1::TransactionStepV2 >&
      steps() const;

  // .executor.v1.TransactionContextV2 context = 1;
  bool has_context() const;
  private:
  bool _internal_has_context() const;
  public:
  void clear_context();
  const ::executor::v1::TransactionContextV2& context() const;
  PROTOBUF_NODISCARD ::executor::v1::TransactionContextV2* release_context();
  ::executor::v1::TransactionContextV2* mutable_context();
  void set_allocated_context(::executor::v1::TransactionContextV2* context);
  private:
  const ::executor::v1::TransactionContextV2& _internal_context() const;
  ::executor::v1::TransactionContextV2* _internal_mutable_context();
  public:
  void unsafe_arena_set_allocated_context(
      ::executor::v1::TransactionContextV2* context);
  ::executor::v1::TransactionContextV2* unsafe_arena_release_context();

  // @@protoc_insertion_point(class_scope:executor.v1.FullTraceV2)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::executor::v1::TransactionStepV2 > steps_;
    ::executor::v1::TransactionContextV2* context_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_executor_2eproto;
};
// -------------------------------------------------------------------

class TransactionContextV2 final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:executor.v1.TransactionContextV2) */ {
 public:
  inline TransactionContextV2() : TransactionContextV2(nullptr) {}
  ~TransactionContextV2() override;
  explicit PROTOBUF_CONSTEXPR TransactionContextV2(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TransactionContextV2(const TransactionContextV2& from);
  TransactionContextV2(TransactionContextV2&& from) noexcept
    : TransactionContextV2() {
    *this = ::std::move(from);
  }

  inline TransactionContextV2& operator=(const TransactionContextV2& from) {
    CopyFrom(from);
    return *this;
  }
  inline TransactionContextV2& operator=(TransactionContextV2&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TransactionContextV2& default_instance() {
    return *internal_default_instance();
  }
  static inline const TransactionContextV2* internal_default_instance() {
    return reinterpret_cast<const TransactionContextV2*>(
               &_TransactionContextV2_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(TransactionContextV2& a, TransactionContextV2& b) {
    a.Swap(&b);
  }
  inline void Swap(TransactionContextV2* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TransactionContextV2* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TransactionContextV2* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TransactionContextV2>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TransactionContextV2& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TransactionContextV2& from) {
    TransactionContextV2::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TransactionContextV2* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "executor.v1.TransactionContextV2";
  }
  protected:
  explicit TransactionContextV2(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
    kFromFieldNumber = 2,
    kToFieldNumber = 3,
    kDataFieldNumber = 4,
    kValueFieldNumber = 6,
    kBlockHashFieldNumber = 7,
    kOutputFieldNumber = 8,
    kGasPriceFieldNumber = 10,
    kOldStateRootFieldNumber = 12,
    kGasFieldNumber = 5,
    kGasUsedFieldNumber = 9,
    kNonceFieldNumber = 13,
    kTxIndexFieldNumber = 14,
    kChainIdFieldNumber = 15,
    kExecutionTimeFieldNumber = 11,
  };
  // string type = 1;
  void clear_type();
  const std::string& type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_type();
  PROTOBUF_NODISCARD std::string* release_type();
  void set_allocated_type(std::string* type);
  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(const std::string& value);
  std::string* _internal_mutable_type();
  public:

  // string from = 2;
  void clear_from();
  const std::string& from() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_from(ArgT0&& arg0, ArgT... args);
  std::string* mutable_from();
  PROTOBUF_NODISCARD std::string* release_from();
  void set_allocated_from(std::string* from);
  private:
  const std::string& _internal_from() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_from(const std::string& value);
  std::string* _internal_mutable_from();
  public:

  // string to = 3;
  void clear_to();
  const std::string& to() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_to(ArgT0&& arg0, ArgT... args);
  std::string* mutable_to();
  PROTOBUF_NODISCARD std::string* release_to();
  void set_allocated_to(std::string* to);
  private:
  const std::string& _internal_to() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_to(const std::string& value);
  std::string* _internal_mutable_to();
  public:

  // bytes data = 4;
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // string value = 6;
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // bytes block_hash = 7;
  void clear_block_hash();
  const std::string& block_hash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_block_hash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_block_hash();
  PROTOBUF_NODISCARD std::string* release_block_hash();
  void set_allocated_block_hash(std::string* block_hash);
  private:
  const std::string& _internal_block_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_block_hash(const std::string& value);
  std::string* _internal_mutable_block_hash();
  public:

  // bytes output = 8;
  void clear_output();
  const std::string& output() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_output(ArgT0&& arg0, ArgT... args);
  std::string* mutable_output();
  PROTOBUF_NODISCARD std::string* release_output();
  void set_allocated_output(std::string* output);
  private:
  const std::string& _internal_output() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_output(const std::string& value);
  std::string* _internal_mutable_output();
  public:

  // string gas_price = 10;
  void clear_gas_price();
  const std::string& gas_price() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_gas_price(ArgT0&& arg0, ArgT... args);
  std::string* mutable_gas_price();
  PROTOBUF_NODISCARD std::string* release_gas_price();
  void set_allocated_gas_price(std::string* gas_price);
  private:
  const std::string& _internal_gas_price() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_gas_price(const std::string& value);
  std::string* _internal_mutable_gas_price();
  public:

  // bytes old_state_root = 12;
  void clear_old_state_root();
  const std::string& old_state_root() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_old_state_root(ArgT0&& arg0, ArgT... args);
  std::string* mutable_old_state_root();
  PROTOBUF_NODISCARD std::string* release_old_state_root();
  void set_allocated_old_state_root(std::string* old_state_root);
  private:
  const std::string& _internal_old_state_root() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_old_state_root(const std::string& value);
  std::string* _internal_mutable_old_state_root();
  public:

  // uint64 gas = 5;
  void clear_gas();
  uint64_t gas() const;
  void set_gas(uint64_t value);
  private:
  uint64_t _internal_gas() const;
  void _internal_set_gas(uint64_t value);
  public:

  // uint64 gas_used = 9;
  void clear_gas_used();
  uint64_t gas_used() const;
  void set_gas_used(uint64_t value);
  private:
  uint64_t _internal_gas_used() const;
  void _internal_set_gas_used(uint64_t value);
  public:

  // uint64 nonce = 13;
  void clear_nonce();
  uint64_t nonce() const;
  void set_nonce(uint64_t value);
  private:
  uint64_t _internal_nonce() const;
  void _internal_set_nonce(uint64_t value);
  public:

  // uint64 tx_index = 14;
  void clear_tx_index();
  uint64_t tx_index() const;
  void set_tx_index(uint64_t value);
  private:
  uint64_t _internal_tx_index() const;
  void _internal_set_tx_index(uint64_t value);
  public:

  // uint64 chain_id = 15;
  void clear_chain_id();
  uint64_t chain_id() const;
  void set_chain_id(uint64_t value);
  private:
  uint64_t _internal_chain_id() const;
  void _internal_set_chain_id(uint64_t value);
  public:

  // uint32 execution_time = 11;
  void clear_execution_time();
  uint32_t execution_time() const;
  void set_execution_time(uint32_t value);
  private:
  uint32_t _internal_execution_time() const;
  void _internal_set_execution_time(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:executor.v1.TransactionContextV2)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr from_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr to_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr block_hash_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr output_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr gas_price_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr old_state_root_;
    uint64_t gas_;
    uint64_t gas_used_;
    uint64_t nonce_;
    uint64_t tx_index_;
    uint64_t chain_id_;
    uint32_t execution_time_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_executor_2eproto;
};
// -------------------------------------------------------------------

class TransactionStepV2_StorageEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<TransactionStepV2_StorageEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<TransactionStepV2_StorageEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  TransactionStepV2_StorageEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR TransactionStepV2_StorageEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit TransactionStepV2_StorageEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const TransactionStepV2_StorageEntry_DoNotUse& other);
  static const TransactionStepV2_StorageEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const TransactionStepV2_StorageEntry_DoNotUse*>(&_TransactionStepV2_StorageEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "executor.v1.TransactionStepV2.StorageEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "executor.v1.TransactionStepV2.StorageEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_executor_2eproto);
    return ::descriptor_table_executor_2eproto.file_level_metadata[35];
  }

  public:
};

// -------------------------------------------------------------------

class TransactionStepV2 final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:executor.v1.TransactionStepV2) */ {
 public:
  inline TransactionStepV2() : TransactionStepV2(nullptr) {}
  ~TransactionStepV2() override;
  explicit PROTOBUF_CONSTEXPR TransactionStepV2(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TransactionStepV2(const TransactionStepV2& from);
  TransactionStepV2(TransactionStepV2&& from) noexcept
    : TransactionStepV2() {
    *this = ::std::move(from);
  }

  inline TransactionStepV2& operator=(const TransactionStepV2& from) {
    CopyFrom(from);
    return *this;
  }
  inline TransactionStepV2& operator=(TransactionStepV2&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TransactionStepV2& default_instance() {
    return *internal_default_instance();
  }
  static inline const TransactionStepV2* internal_default_instance() {
    return reinterpret_cast<const TransactionStepV2*>(
               &_TransactionStepV2_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(TransactionStepV2& a, TransactionStepV2& b) {
    a.Swap(&b);
  }
  inline void Swap(TransactionStepV2* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TransactionStepV2* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TransactionStepV2* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TransactionStepV2>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TransactionStepV2& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TransactionStepV2& from) {
    TransactionStepV2::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TransactionStepV2* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "executor.v1.TransactionStepV2";
  }
  protected:
  explicit TransactionStepV2(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kStackFieldNumber = 8,
    kStorageFieldNumber = 15,
    kStateRootFieldNumber = 1,
    kMemoryFieldNumber = 9,
    kReturnDataFieldNumber = 12,
    kContractFieldNumber = 13,
    kPcFieldNumber = 3,
    kGasFieldNumber = 4,
    kDepthFieldNumber = 2,
    kOpFieldNumber = 7,
    kGasCostFieldNumber = 5,
    kGasRefundFieldNumber = 6,
    kMemorySizeFieldNumber = 10,
    kMemoryOffsetFieldNumber = 11,
    kErrorFieldNumber = 14,
  };
  // repeated string stack = 8;
  int stack_size() const;
  private:
  int _internal_stack_size() const;
  public:
  void clear_stack();
  const std::string& stack(int index) const;
  std::string* mutable_stack(int index);
  void set_stack(int index, const std::string& value);
  void set_stack(int index, std::string&& value);
  void set_stack(int index, const char* value);
  void set_stack(int index, const char* value, size_t size);
  std::string* add_stack();
  void add_stack(const std::string& value);
  void add_stack(std::string&& value);
  void add_stack(const char* value);
  void add_stack(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& stack() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_stack();
  private:
  const std::string& _internal_stack(int index) const;
  std::string* _internal_add_stack();
  public:

  // map<string, string> storage = 15;
  int storage_size() const;
  private:
  int _internal_storage_size() const;
  public:
  void clear_storage();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_storage() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_storage();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      storage() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_storage();

  // bytes state_root = 1;
  void clear_state_root();
  const std::string& state_root() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_state_root(ArgT0&& arg0, ArgT... args);
  std::string* mutable_state_root();
  PROTOBUF_NODISCARD std::string* release_state_root();
  void set_allocated_state_root(std::string* state_root);
  private:
  const std::string& _internal_state_root() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_state_root(const std::string& value);
  std::string* _internal_mutable_state_root();
  public:

  // bytes memory = 9;
  void clear_memory();
  const std::string& memory() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_memory(ArgT0&& arg0, ArgT... args);
  std::string* mutable_memory();
  PROTOBUF_NODISCARD std::string* release_memory();
  void set_allocated_memory(std::string* memory);
  private:
  const std::string& _internal_memory() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_memory(const std::string& value);
  std::string* _internal_mutable_memory();
  public:

  // bytes return_data = 12;
  void clear_return_data();
  const std::string& return_data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_return_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_return_data();
  PROTOBUF_NODISCARD std::string* release_return_data();
  void set_allocated_return_data(std::string* return_data);
  private:
  const std::string& _internal_return_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_return_data(const std::string& value);
  std::string* _internal_mutable_return_data();
  public:

  // .executor.v1.ContractV2 contract = 13;
  bool has_contract() const;
  private:
  bool _internal_has_contract() const;
  public:
  void clear_contract();
  const ::executor::v1::ContractV2& contract() const;
  PROTOBUF_NODISCARD ::executor::v1::ContractV2* release_contract();
  ::executor::v1::ContractV2* mutable_contract();
  void set_allocated_contract(::executor::v1::ContractV2* contract);
  private:
  const ::executor::v1::ContractV2& _internal_contract() const;
  ::executor::v1::ContractV2* _internal_mutable_contract();
  public:
  void unsafe_arena_set_allocated_contract(
      ::executor::v1::ContractV2* contract);
  ::executor::v1::ContractV2* unsafe_arena_release_contract();

  // uint64 pc = 3;
  void clear_pc();
  uint64_t pc() const;
  void set_pc(uint64_t value);
  private:
  uint64_t _internal_pc() const;
  void _internal_set_pc(uint64_t value);
  public:

  // uint64 gas = 4;
  void clear_gas();
  uint64_t gas() const;
  void set_gas(uint64_t value);
  private:
  uint64_t _internal_gas() const;
  void _internal_set_gas(uint64_t value);
  public:

  // uint32 depth = 2;
  void clear_depth();
  uint32_t depth() const;
  void set_depth(uint32_t value);
  private:
  uint32_t _internal_depth() const;
  void _internal_set_depth(uint32_t value);
  public:

  // uint32 op = 7;
  void clear_op();
  uint32_t op() const;
  void set_op(uint32_t value);
  private:
  uint32_t _internal_op() const;
  void _internal_set_op(uint32_t value);
  public:

  // uint64 gas_cost = 5;
  void clear_gas_cost();
  uint64_t gas_cost() const;
  void set_gas_cost(uint64_t value);
  private:
  uint64_t _internal_gas_cost() const;
  void _internal_set_gas_cost(uint64_t value);
  public:

  // uint64 gas_refund = 6;
  void clear_gas_refund();
  uint64_t gas_refund() const;
  void set_gas_refund(uint64_t value);
  private:
  uint64_t _internal_gas_refund() const;
  void _internal_set_gas_refund(uint64_t value);
  public:

  // uint32 memory_size = 10;
  void clear_memory_size();
  uint32_t memory_size() const;
  void set_memory_size(uint32_t value);
  private:
  uint32_t _internal_memory_size() const;
  void _internal_set_memory_size(uint32_t value);
  public:

  // uint32 memory_offset = 11;
  void clear_memory_offset();
  uint32_t memory_offset() const;
  void set_memory_offset(uint32_t value);
  private:
  uint32_t _internal_memory_offset() const;
  void _internal_set_memory_offset(uint32_t value);
  public:

  // .executor.v1.RomError error = 14;
  void clear_error();
  ::executor::v1::RomError error() const;
  void set_error(::executor::v1::RomError value);
  private:
  ::executor::v1::RomError _internal_error() const;
  void _internal_set_error(::executor::v1::RomError value);
  public:

  // @@protoc_insertion_point(class_scope:executor.v1.TransactionStepV2)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> stack_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        TransactionStepV2_StorageEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> storage_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr state_root_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr memory_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr return_data_;
    ::executor::v1::ContractV2* contract_;
    uint64_t pc_;
    uint64_t gas_;
    uint32_t depth_;
    uint32_t op_;
    uint64_t gas_cost_;
    uint64_t gas_refund_;
    uint32_t memory_size_;
    uint32_t memory_offset_;
    int error_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_executor_2eproto;
};
// -------------------------------------------------------------------

class ContractV2 final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:executor.v1.ContractV2) */ {
 public:
  inline ContractV2() : ContractV2(nullptr) {}
  ~ContractV2() override;
  explicit PROTOBUF_CONSTEXPR ContractV2(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ContractV2(const ContractV2& from);
  ContractV2(ContractV2&& from) noexcept
    : ContractV2() {
    *this = ::std::move(from);
  }

  inline ContractV2& operator=(const ContractV2& from) {
    CopyFrom(from);
    return *this;
  }
  inline ContractV2& operator=(ContractV2&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ContractV2& default_instance() {
    return *internal_default_instance();
  }
  static inline const ContractV2* internal_default_instance() {
    return reinterpret_cast<const ContractV2*>(
               &_ContractV2_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  friend void swap(ContractV2& a, ContractV2& b) {
    a.Swap(&b);
  }
  inline void Swap(ContractV2* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ContractV2* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ContractV2* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ContractV2>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ContractV2& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ContractV2& from) {
    ContractV2::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ContractV2* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "executor.v1.ContractV2";
  }
  protected:
  explicit ContractV2(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddressFieldNumber = 1,
    kCallerFieldNumber = 2,
    kValueFieldNumber = 3,
    kDataFieldNumber = 4,
    kTypeFieldNumber = 6,
    kGasFieldNumber = 5,
  };
  // string address = 1;
  void clear_address();
  const std::string& address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_address();
  PROTOBUF_NODISCARD std::string* release_address();
  void set_allocated_address(std::string* address);
  private:
  const std::string& _internal_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_address(const std::string& value);
  std::string* _internal_mutable_address();
  public:

  // string caller = 2;
  void clear_caller();
  const std::string& caller() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_caller(ArgT0&& arg0, ArgT... args);
  std::string* mutable_caller();
  PROTOBUF_NODISCARD std::string* release_caller();
  void set_allocated_caller(std::string* caller);
  private:
  const std::string& _internal_caller() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_caller(const std::string& value);
  std::string* _internal_mutable_caller();
  public:

  // string value = 3;
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // bytes data = 4;
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // string type = 6;
  void clear_type();
  const std::string& type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_type();
  PROTOBUF_NODISCARD std::string* release_type();
  void set_allocated_type(std::string* type);
  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(const std::string& value);
  std::string* _internal_mutable_type();
  public:

  // uint64 gas = 5;
  void clear_gas();
  uint64_t gas() const;
  void set_gas(uint64_t value);
  private:
  uint64_t _internal_gas() const;
  void _internal_set_gas(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:executor.v1.ContractV2)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr address_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr caller_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
    uint64_t gas_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_executor_2eproto;
};
// -------------------------------------------------------------------

class ProcessBlockResponseV2 final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:executor.v1.ProcessBlockResponseV2) */ {
 public:
  inline ProcessBlockResponseV2() : ProcessBlockResponseV2(nullptr) {}
  ~ProcessBlockResponseV2() override;
  explicit PROTOBUF_CONSTEXPR ProcessBlockResponseV2(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ProcessBlockResponseV2(const ProcessBlockResponseV2& from);
  ProcessBlockResponseV2(ProcessBlockResponseV2&& from) noexcept
    : ProcessBlockResponseV2() {
    *this = ::std::move(from);
  }

  inline ProcessBlockResponseV2& operator=(const ProcessBlockResponseV2& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProcessBlockResponseV2& operator=(ProcessBlockResponseV2&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ProcessBlockResponseV2& default_instance() {
    return *internal_default_instance();
  }
  static inline const ProcessBlockResponseV2* internal_default_instance() {
    return reinterpret_cast<const ProcessBlockResponseV2*>(
               &_ProcessBlockResponseV2_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  friend void swap(ProcessBlockResponseV2& a, ProcessBlockResponseV2& b) {
    a.Swap(&b);
  }
  inline void Swap(ProcessBlockResponseV2* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProcessBlockResponseV2* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ProcessBlockResponseV2* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ProcessBlockResponseV2>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ProcessBlockResponseV2& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ProcessBlockResponseV2& from) {
    ProcessBlockResponseV2::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProcessBlockResponseV2* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "executor.v1.ProcessBlockResponseV2";
  }
  protected:
  explicit ProcessBlockResponseV2(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResponsesFieldNumber = 11,
    kLogsFieldNumber = 12,
    kParentHashFieldNumber = 1,
    kCoinbaseFieldNumber = 2,
    kGerFieldNumber = 6,
    kBlockHashL1FieldNumber = 7,
    kBlockInfoRootFieldNumber = 9,
    kBlockHashFieldNumber = 10,
    kGasLimitFieldNumber = 3,
    kBlockNumberFieldNumber = 4,
    kTimestampFieldNumber = 5,
    kGasUsedFieldNumber = 8,
  };
  // repeated .executor.v1.ProcessTransactionResponseV2 responses = 11;
  int responses_size() const;
  private:
  int _internal_responses_size() const;
  public:
  void clear_responses();
  ::executor::v1::ProcessTransactionResponseV2* mutable_responses(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::executor::v1::ProcessTransactionResponseV2 >*
      mutable_responses();
  private:
  const ::executor::v1::ProcessTransactionResponseV2& _internal_responses(int index) const;
  ::executor::v1::ProcessTransactionResponseV2* _internal_add_responses();
  public:
  const ::executor::v1::ProcessTransactionResponseV2& responses(int index) const;
  ::executor::v1::ProcessTransactionResponseV2* add_responses();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::executor::v1::ProcessTransactionResponseV2 >&
      responses() const;

  // repeated .executor.v1.LogV2 logs = 12;
  int logs_size() const;
  private:
  int _internal_logs_size() const;
  public:
  void clear_logs();
  ::executor::v1::LogV2* mutable_logs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::executor::v1::LogV2 >*
      mutable_logs();
  private:
  const ::executor::v1::LogV2& _internal_logs(int index) const;
  ::executor::v1::LogV2* _internal_add_logs();
  public:
  const ::executor::v1::LogV2& logs(int index) const;
  ::executor::v1::LogV2* add_logs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::executor::v1::LogV2 >&
      logs() const;

  // bytes parent_hash = 1;
  void clear_parent_hash();
  const std::string& parent_hash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_parent_hash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_parent_hash();
  PROTOBUF_NODISCARD std::string* release_parent_hash();
  void set_allocated_parent_hash(std::string* parent_hash);
  private:
  const std::string& _internal_parent_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_parent_hash(const std::string& value);
  std::string* _internal_mutable_parent_hash();
  public:

  // string coinbase = 2;
  void clear_coinbase();
  const std::string& coinbase() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_coinbase(ArgT0&& arg0, ArgT... args);
  std::string* mutable_coinbase();
  PROTOBUF_NODISCARD std::string* release_coinbase();
  void set_allocated_coinbase(std::string* coinbase);
  private:
  const std::string& _internal_coinbase() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_coinbase(const std::string& value);
  std::string* _internal_mutable_coinbase();
  public:

  // bytes ger = 6;
  void clear_ger();
  const std::string& ger() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ger(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ger();
  PROTOBUF_NODISCARD std::string* release_ger();
  void set_allocated_ger(std::string* ger);
  private:
  const std::string& _internal_ger() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ger(const std::string& value);
  std::string* _internal_mutable_ger();
  public:

  // bytes block_hash_l1 = 7;
  void clear_block_hash_l1();
  const std::string& block_hash_l1() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_block_hash_l1(ArgT0&& arg0, ArgT... args);
  std::string* mutable_block_hash_l1();
  PROTOBUF_NODISCARD std::string* release_block_hash_l1();
  void set_allocated_block_hash_l1(std::string* block_hash_l1);
  private:
  const std::string& _internal_block_hash_l1() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_block_hash_l1(const std::string& value);
  std::string* _internal_mutable_block_hash_l1();
  public:

  // bytes block_info_root = 9;
  void clear_block_info_root();
  const std::string& block_info_root() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_block_info_root(ArgT0&& arg0, ArgT... args);
  std::string* mutable_block_info_root();
  PROTOBUF_NODISCARD std::string* release_block_info_root();
  void set_allocated_block_info_root(std::string* block_info_root);
  private:
  const std::string& _internal_block_info_root() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_block_info_root(const std::string& value);
  std::string* _internal_mutable_block_info_root();
  public:

  // bytes block_hash = 10;
  void clear_block_hash();
  const std::string& block_hash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_block_hash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_block_hash();
  PROTOBUF_NODISCARD std::string* release_block_hash();
  void set_allocated_block_hash(std::string* block_hash);
  private:
  const std::string& _internal_block_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_block_hash(const std::string& value);
  std::string* _internal_mutable_block_hash();
  public:

  // uint64 gas_limit = 3;
  void clear_gas_limit();
  uint64_t gas_limit() const;
  void set_gas_limit(uint64_t value);
  private:
  uint64_t _internal_gas_limit() const;
  void _internal_set_gas_limit(uint64_t value);
  public:

  // uint64 block_number = 4;
  void clear_block_number();
  uint64_t block_number() const;
  void set_block_number(uint64_t value);
  private:
  uint64_t _internal_block_number() const;
  void _internal_set_block_number(uint64_t value);
  public:

  // uint64 timestamp = 5;
  void clear_timestamp();
  uint64_t timestamp() const;
  void set_timestamp(uint64_t value);
  private:
  uint64_t _internal_timestamp() const;
  void _internal_set_timestamp(uint64_t value);
  public:

  // uint64 gas_used = 8;
  void clear_gas_used();
  uint64_t gas_used() const;
  void set_gas_used(uint64_t value);
  private:
  uint64_t _internal_gas_used() const;
  void _internal_set_gas_used(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:executor.v1.ProcessBlockResponseV2)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::executor::v1::ProcessTransactionResponseV2 > responses_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::executor::v1::LogV2 > logs_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr parent_hash_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr coinbase_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ger_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr block_hash_l1_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr block_info_root_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr block_hash_;
    uint64_t gas_limit_;
    uint64_t block_number_;
    uint64_t timestamp_;
    uint64_t gas_used_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_executor_2eproto;
};
// -------------------------------------------------------------------

class ProcessTransactionResponseV2 final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:executor.v1.ProcessTransactionResponseV2) */ {
 public:
  inline ProcessTransactionResponseV2() : ProcessTransactionResponseV2(nullptr) {}
  ~ProcessTransactionResponseV2() override;
  explicit PROTOBUF_CONSTEXPR ProcessTransactionResponseV2(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ProcessTransactionResponseV2(const ProcessTransactionResponseV2& from);
  ProcessTransactionResponseV2(ProcessTransactionResponseV2&& from) noexcept
    : ProcessTransactionResponseV2() {
    *this = ::std::move(from);
  }

  inline ProcessTransactionResponseV2& operator=(const ProcessTransactionResponseV2& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProcessTransactionResponseV2& operator=(ProcessTransactionResponseV2&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ProcessTransactionResponseV2& default_instance() {
    return *internal_default_instance();
  }
  static inline const ProcessTransactionResponseV2* internal_default_instance() {
    return reinterpret_cast<const ProcessTransactionResponseV2*>(
               &_ProcessTransactionResponseV2_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  friend void swap(ProcessTransactionResponseV2& a, ProcessTransactionResponseV2& b) {
    a.Swap(&b);
  }
  inline void Swap(ProcessTransactionResponseV2* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProcessTransactionResponseV2* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ProcessTransactionResponseV2* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ProcessTransactionResponseV2>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ProcessTransactionResponseV2& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ProcessTransactionResponseV2& from) {
    ProcessTransactionResponseV2::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProcessTransactionResponseV2* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "executor.v1.ProcessTransactionResponseV2";
  }
  protected:
  explicit ProcessTransactionResponseV2(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLogsFieldNumber = 15,
    kTxHashFieldNumber = 1,
    kTxHashL2FieldNumber = 2,
    kRlpTxFieldNumber = 3,
    kBlockHashFieldNumber = 4,
    kReturnValueFieldNumber = 7,
    kCreateAddressFieldNumber = 13,
    kStateRootFieldNumber = 14,
    kEffectiveGasPriceFieldNumber = 17,
    kFullTraceFieldNumber = 16,
    kBlockNumberFieldNumber = 5,
    kGasLeftFieldNumber = 8,
    kGasUsedFieldNumber = 9,
    kTypeFieldNumber = 6,
    kErrorFieldNumber = 12,
    kCumulativeGasUsedFieldNumber = 10,
    kGasRefundedFieldNumber = 11,
    kEffectivePercentageFieldNumber = 18,
    kHasGaspriceOpcodeFieldNumber = 19,
    kHasBalanceOpcodeFieldNumber = 20,
  };
  // repeated .executor.v1.LogV2 logs = 15;
  int logs_size() const;
  private:
  int _internal_logs_size() const;
  public:
  void clear_logs();
  ::executor::v1::LogV2* mutable_logs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::executor::v1::LogV2 >*
      mutable_logs();
  private:
  const ::executor::v1::LogV2& _internal_logs(int index) const;
  ::executor::v1::LogV2* _internal_add_logs();
  public:
  const ::executor::v1::LogV2& logs(int index) const;
  ::executor::v1::LogV2* add_logs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::executor::v1::LogV2 >&
      logs() const;

  // bytes tx_hash = 1;
  void clear_tx_hash();
  const std::string& tx_hash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tx_hash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tx_hash();
  PROTOBUF_NODISCARD std::string* release_tx_hash();
  void set_allocated_tx_hash(std::string* tx_hash);
  private:
  const std::string& _internal_tx_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tx_hash(const std::string& value);
  std::string* _internal_mutable_tx_hash();
  public:

  // bytes tx_hash_l2 = 2;
  void clear_tx_hash_l2();
  const std::string& tx_hash_l2() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tx_hash_l2(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tx_hash_l2();
  PROTOBUF_NODISCARD std::string* release_tx_hash_l2();
  void set_allocated_tx_hash_l2(std::string* tx_hash_l2);
  private:
  const std::string& _internal_tx_hash_l2() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tx_hash_l2(const std::string& value);
  std::string* _internal_mutable_tx_hash_l2();
  public:

  // bytes rlp_tx = 3;
  void clear_rlp_tx();
  const std::string& rlp_tx() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_rlp_tx(ArgT0&& arg0, ArgT... args);
  std::string* mutable_rlp_tx();
  PROTOBUF_NODISCARD std::string* release_rlp_tx();
  void set_allocated_rlp_tx(std::string* rlp_tx);
  private:
  const std::string& _internal_rlp_tx() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_rlp_tx(const std::string& value);
  std::string* _internal_mutable_rlp_tx();
  public:

  // bytes block_hash = 4;
  void clear_block_hash();
  const std::string& block_hash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_block_hash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_block_hash();
  PROTOBUF_NODISCARD std::string* release_block_hash();
  void set_allocated_block_hash(std::string* block_hash);
  private:
  const std::string& _internal_block_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_block_hash(const std::string& value);
  std::string* _internal_mutable_block_hash();
  public:

  // bytes return_value = 7;
  void clear_return_value();
  const std::string& return_value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_return_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_return_value();
  PROTOBUF_NODISCARD std::string* release_return_value();
  void set_allocated_return_value(std::string* return_value);
  private:
  const std::string& _internal_return_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_return_value(const std::string& value);
  std::string* _internal_mutable_return_value();
  public:

  // string create_address = 13;
  void clear_create_address();
  const std::string& create_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_create_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_create_address();
  PROTOBUF_NODISCARD std::string* release_create_address();
  void set_allocated_create_address(std::string* create_address);
  private:
  const std::string& _internal_create_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_create_address(const std::string& value);
  std::string* _internal_mutable_create_address();
  public:

  // bytes state_root = 14;
  void clear_state_root();
  const std::string& state_root() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_state_root(ArgT0&& arg0, ArgT... args);
  std::string* mutable_state_root();
  PROTOBUF_NODISCARD std::string* release_state_root();
  void set_allocated_state_root(std::string* state_root);
  private:
  const std::string& _internal_state_root() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_state_root(const std::string& value);
  std::string* _internal_mutable_state_root();
  public:

  // string effective_gas_price = 17;
  void clear_effective_gas_price();
  const std::string& effective_gas_price() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_effective_gas_price(ArgT0&& arg0, ArgT... args);
  std::string* mutable_effective_gas_price();
  PROTOBUF_NODISCARD std::string* release_effective_gas_price();
  void set_allocated_effective_gas_price(std::string* effective_gas_price);
  private:
  const std::string& _internal_effective_gas_price() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_effective_gas_price(const std::string& value);
  std::string* _internal_mutable_effective_gas_price();
  public:

  // .executor.v1.FullTraceV2 full_trace = 16;
  bool has_full_trace() const;
  private:
  bool _internal_has_full_trace() const;
  public:
  void clear_full_trace();
  const ::executor::v1::FullTraceV2& full_trace() const;
  PROTOBUF_NODISCARD ::executor::v1::FullTraceV2* release_full_trace();
  ::executor::v1::FullTraceV2* mutable_full_trace();
  void set_allocated_full_trace(::executor::v1::FullTraceV2* full_trace);
  private:
  const ::executor::v1::FullTraceV2& _internal_full_trace() const;
  ::executor::v1::FullTraceV2* _internal_mutable_full_trace();
  public:
  void unsafe_arena_set_allocated_full_trace(
      ::executor::v1::FullTraceV2* full_trace);
  ::executor::v1::FullTraceV2* unsafe_arena_release_full_trace();

  // uint64 block_number = 5;
  void clear_block_number();
  uint64_t block_number() const;
  void set_block_number(uint64_t value);
  private:
  uint64_t _internal_block_number() const;
  void _internal_set_block_number(uint64_t value);
  public:

  // uint64 gas_left = 8;
  void clear_gas_left();
  uint64_t gas_left() const;
  void set_gas_left(uint64_t value);
  private:
  uint64_t _internal_gas_left() const;
  void _internal_set_gas_left(uint64_t value);
  public:

  // uint64 gas_used = 9;
  void clear_gas_used();
  uint64_t gas_used() const;
  void set_gas_used(uint64_t value);
  private:
  uint64_t _internal_gas_used() const;
  void _internal_set_gas_used(uint64_t value);
  public:

  // uint32 type = 6;
  void clear_type();
  uint32_t type() const;
  void set_type(uint32_t value);
  private:
  uint32_t _internal_type() const;
  void _internal_set_type(uint32_t value);
  public:

  // .executor.v1.RomError error = 12;
  void clear_error();
  ::executor::v1::RomError error() const;
  void set_error(::executor::v1::RomError value);
  private:
  ::executor::v1::RomError _internal_error() const;
  void _internal_set_error(::executor::v1::RomError value);
  public:

  // uint64 cumulative_gas_used = 10;
  void clear_cumulative_gas_used();
  uint64_t cumulative_gas_used() const;
  void set_cumulative_gas_used(uint64_t value);
  private:
  uint64_t _internal_cumulative_gas_used() const;
  void _internal_set_cumulative_gas_used(uint64_t value);
  public:

  // uint64 gas_refunded = 11;
  void clear_gas_refunded();
  uint64_t gas_refunded() const;
  void set_gas_refunded(uint64_t value);
  private:
  uint64_t _internal_gas_refunded() const;
  void _internal_set_gas_refunded(uint64_t value);
  public:

  // uint32 effective_percentage = 18;
  void clear_effective_percentage();
  uint32_t effective_percentage() const;
  void set_effective_percentage(uint32_t value);
  private:
  uint32_t _internal_effective_percentage() const;
  void _internal_set_effective_percentage(uint32_t value);
  public:

  // uint32 has_gasprice_opcode = 19;
  void clear_has_gasprice_opcode();
  uint32_t has_gasprice_opcode() const;
  void set_has_gasprice_opcode(uint32_t value);
  private:
  uint32_t _internal_has_gasprice_opcode() const;
  void _internal_set_has_gasprice_opcode(uint32_t value);
  public:

  // uint32 has_balance_opcode = 20;
  void clear_has_balance_opcode();
  uint32_t has_balance_opcode() const;
  void set_has_balance_opcode(uint32_t value);
  private:
  uint32_t _internal_has_balance_opcode() const;
  void _internal_set_has_balance_opcode(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:executor.v1.ProcessTransactionResponseV2)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::executor::v1::LogV2 > logs_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tx_hash_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tx_hash_l2_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr rlp_tx_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr block_hash_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr return_value_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr create_address_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr state_root_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr effective_gas_price_;
    ::executor::v1::FullTraceV2* full_trace_;
    uint64_t block_number_;
    uint64_t gas_left_;
    uint64_t gas_used_;
    uint32_t type_;
    int error_;
    uint64_t cumulative_gas_used_;
    uint64_t gas_refunded_;
    uint32_t effective_percentage_;
    uint32_t has_gasprice_opcode_;
    uint32_t has_balance_opcode_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_executor_2eproto;
};
// -------------------------------------------------------------------

class LogV2 final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:executor.v1.LogV2) */ {
 public:
  inline LogV2() : LogV2(nullptr) {}
  ~LogV2() override;
  explicit PROTOBUF_CONSTEXPR LogV2(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LogV2(const LogV2& from);
  LogV2(LogV2&& from) noexcept
    : LogV2() {
    *this = ::std::move(from);
  }

  inline LogV2& operator=(const LogV2& from) {
    CopyFrom(from);
    return *this;
  }
  inline LogV2& operator=(LogV2&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LogV2& default_instance() {
    return *internal_default_instance();
  }
  static inline const LogV2* internal_default_instance() {
    return reinterpret_cast<const LogV2*>(
               &_LogV2_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    40;

  friend void swap(LogV2& a, LogV2& b) {
    a.Swap(&b);
  }
  inline void Swap(LogV2* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LogV2* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LogV2* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LogV2>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LogV2& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LogV2& from) {
    LogV2::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LogV2* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "executor.v1.LogV2";
  }
  protected:
  explicit LogV2(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTopicsFieldNumber = 2,
    kAddressFieldNumber = 1,
    kDataFieldNumber = 3,
    kTxHashFieldNumber = 5,
    kTxHashL2FieldNumber = 6,
    kBlockHashFieldNumber = 8,
    kBlockNumberFieldNumber = 4,
    kTxIndexFieldNumber = 7,
    kIndexFieldNumber = 9,
  };
  // repeated bytes topics = 2;
  int topics_size() const;
  private:
  int _internal_topics_size() const;
  public:
  void clear_topics();
  const std::string& topics(int index) const;
  std::string* mutable_topics(int index);
  void set_topics(int index, const std::string& value);
  void set_topics(int index, std::string&& value);
  void set_topics(int index, const char* value);
  void set_topics(int index, const void* value, size_t size);
  std::string* add_topics();
  void add_topics(const std::string& value);
  void add_topics(std::string&& value);
  void add_topics(const char* value);
  void add_topics(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& topics() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_topics();
  private:
  const std::string& _internal_topics(int index) const;
  std::string* _internal_add_topics();
  public:

  // string address = 1;
  void clear_address();
  const std::string& address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_address();
  PROTOBUF_NODISCARD std::string* release_address();
  void set_allocated_address(std::string* address);
  private:
  const std::string& _internal_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_address(const std::string& value);
  std::string* _internal_mutable_address();
  public:

  // bytes data = 3;
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // bytes tx_hash = 5;
  void clear_tx_hash();
  const std::string& tx_hash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tx_hash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tx_hash();
  PROTOBUF_NODISCARD std::string* release_tx_hash();
  void set_allocated_tx_hash(std::string* tx_hash);
  private:
  const std::string& _internal_tx_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tx_hash(const std::string& value);
  std::string* _internal_mutable_tx_hash();
  public:

  // bytes tx_hash_l2 = 6;
  void clear_tx_hash_l2();
  const std::string& tx_hash_l2() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tx_hash_l2(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tx_hash_l2();
  PROTOBUF_NODISCARD std::string* release_tx_hash_l2();
  void set_allocated_tx_hash_l2(std::string* tx_hash_l2);
  private:
  const std::string& _internal_tx_hash_l2() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tx_hash_l2(const std::string& value);
  std::string* _internal_mutable_tx_hash_l2();
  public:

  // bytes block_hash = 8;
  void clear_block_hash();
  const std::string& block_hash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_block_hash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_block_hash();
  PROTOBUF_NODISCARD std::string* release_block_hash();
  void set_allocated_block_hash(std::string* block_hash);
  private:
  const std::string& _internal_block_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_block_hash(const std::string& value);
  std::string* _internal_mutable_block_hash();
  public:

  // uint64 block_number = 4;
  void clear_block_number();
  uint64_t block_number() const;
  void set_block_number(uint64_t value);
  private:
  uint64_t _internal_block_number() const;
  void _internal_set_block_number(uint64_t value);
  public:

  // uint32 tx_index = 7;
  void clear_tx_index();
  uint32_t tx_index() const;
  void set_tx_index(uint32_t value);
  private:
  uint32_t _internal_tx_index() const;
  void _internal_set_tx_index(uint32_t value);
  public:

  // uint32 index = 9;
  void clear_index();
  uint32_t index() const;
  void set_index(uint32_t value);
  private:
  uint32_t _internal_index() const;
  void _internal_set_index(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:executor.v1.LogV2)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> topics_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr address_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tx_hash_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tx_hash_l2_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr block_hash_;
    uint64_t block_number_;
    uint32_t tx_index_;
    uint32_t index_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_executor_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// ProcessBatchRequest

// bytes old_state_root = 1;
inline void ProcessBatchRequest::clear_old_state_root() {
  _impl_.old_state_root_.ClearToEmpty();
}
inline const std::string& ProcessBatchRequest::old_state_root() const {
  // @@protoc_insertion_point(field_get:executor.v1.ProcessBatchRequest.old_state_root)
  return _internal_old_state_root();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProcessBatchRequest::set_old_state_root(ArgT0&& arg0, ArgT... args) {
 
 _impl_.old_state_root_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:executor.v1.ProcessBatchRequest.old_state_root)
}
inline std::string* ProcessBatchRequest::mutable_old_state_root() {
  std::string* _s = _internal_mutable_old_state_root();
  // @@protoc_insertion_point(field_mutable:executor.v1.ProcessBatchRequest.old_state_root)
  return _s;
}
inline const std::string& ProcessBatchRequest::_internal_old_state_root() const {
  return _impl_.old_state_root_.Get();
}
inline void ProcessBatchRequest::_internal_set_old_state_root(const std::string& value) {
  
  _impl_.old_state_root_.Set(value, GetArenaForAllocation());
}
inline std::string* ProcessBatchRequest::_internal_mutable_old_state_root() {
  
  return _impl_.old_state_root_.Mutable(GetArenaForAllocation());
}
inline std::string* ProcessBatchRequest::release_old_state_root() {
  // @@protoc_insertion_point(field_release:executor.v1.ProcessBatchRequest.old_state_root)
  return _impl_.old_state_root_.Release();
}
inline void ProcessBatchRequest::set_allocated_old_state_root(std::string* old_state_root) {
  if (old_state_root != nullptr) {
    
  } else {
    
  }
  _impl_.old_state_root_.SetAllocated(old_state_root, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.old_state_root_.IsDefault()) {
    _impl_.old_state_root_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:executor.v1.ProcessBatchRequest.old_state_root)
}

// bytes old_acc_input_hash = 2;
inline void ProcessBatchRequest::clear_old_acc_input_hash() {
  _impl_.old_acc_input_hash_.ClearToEmpty();
}
inline const std::string& ProcessBatchRequest::old_acc_input_hash() const {
  // @@protoc_insertion_point(field_get:executor.v1.ProcessBatchRequest.old_acc_input_hash)
  return _internal_old_acc_input_hash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProcessBatchRequest::set_old_acc_input_hash(ArgT0&& arg0, ArgT... args) {
 
 _impl_.old_acc_input_hash_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:executor.v1.ProcessBatchRequest.old_acc_input_hash)
}
inline std::string* ProcessBatchRequest::mutable_old_acc_input_hash() {
  std::string* _s = _internal_mutable_old_acc_input_hash();
  // @@protoc_insertion_point(field_mutable:executor.v1.ProcessBatchRequest.old_acc_input_hash)
  return _s;
}
inline const std::string& ProcessBatchRequest::_internal_old_acc_input_hash() const {
  return _impl_.old_acc_input_hash_.Get();
}
inline void ProcessBatchRequest::_internal_set_old_acc_input_hash(const std::string& value) {
  
  _impl_.old_acc_input_hash_.Set(value, GetArenaForAllocation());
}
inline std::string* ProcessBatchRequest::_internal_mutable_old_acc_input_hash() {
  
  return _impl_.old_acc_input_hash_.Mutable(GetArenaForAllocation());
}
inline std::string* ProcessBatchRequest::release_old_acc_input_hash() {
  // @@protoc_insertion_point(field_release:executor.v1.ProcessBatchRequest.old_acc_input_hash)
  return _impl_.old_acc_input_hash_.Release();
}
inline void ProcessBatchRequest::set_allocated_old_acc_input_hash(std::string* old_acc_input_hash) {
  if (old_acc_input_hash != nullptr) {
    
  } else {
    
  }
  _impl_.old_acc_input_hash_.SetAllocated(old_acc_input_hash, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.old_acc_input_hash_.IsDefault()) {
    _impl_.old_acc_input_hash_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:executor.v1.ProcessBatchRequest.old_acc_input_hash)
}

// uint64 old_batch_num = 3;
inline void ProcessBatchRequest::clear_old_batch_num() {
  _impl_.old_batch_num_ = uint64_t{0u};
}
inline uint64_t ProcessBatchRequest::_internal_old_batch_num() const {
  return _impl_.old_batch_num_;
}
inline uint64_t ProcessBatchRequest::old_batch_num() const {
  // @@protoc_insertion_point(field_get:executor.v1.ProcessBatchRequest.old_batch_num)
  return _internal_old_batch_num();
}
inline void ProcessBatchRequest::_internal_set_old_batch_num(uint64_t value) {
  
  _impl_.old_batch_num_ = value;
}
inline void ProcessBatchRequest::set_old_batch_num(uint64_t value) {
  _internal_set_old_batch_num(value);
  // @@protoc_insertion_point(field_set:executor.v1.ProcessBatchRequest.old_batch_num)
}

// uint64 chain_id = 4;
inline void ProcessBatchRequest::clear_chain_id() {
  _impl_.chain_id_ = uint64_t{0u};
}
inline uint64_t ProcessBatchRequest::_internal_chain_id() const {
  return _impl_.chain_id_;
}
inline uint64_t ProcessBatchRequest::chain_id() const {
  // @@protoc_insertion_point(field_get:executor.v1.ProcessBatchRequest.chain_id)
  return _internal_chain_id();
}
inline void ProcessBatchRequest::_internal_set_chain_id(uint64_t value) {
  
  _impl_.chain_id_ = value;
}
inline void ProcessBatchRequest::set_chain_id(uint64_t value) {
  _internal_set_chain_id(value);
  // @@protoc_insertion_point(field_set:executor.v1.ProcessBatchRequest.chain_id)
}

// uint64 fork_id = 5;
inline void ProcessBatchRequest::clear_fork_id() {
  _impl_.fork_id_ = uint64_t{0u};
}
inline uint64_t ProcessBatchRequest::_internal_fork_id() const {
  return _impl_.fork_id_;
}
inline uint64_t ProcessBatchRequest::fork_id() const {
  // @@protoc_insertion_point(field_get:executor.v1.ProcessBatchRequest.fork_id)
  return _internal_fork_id();
}
inline void ProcessBatchRequest::_internal_set_fork_id(uint64_t value) {
  
  _impl_.fork_id_ = value;
}
inline void ProcessBatchRequest::set_fork_id(uint64_t value) {
  _internal_set_fork_id(value);
  // @@protoc_insertion_point(field_set:executor.v1.ProcessBatchRequest.fork_id)
}

// bytes batch_l2_data = 6;
inline void ProcessBatchRequest::clear_batch_l2_data() {
  _impl_.batch_l2_data_.ClearToEmpty();
}
inline const std::string& ProcessBatchRequest::batch_l2_data() const {
  // @@protoc_insertion_point(field_get:executor.v1.ProcessBatchRequest.batch_l2_data)
  return _internal_batch_l2_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProcessBatchRequest::set_batch_l2_data(ArgT0&& arg0, ArgT... args) {
 
 _impl_.batch_l2_data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:executor.v1.ProcessBatchRequest.batch_l2_data)
}
inline std::string* ProcessBatchRequest::mutable_batch_l2_data() {
  std::string* _s = _internal_mutable_batch_l2_data();
  // @@protoc_insertion_point(field_mutable:executor.v1.ProcessBatchRequest.batch_l2_data)
  return _s;
}
inline const std::string& ProcessBatchRequest::_internal_batch_l2_data() const {
  return _impl_.batch_l2_data_.Get();
}
inline void ProcessBatchRequest::_internal_set_batch_l2_data(const std::string& value) {
  
  _impl_.batch_l2_data_.Set(value, GetArenaForAllocation());
}
inline std::string* ProcessBatchRequest::_internal_mutable_batch_l2_data() {
  
  return _impl_.batch_l2_data_.Mutable(GetArenaForAllocation());
}
inline std::string* ProcessBatchRequest::release_batch_l2_data() {
  // @@protoc_insertion_point(field_release:executor.v1.ProcessBatchRequest.batch_l2_data)
  return _impl_.batch_l2_data_.Release();
}
inline void ProcessBatchRequest::set_allocated_batch_l2_data(std::string* batch_l2_data) {
  if (batch_l2_data != nullptr) {
    
  } else {
    
  }
  _impl_.batch_l2_data_.SetAllocated(batch_l2_data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.batch_l2_data_.IsDefault()) {
    _impl_.batch_l2_data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:executor.v1.ProcessBatchRequest.batch_l2_data)
}

// bytes global_exit_root = 7;
inline void ProcessBatchRequest::clear_global_exit_root() {
  _impl_.global_exit_root_.ClearToEmpty();
}
inline const std::string& ProcessBatchRequest::global_exit_root() const {
  // @@protoc_insertion_point(field_get:executor.v1.ProcessBatchRequest.global_exit_root)
  return _internal_global_exit_root();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProcessBatchRequest::set_global_exit_root(ArgT0&& arg0, ArgT... args) {
 
 _impl_.global_exit_root_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:executor.v1.ProcessBatchRequest.global_exit_root)
}
inline std::string* ProcessBatchRequest::mutable_global_exit_root() {
  std::string* _s = _internal_mutable_global_exit_root();
  // @@protoc_insertion_point(field_mutable:executor.v1.ProcessBatchRequest.global_exit_root)
  return _s;
}
inline const std::string& ProcessBatchRequest::_internal_global_exit_root() const {
  return _impl_.global_exit_root_.Get();
}
inline void ProcessBatchRequest::_internal_set_global_exit_root(const std::string& value) {
  
  _impl_.global_exit_root_.Set(value, GetArenaForAllocation());
}
inline std::string* ProcessBatchRequest::_internal_mutable_global_exit_root() {
  
  return _impl_.global_exit_root_.Mutable(GetArenaForAllocation());
}
inline std::string* ProcessBatchRequest::release_global_exit_root() {
  // @@protoc_insertion_point(field_release:executor.v1.ProcessBatchRequest.global_exit_root)
  return _impl_.global_exit_root_.Release();
}
inline void ProcessBatchRequest::set_allocated_global_exit_root(std::string* global_exit_root) {
  if (global_exit_root != nullptr) {
    
  } else {
    
  }
  _impl_.global_exit_root_.SetAllocated(global_exit_root, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.global_exit_root_.IsDefault()) {
    _impl_.global_exit_root_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:executor.v1.ProcessBatchRequest.global_exit_root)
}

// uint64 eth_timestamp = 8;
inline void ProcessBatchRequest::clear_eth_timestamp() {
  _impl_.eth_timestamp_ = uint64_t{0u};
}
inline uint64_t ProcessBatchRequest::_internal_eth_timestamp() const {
  return _impl_.eth_timestamp_;
}
inline uint64_t ProcessBatchRequest::eth_timestamp() const {
  // @@protoc_insertion_point(field_get:executor.v1.ProcessBatchRequest.eth_timestamp)
  return _internal_eth_timestamp();
}
inline void ProcessBatchRequest::_internal_set_eth_timestamp(uint64_t value) {
  
  _impl_.eth_timestamp_ = value;
}
inline void ProcessBatchRequest::set_eth_timestamp(uint64_t value) {
  _internal_set_eth_timestamp(value);
  // @@protoc_insertion_point(field_set:executor.v1.ProcessBatchRequest.eth_timestamp)
}

// string coinbase = 9;
inline void ProcessBatchRequest::clear_coinbase() {
  _impl_.coinbase_.ClearToEmpty();
}
inline const std::string& ProcessBatchRequest::coinbase() const {
  // @@protoc_insertion_point(field_get:executor.v1.ProcessBatchRequest.coinbase)
  return _internal_coinbase();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProcessBatchRequest::set_coinbase(ArgT0&& arg0, ArgT... args) {
 
 _impl_.coinbase_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:executor.v1.ProcessBatchRequest.coinbase)
}
inline std::string* ProcessBatchRequest::mutable_coinbase() {
  std::string* _s = _internal_mutable_coinbase();
  // @@protoc_insertion_point(field_mutable:executor.v1.ProcessBatchRequest.coinbase)
  return _s;
}
inline const std::string& ProcessBatchRequest::_internal_coinbase() const {
  return _impl_.coinbase_.Get();
}
inline void ProcessBatchRequest::_internal_set_coinbase(const std::string& value) {
  
  _impl_.coinbase_.Set(value, GetArenaForAllocation());
}
inline std::string* ProcessBatchRequest::_internal_mutable_coinbase() {
  
  return _impl_.coinbase_.Mutable(GetArenaForAllocation());
}
inline std::string* ProcessBatchRequest::release_coinbase() {
  // @@protoc_insertion_point(field_release:executor.v1.ProcessBatchRequest.coinbase)
  return _impl_.coinbase_.Release();
}
inline void ProcessBatchRequest::set_allocated_coinbase(std::string* coinbase) {
  if (coinbase != nullptr) {
    
  } else {
    
  }
  _impl_.coinbase_.SetAllocated(coinbase, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.coinbase_.IsDefault()) {
    _impl_.coinbase_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:executor.v1.ProcessBatchRequest.coinbase)
}

// uint32 update_merkle_tree = 10;
inline void ProcessBatchRequest::clear_update_merkle_tree() {
  _impl_.update_merkle_tree_ = 0u;
}
inline uint32_t ProcessBatchRequest::_internal_update_merkle_tree() const {
  return _impl_.update_merkle_tree_;
}
inline uint32_t ProcessBatchRequest::update_merkle_tree() const {
  // @@protoc_insertion_point(field_get:executor.v1.ProcessBatchRequest.update_merkle_tree)
  return _internal_update_merkle_tree();
}
inline void ProcessBatchRequest::_internal_set_update_merkle_tree(uint32_t value) {
  
  _impl_.update_merkle_tree_ = value;
}
inline void ProcessBatchRequest::set_update_merkle_tree(uint32_t value) {
  _internal_set_update_merkle_tree(value);
  // @@protoc_insertion_point(field_set:executor.v1.ProcessBatchRequest.update_merkle_tree)
}

// uint64 no_counters = 11;
inline void ProcessBatchRequest::clear_no_counters() {
  _impl_.no_counters_ = uint64_t{0u};
}
inline uint64_t ProcessBatchRequest::_internal_no_counters() const {
  return _impl_.no_counters_;
}
inline uint64_t ProcessBatchRequest::no_counters() const {
  // @@protoc_insertion_point(field_get:executor.v1.ProcessBatchRequest.no_counters)
  return _internal_no_counters();
}
inline void ProcessBatchRequest::_internal_set_no_counters(uint64_t value) {
  
  _impl_.no_counters_ = value;
}
inline void ProcessBatchRequest::set_no_counters(uint64_t value) {
  _internal_set_no_counters(value);
  // @@protoc_insertion_point(field_set:executor.v1.ProcessBatchRequest.no_counters)
}

// string from = 12;
inline void ProcessBatchRequest::clear_from() {
  _impl_.from_.ClearToEmpty();
}
inline const std::string& ProcessBatchRequest::from() const {
  // @@protoc_insertion_point(field_get:executor.v1.ProcessBatchRequest.from)
  return _internal_from();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProcessBatchRequest::set_from(ArgT0&& arg0, ArgT... args) {
 
 _impl_.from_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:executor.v1.ProcessBatchRequest.from)
}
inline std::string* ProcessBatchRequest::mutable_from() {
  std::string* _s = _internal_mutable_from();
  // @@protoc_insertion_point(field_mutable:executor.v1.ProcessBatchRequest.from)
  return _s;
}
inline const std::string& ProcessBatchRequest::_internal_from() const {
  return _impl_.from_.Get();
}
inline void ProcessBatchRequest::_internal_set_from(const std::string& value) {
  
  _impl_.from_.Set(value, GetArenaForAllocation());
}
inline std::string* ProcessBatchRequest::_internal_mutable_from() {
  
  return _impl_.from_.Mutable(GetArenaForAllocation());
}
inline std::string* ProcessBatchRequest::release_from() {
  // @@protoc_insertion_point(field_release:executor.v1.ProcessBatchRequest.from)
  return _impl_.from_.Release();
}
inline void ProcessBatchRequest::set_allocated_from(std::string* from) {
  if (from != nullptr) {
    
  } else {
    
  }
  _impl_.from_.SetAllocated(from, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.from_.IsDefault()) {
    _impl_.from_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:executor.v1.ProcessBatchRequest.from)
}

// map<string, string> db = 13;
inline int ProcessBatchRequest::_internal_db_size() const {
  return _impl_.db_.size();
}
inline int ProcessBatchRequest::db_size() const {
  return _internal_db_size();
}
inline void ProcessBatchRequest::clear_db() {
  _impl_.db_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
ProcessBatchRequest::_internal_db() const {
  return _impl_.db_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
ProcessBatchRequest::db() const {
  // @@protoc_insertion_point(field_map:executor.v1.ProcessBatchRequest.db)
  return _internal_db();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
ProcessBatchRequest::_internal_mutable_db() {
  return _impl_.db_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
ProcessBatchRequest::mutable_db() {
  // @@protoc_insertion_point(field_mutable_map:executor.v1.ProcessBatchRequest.db)
  return _internal_mutable_db();
}

// map<string, string> contracts_bytecode = 14;
inline int ProcessBatchRequest::_internal_contracts_bytecode_size() const {
  return _impl_.contracts_bytecode_.size();
}
inline int ProcessBatchRequest::contracts_bytecode_size() const {
  return _internal_contracts_bytecode_size();
}
inline void ProcessBatchRequest::clear_contracts_bytecode() {
  _impl_.contracts_bytecode_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
ProcessBatchRequest::_internal_contracts_bytecode() const {
  return _impl_.contracts_bytecode_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
ProcessBatchRequest::contracts_bytecode() const {
  // @@protoc_insertion_point(field_map:executor.v1.ProcessBatchRequest.contracts_bytecode)
  return _internal_contracts_bytecode();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
ProcessBatchRequest::_internal_mutable_contracts_bytecode() {
  return _impl_.contracts_bytecode_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
ProcessBatchRequest::mutable_contracts_bytecode() {
  // @@protoc_insertion_point(field_mutable_map:executor.v1.ProcessBatchRequest.contracts_bytecode)
  return _internal_mutable_contracts_bytecode();
}

// .executor.v1.TraceConfig trace_config = 15;
inline bool ProcessBatchRequest::_internal_has_trace_config() const {
  return this != internal_default_instance() && _impl_.trace_config_ != nullptr;
}
inline bool ProcessBatchRequest::has_trace_config() const {
  return _internal_has_trace_config();
}
inline void ProcessBatchRequest::clear_trace_config() {
  if (GetArenaForAllocation() == nullptr && _impl_.trace_config_ != nullptr) {
    delete _impl_.trace_config_;
  }
  _impl_.trace_config_ = nullptr;
}
inline const ::executor::v1::TraceConfig& ProcessBatchRequest::_internal_trace_config() const {
  const ::executor::v1::TraceConfig* p = _impl_.trace_config_;
  return p != nullptr ? *p : reinterpret_cast<const ::executor::v1::TraceConfig&>(
      ::executor::v1::_TraceConfig_default_instance_);
}
inline const ::executor::v1::TraceConfig& ProcessBatchRequest::trace_config() const {
  // @@protoc_insertion_point(field_get:executor.v1.ProcessBatchRequest.trace_config)
  return _internal_trace_config();
}
inline void ProcessBatchRequest::unsafe_arena_set_allocated_trace_config(
    ::executor::v1::TraceConfig* trace_config) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.trace_config_);
  }
  _impl_.trace_config_ = trace_config;
  if (trace_config) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:executor.v1.ProcessBatchRequest.trace_config)
}
inline ::executor::v1::TraceConfig* ProcessBatchRequest::release_trace_config() {
  
  ::executor::v1::TraceConfig* temp = _impl_.trace_config_;
  _impl_.trace_config_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::executor::v1::TraceConfig* ProcessBatchRequest::unsafe_arena_release_trace_config() {
  // @@protoc_insertion_point(field_release:executor.v1.ProcessBatchRequest.trace_config)
  
  ::executor::v1::TraceConfig* temp = _impl_.trace_config_;
  _impl_.trace_config_ = nullptr;
  return temp;
}
inline ::executor::v1::TraceConfig* ProcessBatchRequest::_internal_mutable_trace_config() {
  
  if (_impl_.trace_config_ == nullptr) {
    auto* p = CreateMaybeMessage<::executor::v1::TraceConfig>(GetArenaForAllocation());
    _impl_.trace_config_ = p;
  }
  return _impl_.trace_config_;
}
inline ::executor::v1::TraceConfig* ProcessBatchRequest::mutable_trace_config() {
  ::executor::v1::TraceConfig* _msg = _internal_mutable_trace_config();
  // @@protoc_insertion_point(field_mutable:executor.v1.ProcessBatchRequest.trace_config)
  return _msg;
}
inline void ProcessBatchRequest::set_allocated_trace_config(::executor::v1::TraceConfig* trace_config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.trace_config_;
  }
  if (trace_config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(trace_config);
    if (message_arena != submessage_arena) {
      trace_config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, trace_config, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.trace_config_ = trace_config;
  // @@protoc_insertion_point(field_set_allocated:executor.v1.ProcessBatchRequest.trace_config)
}

// string context_id = 16;
inline void ProcessBatchRequest::clear_context_id() {
  _impl_.context_id_.ClearToEmpty();
}
inline const std::string& ProcessBatchRequest::context_id() const {
  // @@protoc_insertion_point(field_get:executor.v1.ProcessBatchRequest.context_id)
  return _internal_context_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProcessBatchRequest::set_context_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.context_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:executor.v1.ProcessBatchRequest.context_id)
}
inline std::string* ProcessBatchRequest::mutable_context_id() {
  std::string* _s = _internal_mutable_context_id();
  // @@protoc_insertion_point(field_mutable:executor.v1.ProcessBatchRequest.context_id)
  return _s;
}
inline const std::string& ProcessBatchRequest::_internal_context_id() const {
  return _impl_.context_id_.Get();
}
inline void ProcessBatchRequest::_internal_set_context_id(const std::string& value) {
  
  _impl_.context_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ProcessBatchRequest::_internal_mutable_context_id() {
  
  return _impl_.context_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ProcessBatchRequest::release_context_id() {
  // @@protoc_insertion_point(field_release:executor.v1.ProcessBatchRequest.context_id)
  return _impl_.context_id_.Release();
}
inline void ProcessBatchRequest::set_allocated_context_id(std::string* context_id) {
  if (context_id != nullptr) {
    
  } else {
    
  }
  _impl_.context_id_.SetAllocated(context_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.context_id_.IsDefault()) {
    _impl_.context_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:executor.v1.ProcessBatchRequest.context_id)
}

// map<string, .executor.v1.OverrideAccount> state_override = 17;
inline int ProcessBatchRequest::_internal_state_override_size() const {
  return _impl_.state_override_.size();
}
inline int ProcessBatchRequest::state_override_size() const {
  return _internal_state_override_size();
}
inline void ProcessBatchRequest::clear_state_override() {
  _impl_.state_override_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::executor::v1::OverrideAccount >&
ProcessBatchRequest::_internal_state_override() const {
  return _impl_.state_override_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::executor::v1::OverrideAccount >&
ProcessBatchRequest::state_override() const {
  // @@protoc_insertion_point(field_map:executor.v1.ProcessBatchRequest.state_override)
  return _internal_state_override();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::executor::v1::OverrideAccount >*
ProcessBatchRequest::_internal_mutable_state_override() {
  return _impl_.state_override_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::executor::v1::OverrideAccount >*
ProcessBatchRequest::mutable_state_override() {
  // @@protoc_insertion_point(field_mutable_map:executor.v1.ProcessBatchRequest.state_override)
  return _internal_mutable_state_override();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// ProcessBatchResponse

// bytes new_state_root = 1;
inline void ProcessBatchResponse::clear_new_state_root() {
  _impl_.new_state_root_.ClearToEmpty();
}
inline const std::string& ProcessBatchResponse::new_state_root() const {
  // @@protoc_insertion_point(field_get:executor.v1.ProcessBatchResponse.new_state_root)
  return _internal_new_state_root();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProcessBatchResponse::set_new_state_root(ArgT0&& arg0, ArgT... args) {
 
 _impl_.new_state_root_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:executor.v1.ProcessBatchResponse.new_state_root)
}
inline std::string* ProcessBatchResponse::mutable_new_state_root() {
  std::string* _s = _internal_mutable_new_state_root();
  // @@protoc_insertion_point(field_mutable:executor.v1.ProcessBatchResponse.new_state_root)
  return _s;
}
inline const std::string& ProcessBatchResponse::_internal_new_state_root() const {
  return _impl_.new_state_root_.Get();
}
inline void ProcessBatchResponse::_internal_set_new_state_root(const std::string& value) {
  
  _impl_.new_state_root_.Set(value, GetArenaForAllocation());
}
inline std::string* ProcessBatchResponse::_internal_mutable_new_state_root() {
  
  return _impl_.new_state_root_.Mutable(GetArenaForAllocation());
}
inline std::string* ProcessBatchResponse::release_new_state_root() {
  // @@protoc_insertion_point(field_release:executor.v1.ProcessBatchResponse.new_state_root)
  return _impl_.new_state_root_.Release();
}
inline void ProcessBatchResponse::set_allocated_new_state_root(std::string* new_state_root) {
  if (new_state_root != nullptr) {
    
  } else {
    
  }
  _impl_.new_state_root_.SetAllocated(new_state_root, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.new_state_root_.IsDefault()) {
    _impl_.new_state_root_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:executor.v1.ProcessBatchResponse.new_state_root)
}

// bytes new_acc_input_hash = 2;
inline void ProcessBatchResponse::clear_new_acc_input_hash() {
  _impl_.new_acc_input_hash_.ClearToEmpty();
}
inline const std::string& ProcessBatchResponse::new_acc_input_hash() const {
  // @@protoc_insertion_point(field_get:executor.v1.ProcessBatchResponse.new_acc_input_hash)
  return _internal_new_acc_input_hash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProcessBatchResponse::set_new_acc_input_hash(ArgT0&& arg0, ArgT... args) {
 
 _impl_.new_acc_input_hash_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:executor.v1.ProcessBatchResponse.new_acc_input_hash)
}
inline std::string* ProcessBatchResponse::mutable_new_acc_input_hash() {
  std::string* _s = _internal_mutable_new_acc_input_hash();
  // @@protoc_insertion_point(field_mutable:executor.v1.ProcessBatchResponse.new_acc_input_hash)
  return _s;
}
inline const std::string& ProcessBatchResponse::_internal_new_acc_input_hash() const {
  return _impl_.new_acc_input_hash_.Get();
}
inline void ProcessBatchResponse::_internal_set_new_acc_input_hash(const std::string& value) {
  
  _impl_.new_acc_input_hash_.Set(value, GetArenaForAllocation());
}
inline std::string* ProcessBatchResponse::_internal_mutable_new_acc_input_hash() {
  
  return _impl_.new_acc_input_hash_.Mutable(GetArenaForAllocation());
}
inline std::string* ProcessBatchResponse::release_new_acc_input_hash() {
  // @@protoc_insertion_point(field_release:executor.v1.ProcessBatchResponse.new_acc_input_hash)
  return _impl_.new_acc_input_hash_.Release();
}
inline void ProcessBatchResponse::set_allocated_new_acc_input_hash(std::string* new_acc_input_hash) {
  if (new_acc_input_hash != nullptr) {
    
  } else {
    
  }
  _impl_.new_acc_input_hash_.SetAllocated(new_acc_input_hash, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.new_acc_input_hash_.IsDefault()) {
    _impl_.new_acc_input_hash_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:executor.v1.ProcessBatchResponse.new_acc_input_hash)
}

// bytes new_local_exit_root = 3;
inline void ProcessBatchResponse::clear_new_local_exit_root() {
  _impl_.new_local_exit_root_.ClearToEmpty();
}
inline const std::string& ProcessBatchResponse::new_local_exit_root() const {
  // @@protoc_insertion_point(field_get:executor.v1.ProcessBatchResponse.new_local_exit_root)
  return _internal_new_local_exit_root();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProcessBatchResponse::set_new_local_exit_root(ArgT0&& arg0, ArgT... args) {
 
 _impl_.new_local_exit_root_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:executor.v1.ProcessBatchResponse.new_local_exit_root)
}
inline std::string* ProcessBatchResponse::mutable_new_local_exit_root() {
  std::string* _s = _internal_mutable_new_local_exit_root();
  // @@protoc_insertion_point(field_mutable:executor.v1.ProcessBatchResponse.new_local_exit_root)
  return _s;
}
inline const std::string& ProcessBatchResponse::_internal_new_local_exit_root() const {
  return _impl_.new_local_exit_root_.Get();
}
inline void ProcessBatchResponse::_internal_set_new_local_exit_root(const std::string& value) {
  
  _impl_.new_local_exit_root_.Set(value, GetArenaForAllocation());
}
inline std::string* ProcessBatchResponse::_internal_mutable_new_local_exit_root() {
  
  return _impl_.new_local_exit_root_.Mutable(GetArenaForAllocation());
}
inline std::string* ProcessBatchResponse::release_new_local_exit_root() {
  // @@protoc_insertion_point(field_release:executor.v1.ProcessBatchResponse.new_local_exit_root)
  return _impl_.new_local_exit_root_.Release();
}
inline void ProcessBatchResponse::set_allocated_new_local_exit_root(std::string* new_local_exit_root) {
  if (new_local_exit_root != nullptr) {
    
  } else {
    
  }
  _impl_.new_local_exit_root_.SetAllocated(new_local_exit_root, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.new_local_exit_root_.IsDefault()) {
    _impl_.new_local_exit_root_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:executor.v1.ProcessBatchResponse.new_local_exit_root)
}

// uint64 new_batch_num = 4;
inline void ProcessBatchResponse::clear_new_batch_num() {
  _impl_.new_batch_num_ = uint64_t{0u};
}
inline uint64_t ProcessBatchResponse::_internal_new_batch_num() const {
  return _impl_.new_batch_num_;
}
inline uint64_t ProcessBatchResponse::new_batch_num() const {
  // @@protoc_insertion_point(field_get:executor.v1.ProcessBatchResponse.new_batch_num)
  return _internal_new_batch_num();
}
inline void ProcessBatchResponse::_internal_set_new_batch_num(uint64_t value) {
  
  _impl_.new_batch_num_ = value;
}
inline void ProcessBatchResponse::set_new_batch_num(uint64_t value) {
  _internal_set_new_batch_num(value);
  // @@protoc_insertion_point(field_set:executor.v1.ProcessBatchResponse.new_batch_num)
}

// uint32 cnt_keccak_hashes = 5;
inline void ProcessBatchResponse::clear_cnt_keccak_hashes() {
  _impl_.cnt_keccak_hashes_ = 0u;
}
inline uint32_t ProcessBatchResponse::_internal_cnt_keccak_hashes() const {
  return _impl_.cnt_keccak_hashes_;
}
inline uint32_t ProcessBatchResponse::cnt_keccak_hashes() const {
  // @@protoc_insertion_point(field_get:executor.v1.ProcessBatchResponse.cnt_keccak_hashes)
  return _internal_cnt_keccak_hashes();
}
inline void ProcessBatchResponse::_internal_set_cnt_keccak_hashes(uint32_t value) {
  
  _impl_.cnt_keccak_hashes_ = value;
}
inline void ProcessBatchResponse::set_cnt_keccak_hashes(uint32_t value) {
  _internal_set_cnt_keccak_hashes(value);
  // @@protoc_insertion_point(field_set:executor.v1.ProcessBatchResponse.cnt_keccak_hashes)
}

// uint32 cnt_poseidon_hashes = 6;
inline void ProcessBatchResponse::clear_cnt_poseidon_hashes() {
  _impl_.cnt_poseidon_hashes_ = 0u;
}
inline uint32_t ProcessBatchResponse::_internal_cnt_poseidon_hashes() const {
  return _impl_.cnt_poseidon_hashes_;
}
inline uint32_t ProcessBatchResponse::cnt_poseidon_hashes() const {
  // @@protoc_insertion_point(field_get:executor.v1.ProcessBatchResponse.cnt_poseidon_hashes)
  return _internal_cnt_poseidon_hashes();
}
inline void ProcessBatchResponse::_internal_set_cnt_poseidon_hashes(uint32_t value) {
  
  _impl_.cnt_poseidon_hashes_ = value;
}
inline void ProcessBatchResponse::set_cnt_poseidon_hashes(uint32_t value) {
  _internal_set_cnt_poseidon_hashes(value);
  // @@protoc_insertion_point(field_set:executor.v1.ProcessBatchResponse.cnt_poseidon_hashes)
}

// uint32 cnt_poseidon_paddings = 7;
inline void ProcessBatchResponse::clear_cnt_poseidon_paddings() {
  _impl_.cnt_poseidon_paddings_ = 0u;
}
inline uint32_t ProcessBatchResponse::_internal_cnt_poseidon_paddings() const {
  return _impl_.cnt_poseidon_paddings_;
}
inline uint32_t ProcessBatchResponse::cnt_poseidon_paddings() const {
  // @@protoc_insertion_point(field_get:executor.v1.ProcessBatchResponse.cnt_poseidon_paddings)
  return _internal_cnt_poseidon_paddings();
}
inline void ProcessBatchResponse::_internal_set_cnt_poseidon_paddings(uint32_t value) {
  
  _impl_.cnt_poseidon_paddings_ = value;
}
inline void ProcessBatchResponse::set_cnt_poseidon_paddings(uint32_t value) {
  _internal_set_cnt_poseidon_paddings(value);
  // @@protoc_insertion_point(field_set:executor.v1.ProcessBatchResponse.cnt_poseidon_paddings)
}

// uint32 cnt_mem_aligns = 8;
inline void ProcessBatchResponse::clear_cnt_mem_aligns() {
  _impl_.cnt_mem_aligns_ = 0u;
}
inline uint32_t ProcessBatchResponse::_internal_cnt_mem_aligns() const {
  return _impl_.cnt_mem_aligns_;
}
inline uint32_t ProcessBatchResponse::cnt_mem_aligns() const {
  // @@protoc_insertion_point(field_get:executor.v1.ProcessBatchResponse.cnt_mem_aligns)
  return _internal_cnt_mem_aligns();
}
inline void ProcessBatchResponse::_internal_set_cnt_mem_aligns(uint32_t value) {
  
  _impl_.cnt_mem_aligns_ = value;
}
inline void ProcessBatchResponse::set_cnt_mem_aligns(uint32_t value) {
  _internal_set_cnt_mem_aligns(value);
  // @@protoc_insertion_point(field_set:executor.v1.ProcessBatchResponse.cnt_mem_aligns)
}

// uint32 cnt_arithmetics = 9;
inline void ProcessBatchResponse::clear_cnt_arithmetics() {
  _impl_.cnt_arithmetics_ = 0u;
}
inline uint32_t ProcessBatchResponse::_internal_cnt_arithmetics() const {
  return _impl_.cnt_arithmetics_;
}
inline uint32_t ProcessBatchResponse::cnt_arithmetics() const {
  // @@protoc_insertion_point(field_get:executor.v1.ProcessBatchResponse.cnt_arithmetics)
  return _internal_cnt_arithmetics();
}
inline void ProcessBatchResponse::_internal_set_cnt_arithmetics(uint32_t value) {
  
  _impl_.cnt_arithmetics_ = value;
}
inline void ProcessBatchResponse::set_cnt_arithmetics(uint32_t value) {
  _internal_set_cnt_arithmetics(value);
  // @@protoc_insertion_point(field_set:executor.v1.ProcessBatchResponse.cnt_arithmetics)
}

// uint32 cnt_binaries = 10;
inline void ProcessBatchResponse::clear_cnt_binaries() {
  _impl_.cnt_binaries_ = 0u;
}
inline uint32_t ProcessBatchResponse::_internal_cnt_binaries() const {
  return _impl_.cnt_binaries_;
}
inline uint32_t ProcessBatchResponse::cnt_binaries() const {
  // @@protoc_insertion_point(field_get:executor.v1.ProcessBatchResponse.cnt_binaries)
  return _internal_cnt_binaries();
}
inline void ProcessBatchResponse::_internal_set_cnt_binaries(uint32_t value) {
  
  _impl_.cnt_binaries_ = value;
}
inline void ProcessBatchResponse::set_cnt_binaries(uint32_t value) {
  _internal_set_cnt_binaries(value);
  // @@protoc_insertion_point(field_set:executor.v1.ProcessBatchResponse.cnt_binaries)
}

// uint32 cnt_steps = 11;
inline void ProcessBatchResponse::clear_cnt_steps() {
  _impl_.cnt_steps_ = 0u;
}
inline uint32_t ProcessBatchResponse::_internal_cnt_steps() const {
  return _impl_.cnt_steps_;
}
inline uint32_t ProcessBatchResponse::cnt_steps() const {
  // @@protoc_insertion_point(field_get:executor.v1.ProcessBatchResponse.cnt_steps)
  return _internal_cnt_steps();
}
inline void ProcessBatchResponse::_internal_set_cnt_steps(uint32_t value) {
  
  _impl_.cnt_steps_ = value;
}
inline void ProcessBatchResponse::set_cnt_steps(uint32_t value) {
  _internal_set_cnt_steps(value);
  // @@protoc_insertion_point(field_set:executor.v1.ProcessBatchResponse.cnt_steps)
}

// uint64 cumulative_gas_used = 12;
inline void ProcessBatchResponse::clear_cumulative_gas_used() {
  _impl_.cumulative_gas_used_ = uint64_t{0u};
}
inline uint64_t ProcessBatchResponse::_internal_cumulative_gas_used() const {
  return _impl_.cumulative_gas_used_;
}
inline uint64_t ProcessBatchResponse::cumulative_gas_used() const {
  // @@protoc_insertion_point(field_get:executor.v1.ProcessBatchResponse.cumulative_gas_used)
  return _internal_cumulative_gas_used();
}
inline void ProcessBatchResponse::_internal_set_cumulative_gas_used(uint64_t value) {
  
  _impl_.cumulative_gas_used_ = value;
}
inline void ProcessBatchResponse::set_cumulative_gas_used(uint64_t value) {
  _internal_set_cumulative_gas_used(value);
  // @@protoc_insertion_point(field_set:executor.v1.ProcessBatchResponse.cumulative_gas_used)
}

// repeated .executor.v1.ProcessTransactionResponse responses = 13;
inline int ProcessBatchResponse::_internal_responses_size() const {
  return _impl_.responses_.size();
}
inline int ProcessBatchResponse::responses_size() const {
  return _internal_responses_size();
}
inline void ProcessBatchResponse::clear_responses() {
  _impl_.responses_.Clear();
}
inline ::executor::v1::ProcessTransactionResponse* ProcessBatchResponse::mutable_responses(int index) {
  // @@protoc_insertion_point(field_mutable:executor.v1.ProcessBatchResponse.responses)
  return _impl_.responses_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::executor::v1::ProcessTransactionResponse >*
ProcessBatchResponse::mutable_responses() {
  // @@protoc_insertion_point(field_mutable_list:executor.v1.ProcessBatchResponse.responses)
  return &_impl_.responses_;
}
inline const ::executor::v1::ProcessTransactionResponse& ProcessBatchResponse::_internal_responses(int index) const {
  return _impl_.responses_.Get(index);
}
inline const ::executor::v1::ProcessTransactionResponse& ProcessBatchResponse::responses(int index) const {
  // @@protoc_insertion_point(field_get:executor.v1.ProcessBatchResponse.responses)
  return _internal_responses(index);
}
inline ::executor::v1::ProcessTransactionResponse* ProcessBatchResponse::_internal_add_responses() {
  return _impl_.responses_.Add();
}
inline ::executor::v1::ProcessTransactionResponse* ProcessBatchResponse::add_responses() {
  ::executor::v1::ProcessTransactionResponse* _add = _internal_add_responses();
  // @@protoc_insertion_point(field_add:executor.v1.ProcessBatchResponse.responses)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::executor::v1::ProcessTransactionResponse >&
ProcessBatchResponse::responses() const {
  // @@protoc_insertion_point(field_list:executor.v1.ProcessBatchResponse.responses)
  return _impl_.responses_;
}

// .executor.v1.ExecutorError error = 14;
inline void ProcessBatchResponse::clear_error() {
  _impl_.error_ = 0;
}
inline ::executor::v1::ExecutorError ProcessBatchResponse::_internal_error() const {
  return static_cast< ::executor::v1::ExecutorError >(_impl_.error_);
}
inline ::executor::v1::ExecutorError ProcessBatchResponse::error() const {
  // @@protoc_insertion_point(field_get:executor.v1.ProcessBatchResponse.error)
  return _internal_error();
}
inline void ProcessBatchResponse::_internal_set_error(::executor::v1::ExecutorError value) {
  
  _impl_.error_ = value;
}
inline void ProcessBatchResponse::set_error(::executor::v1::ExecutorError value) {
  _internal_set_error(value);
  // @@protoc_insertion_point(field_set:executor.v1.ProcessBatchResponse.error)
}

// map<string, .executor.v1.InfoReadWrite> read_write_addresses = 15;
inline int ProcessBatchResponse::_internal_read_write_addresses_size() const {
  return _impl_.read_write_addresses_.size();
}
inline int ProcessBatchResponse::read_write_addresses_size() const {
  return _internal_read_write_addresses_size();
}
inline void ProcessBatchResponse::clear_read_write_addresses() {
  _impl_.read_write_addresses_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::executor::v1::InfoReadWrite >&
ProcessBatchResponse::_internal_read_write_addresses() const {
  return _impl_.read_write_addresses_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::executor::v1::InfoReadWrite >&
ProcessBatchResponse::read_write_addresses() const {
  // @@protoc_insertion_point(field_map:executor.v1.ProcessBatchResponse.read_write_addresses)
  return _internal_read_write_addresses();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::executor::v1::InfoReadWrite >*
ProcessBatchResponse::_internal_mutable_read_write_addresses() {
  return _impl_.read_write_addresses_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::executor::v1::InfoReadWrite >*
ProcessBatchResponse::mutable_read_write_addresses() {
  // @@protoc_insertion_point(field_mutable_map:executor.v1.ProcessBatchResponse.read_write_addresses)
  return _internal_mutable_read_write_addresses();
}

// uint64 flush_id = 16;
inline void ProcessBatchResponse::clear_flush_id() {
  _impl_.flush_id_ = uint64_t{0u};
}
inline uint64_t ProcessBatchResponse::_internal_flush_id() const {
  return _impl_.flush_id_;
}
inline uint64_t ProcessBatchResponse::flush_id() const {
  // @@protoc_insertion_point(field_get:executor.v1.ProcessBatchResponse.flush_id)
  return _internal_flush_id();
}
inline void ProcessBatchResponse::_internal_set_flush_id(uint64_t value) {
  
  _impl_.flush_id_ = value;
}
inline void ProcessBatchResponse::set_flush_id(uint64_t value) {
  _internal_set_flush_id(value);
  // @@protoc_insertion_point(field_set:executor.v1.ProcessBatchResponse.flush_id)
}

// uint64 stored_flush_id = 17;
inline void ProcessBatchResponse::clear_stored_flush_id() {
  _impl_.stored_flush_id_ = uint64_t{0u};
}
inline uint64_t ProcessBatchResponse::_internal_stored_flush_id() const {
  return _impl_.stored_flush_id_;
}
inline uint64_t ProcessBatchResponse::stored_flush_id() const {
  // @@protoc_insertion_point(field_get:executor.v1.ProcessBatchResponse.stored_flush_id)
  return _internal_stored_flush_id();
}
inline void ProcessBatchResponse::_internal_set_stored_flush_id(uint64_t value) {
  
  _impl_.stored_flush_id_ = value;
}
inline void ProcessBatchResponse::set_stored_flush_id(uint64_t value) {
  _internal_set_stored_flush_id(value);
  // @@protoc_insertion_point(field_set:executor.v1.ProcessBatchResponse.stored_flush_id)
}

// string prover_id = 18;
inline void ProcessBatchResponse::clear_prover_id() {
  _impl_.prover_id_.ClearToEmpty();
}
inline const std::string& ProcessBatchResponse::prover_id() const {
  // @@protoc_insertion_point(field_get:executor.v1.ProcessBatchResponse.prover_id)
  return _internal_prover_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProcessBatchResponse::set_prover_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.prover_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:executor.v1.ProcessBatchResponse.prover_id)
}
inline std::string* ProcessBatchResponse::mutable_prover_id() {
  std::string* _s = _internal_mutable_prover_id();
  // @@protoc_insertion_point(field_mutable:executor.v1.ProcessBatchResponse.prover_id)
  return _s;
}
inline const std::string& ProcessBatchResponse::_internal_prover_id() const {
  return _impl_.prover_id_.Get();
}
inline void ProcessBatchResponse::_internal_set_prover_id(const std::string& value) {
  
  _impl_.prover_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ProcessBatchResponse::_internal_mutable_prover_id() {
  
  return _impl_.prover_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ProcessBatchResponse::release_prover_id() {
  // @@protoc_insertion_point(field_release:executor.v1.ProcessBatchResponse.prover_id)
  return _impl_.prover_id_.Release();
}
inline void ProcessBatchResponse::set_allocated_prover_id(std::string* prover_id) {
  if (prover_id != nullptr) {
    
  } else {
    
  }
  _impl_.prover_id_.SetAllocated(prover_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.prover_id_.IsDefault()) {
    _impl_.prover_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:executor.v1.ProcessBatchResponse.prover_id)
}

// uint64 fork_id = 19;
inline void ProcessBatchResponse::clear_fork_id() {
  _impl_.fork_id_ = uint64_t{0u};
}
inline uint64_t ProcessBatchResponse::_internal_fork_id() const {
  return _impl_.fork_id_;
}
inline uint64_t ProcessBatchResponse::fork_id() const {
  // @@protoc_insertion_point(field_get:executor.v1.ProcessBatchResponse.fork_id)
  return _internal_fork_id();
}
inline void ProcessBatchResponse::_internal_set_fork_id(uint64_t value) {
  
  _impl_.fork_id_ = value;
}
inline void ProcessBatchResponse::set_fork_id(uint64_t value) {
  _internal_set_fork_id(value);
  // @@protoc_insertion_point(field_set:executor.v1.ProcessBatchResponse.fork_id)
}

// -------------------------------------------------------------------

// GetFlushStatusResponse

// uint64 stored_flush_id = 1;
inline void GetFlushStatusResponse::clear_stored_flush_id() {
  _impl_.stored_flush_id_ = uint64_t{0u};
}
inline uint64_t GetFlushStatusResponse::_internal_stored_flush_id() const {
  return _impl_.stored_flush_id_;
}
inline uint64_t GetFlushStatusResponse::stored_flush_id() const {
  // @@protoc_insertion_point(field_get:executor.v1.GetFlushStatusResponse.stored_flush_id)
  return _internal_stored_flush_id();
}
inline void GetFlushStatusResponse::_internal_set_stored_flush_id(uint64_t value) {
  
  _impl_.stored_flush_id_ = value;
}
inline void GetFlushStatusResponse::set_stored_flush_id(uint64_t value) {
  _internal_set_stored_flush_id(value);
  // @@protoc_insertion_point(field_set:executor.v1.GetFlushStatusResponse.stored_flush_id)
}

// uint64 storing_flush_id = 2;
inline void GetFlushStatusResponse::clear_storing_flush_id() {
  _impl_.storing_flush_id_ = uint64_t{0u};
}
inline uint64_t GetFlushStatusResponse::_internal_storing_flush_id() const {
  return _impl_.storing_flush_id_;
}
inline uint64_t GetFlushStatusResponse::storing_flush_id() const {
  // @@protoc_insertion_point(field_get:executor.v1.GetFlushStatusResponse.storing_flush_id)
  return _internal_storing_flush_id();
}
inline void GetFlushStatusResponse::_internal_set_storing_flush_id(uint64_t value) {
  
  _impl_.storing_flush_id_ = value;
}
inline void GetFlushStatusResponse::set_storing_flush_id(uint64_t value) {
  _internal_set_storing_flush_id(value);
  // @@protoc_insertion_point(field_set:executor.v1.GetFlushStatusResponse.storing_flush_id)
}

// uint64 last_flush_id = 3;
inline void GetFlushStatusResponse::clear_last_flush_id() {
  _impl_.last_flush_id_ = uint64_t{0u};
}
inline uint64_t GetFlushStatusResponse::_internal_last_flush_id() const {
  return _impl_.last_flush_id_;
}
inline uint64_t GetFlushStatusResponse::last_flush_id() const {
  // @@protoc_insertion_point(field_get:executor.v1.GetFlushStatusResponse.last_flush_id)
  return _internal_last_flush_id();
}
inline void GetFlushStatusResponse::_internal_set_last_flush_id(uint64_t value) {
  
  _impl_.last_flush_id_ = value;
}
inline void GetFlushStatusResponse::set_last_flush_id(uint64_t value) {
  _internal_set_last_flush_id(value);
  // @@protoc_insertion_point(field_set:executor.v1.GetFlushStatusResponse.last_flush_id)
}

// uint64 pending_to_flush_nodes = 4;
inline void GetFlushStatusResponse::clear_pending_to_flush_nodes() {
  _impl_.pending_to_flush_nodes_ = uint64_t{0u};
}
inline uint64_t GetFlushStatusResponse::_internal_pending_to_flush_nodes() const {
  return _impl_.pending_to_flush_nodes_;
}
inline uint64_t GetFlushStatusResponse::pending_to_flush_nodes() const {
  // @@protoc_insertion_point(field_get:executor.v1.GetFlushStatusResponse.pending_to_flush_nodes)
  return _internal_pending_to_flush_nodes();
}
inline void GetFlushStatusResponse::_internal_set_pending_to_flush_nodes(uint64_t value) {
  
  _impl_.pending_to_flush_nodes_ = value;
}
inline void GetFlushStatusResponse::set_pending_to_flush_nodes(uint64_t value) {
  _internal_set_pending_to_flush_nodes(value);
  // @@protoc_insertion_point(field_set:executor.v1.GetFlushStatusResponse.pending_to_flush_nodes)
}

// uint64 pending_to_flush_program = 5;
inline void GetFlushStatusResponse::clear_pending_to_flush_program() {
  _impl_.pending_to_flush_program_ = uint64_t{0u};
}
inline uint64_t GetFlushStatusResponse::_internal_pending_to_flush_program() const {
  return _impl_.pending_to_flush_program_;
}
inline uint64_t GetFlushStatusResponse::pending_to_flush_program() const {
  // @@protoc_insertion_point(field_get:executor.v1.GetFlushStatusResponse.pending_to_flush_program)
  return _internal_pending_to_flush_program();
}
inline void GetFlushStatusResponse::_internal_set_pending_to_flush_program(uint64_t value) {
  
  _impl_.pending_to_flush_program_ = value;
}
inline void GetFlushStatusResponse::set_pending_to_flush_program(uint64_t value) {
  _internal_set_pending_to_flush_program(value);
  // @@protoc_insertion_point(field_set:executor.v1.GetFlushStatusResponse.pending_to_flush_program)
}

// uint64 storing_nodes = 6;
inline void GetFlushStatusResponse::clear_storing_nodes() {
  _impl_.storing_nodes_ = uint64_t{0u};
}
inline uint64_t GetFlushStatusResponse::_internal_storing_nodes() const {
  return _impl_.storing_nodes_;
}
inline uint64_t GetFlushStatusResponse::storing_nodes() const {
  // @@protoc_insertion_point(field_get:executor.v1.GetFlushStatusResponse.storing_nodes)
  return _internal_storing_nodes();
}
inline void GetFlushStatusResponse::_internal_set_storing_nodes(uint64_t value) {
  
  _impl_.storing_nodes_ = value;
}
inline void GetFlushStatusResponse::set_storing_nodes(uint64_t value) {
  _internal_set_storing_nodes(value);
  // @@protoc_insertion_point(field_set:executor.v1.GetFlushStatusResponse.storing_nodes)
}

// uint64 storing_program = 7;
inline void GetFlushStatusResponse::clear_storing_program() {
  _impl_.storing_program_ = uint64_t{0u};
}
inline uint64_t GetFlushStatusResponse::_internal_storing_program() const {
  return _impl_.storing_program_;
}
inline uint64_t GetFlushStatusResponse::storing_program() const {
  // @@protoc_insertion_point(field_get:executor.v1.GetFlushStatusResponse.storing_program)
  return _internal_storing_program();
}
inline void GetFlushStatusResponse::_internal_set_storing_program(uint64_t value) {
  
  _impl_.storing_program_ = value;
}
inline void GetFlushStatusResponse::set_storing_program(uint64_t value) {
  _internal_set_storing_program(value);
  // @@protoc_insertion_point(field_set:executor.v1.GetFlushStatusResponse.storing_program)
}

// string prover_id = 8;
inline void GetFlushStatusResponse::clear_prover_id() {
  _impl_.prover_id_.ClearToEmpty();
}
inline const std::string& GetFlushStatusResponse::prover_id() const {
  // @@protoc_insertion_point(field_get:executor.v1.GetFlushStatusResponse.prover_id)
  return _internal_prover_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetFlushStatusResponse::set_prover_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.prover_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:executor.v1.GetFlushStatusResponse.prover_id)
}
inline std::string* GetFlushStatusResponse::mutable_prover_id() {
  std::string* _s = _internal_mutable_prover_id();
  // @@protoc_insertion_point(field_mutable:executor.v1.GetFlushStatusResponse.prover_id)
  return _s;
}
inline const std::string& GetFlushStatusResponse::_internal_prover_id() const {
  return _impl_.prover_id_.Get();
}
inline void GetFlushStatusResponse::_internal_set_prover_id(const std::string& value) {
  
  _impl_.prover_id_.Set(value, GetArenaForAllocation());
}
inline std::string* GetFlushStatusResponse::_internal_mutable_prover_id() {
  
  return _impl_.prover_id_.Mutable(GetArenaForAllocation());
}
inline std::string* GetFlushStatusResponse::release_prover_id() {
  // @@protoc_insertion_point(field_release:executor.v1.GetFlushStatusResponse.prover_id)
  return _impl_.prover_id_.Release();
}
inline void GetFlushStatusResponse::set_allocated_prover_id(std::string* prover_id) {
  if (prover_id != nullptr) {
    
  } else {
    
  }
  _impl_.prover_id_.SetAllocated(prover_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.prover_id_.IsDefault()) {
    _impl_.prover_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:executor.v1.GetFlushStatusResponse.prover_id)
}

// -------------------------------------------------------------------

// TraceConfig

// uint32 disable_storage = 1;
inline void TraceConfig::clear_disable_storage() {
  _impl_.disable_storage_ = 0u;
}
inline uint32_t TraceConfig::_internal_disable_storage() const {
  return _impl_.disable_storage_;
}
inline uint32_t TraceConfig::disable_storage() const {
  // @@protoc_insertion_point(field_get:executor.v1.TraceConfig.disable_storage)
  return _internal_disable_storage();
}
inline void TraceConfig::_internal_set_disable_storage(uint32_t value) {
  
  _impl_.disable_storage_ = value;
}
inline void TraceConfig::set_disable_storage(uint32_t value) {
  _internal_set_disable_storage(value);
  // @@protoc_insertion_point(field_set:executor.v1.TraceConfig.disable_storage)
}

// uint32 disable_stack = 2;
inline void TraceConfig::clear_disable_stack() {
  _impl_.disable_stack_ = 0u;
}
inline uint32_t TraceConfig::_internal_disable_stack() const {
  return _impl_.disable_stack_;
}
inline uint32_t TraceConfig::disable_stack() const {
  // @@protoc_insertion_point(field_get:executor.v1.TraceConfig.disable_stack)
  return _internal_disable_stack();
}
inline void TraceConfig::_internal_set_disable_stack(uint32_t value) {
  
  _impl_.disable_stack_ = value;
}
inline void TraceConfig::set_disable_stack(uint32_t value) {
  _internal_set_disable_stack(value);
  // @@protoc_insertion_point(field_set:executor.v1.TraceConfig.disable_stack)
}

// uint32 enable_memory = 3;
inline void TraceConfig::clear_enable_memory() {
  _impl_.enable_memory_ = 0u;
}
inline uint32_t TraceConfig::_internal_enable_memory() const {
  return _impl_.enable_memory_;
}
inline uint32_t TraceConfig::enable_memory() const {
  // @@protoc_insertion_point(field_get:executor.v1.TraceConfig.enable_memory)
  return _internal_enable_memory();
}
inline void TraceConfig::_internal_set_enable_memory(uint32_t value) {
  
  _impl_.enable_memory_ = value;
}
inline void TraceConfig::set_enable_memory(uint32_t value) {
  _internal_set_enable_memory(value);
  // @@protoc_insertion_point(field_set:executor.v1.TraceConfig.enable_memory)
}

// uint32 enable_return_data = 4;
inline void TraceConfig::clear_enable_return_data() {
  _impl_.enable_return_data_ = 0u;
}
inline uint32_t TraceConfig::_internal_enable_return_data() const {
  return _impl_.enable_return_data_;
}
inline uint32_t TraceConfig::enable_return_data() const {
  // @@protoc_insertion_point(field_get:executor.v1.TraceConfig.enable_return_data)
  return _internal_enable_return_data();
}
inline void TraceConfig::_internal_set_enable_return_data(uint32_t value) {
  
  _impl_.enable_return_data_ = value;
}
inline void TraceConfig::set_enable_return_data(uint32_t value) {
  _internal_set_enable_return_data(value);
  // @@protoc_insertion_point(field_set:executor.v1.TraceConfig.enable_return_data)
}

// bytes tx_hash_to_generate_full_trace = 5;
inline void TraceConfig::clear_tx_hash_to_generate_full_trace() {
  _impl_.tx_hash_to_generate_full_trace_.ClearToEmpty();
}
inline const std::string& TraceConfig::tx_hash_to_generate_full_trace() const {
  // @@protoc_insertion_point(field_get:executor.v1.TraceConfig.tx_hash_to_generate_full_trace)
  return _internal_tx_hash_to_generate_full_trace();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TraceConfig::set_tx_hash_to_generate_full_trace(ArgT0&& arg0, ArgT... args) {
 
 _impl_.tx_hash_to_generate_full_trace_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:executor.v1.TraceConfig.tx_hash_to_generate_full_trace)
}
inline std::string* TraceConfig::mutable_tx_hash_to_generate_full_trace() {
  std::string* _s = _internal_mutable_tx_hash_to_generate_full_trace();
  // @@protoc_insertion_point(field_mutable:executor.v1.TraceConfig.tx_hash_to_generate_full_trace)
  return _s;
}
inline const std::string& TraceConfig::_internal_tx_hash_to_generate_full_trace() const {
  return _impl_.tx_hash_to_generate_full_trace_.Get();
}
inline void TraceConfig::_internal_set_tx_hash_to_generate_full_trace(const std::string& value) {
  
  _impl_.tx_hash_to_generate_full_trace_.Set(value, GetArenaForAllocation());
}
inline std::string* TraceConfig::_internal_mutable_tx_hash_to_generate_full_trace() {
  
  return _impl_.tx_hash_to_generate_full_trace_.Mutable(GetArenaForAllocation());
}
inline std::string* TraceConfig::release_tx_hash_to_generate_full_trace() {
  // @@protoc_insertion_point(field_release:executor.v1.TraceConfig.tx_hash_to_generate_full_trace)
  return _impl_.tx_hash_to_generate_full_trace_.Release();
}
inline void TraceConfig::set_allocated_tx_hash_to_generate_full_trace(std::string* tx_hash_to_generate_full_trace) {
  if (tx_hash_to_generate_full_trace != nullptr) {
    
  } else {
    
  }
  _impl_.tx_hash_to_generate_full_trace_.SetAllocated(tx_hash_to_generate_full_trace, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.tx_hash_to_generate_full_trace_.IsDefault()) {
    _impl_.tx_hash_to_generate_full_trace_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:executor.v1.TraceConfig.tx_hash_to_generate_full_trace)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// OverrideAccount

// bytes balance = 1;
inline void OverrideAccount::clear_balance() {
  _impl_.balance_.ClearToEmpty();
}
inline const std::string& OverrideAccount::balance() const {
  // @@protoc_insertion_point(field_get:executor.v1.OverrideAccount.balance)
  return _internal_balance();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OverrideAccount::set_balance(ArgT0&& arg0, ArgT... args) {
 
 _impl_.balance_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:executor.v1.OverrideAccount.balance)
}
inline std::string* OverrideAccount::mutable_balance() {
  std::string* _s = _internal_mutable_balance();
  // @@protoc_insertion_point(field_mutable:executor.v1.OverrideAccount.balance)
  return _s;
}
inline const std::string& OverrideAccount::_internal_balance() const {
  return _impl_.balance_.Get();
}
inline void OverrideAccount::_internal_set_balance(const std::string& value) {
  
  _impl_.balance_.Set(value, GetArenaForAllocation());
}
inline std::string* OverrideAccount::_internal_mutable_balance() {
  
  return _impl_.balance_.Mutable(GetArenaForAllocation());
}
inline std::string* OverrideAccount::release_balance() {
  // @@protoc_insertion_point(field_release:executor.v1.OverrideAccount.balance)
  return _impl_.balance_.Release();
}
inline void OverrideAccount::set_allocated_balance(std::string* balance) {
  if (balance != nullptr) {
    
  } else {
    
  }
  _impl_.balance_.SetAllocated(balance, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.balance_.IsDefault()) {
    _impl_.balance_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:executor.v1.OverrideAccount.balance)
}

// uint64 nonce = 2;
inline void OverrideAccount::clear_nonce() {
  _impl_.nonce_ = uint64_t{0u};
}
inline uint64_t OverrideAccount::_internal_nonce() const {
  return _impl_.nonce_;
}
inline uint64_t OverrideAccount::nonce() const {
  // @@protoc_insertion_point(field_get:executor.v1.OverrideAccount.nonce)
  return _internal_nonce();
}
inline void OverrideAccount::_internal_set_nonce(uint64_t value) {
  
  _impl_.nonce_ = value;
}
inline void OverrideAccount::set_nonce(uint64_t value) {
  _internal_set_nonce(value);
  // @@protoc_insertion_point(field_set:executor.v1.OverrideAccount.nonce)
}

// bytes code = 3;
inline void OverrideAccount::clear_code() {
  _impl_.code_.ClearToEmpty();
}
inline const std::string& OverrideAccount::code() const {
  // @@protoc_insertion_point(field_get:executor.v1.OverrideAccount.code)
  return _internal_code();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OverrideAccount::set_code(ArgT0&& arg0, ArgT... args) {
 
 _impl_.code_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:executor.v1.OverrideAccount.code)
}
inline std::string* OverrideAccount::mutable_code() {
  std::string* _s = _internal_mutable_code();
  // @@protoc_insertion_point(field_mutable:executor.v1.OverrideAccount.code)
  return _s;
}
inline const std::string& OverrideAccount::_internal_code() const {
  return _impl_.code_.Get();
}
inline void OverrideAccount::_internal_set_code(const std::string& value) {
  
  _impl_.code_.Set(value, GetArenaForAllocation());
}
inline std::string* OverrideAccount::_internal_mutable_code() {
  
  return _impl_.code_.Mutable(GetArenaForAllocation());
}
inline std::string* OverrideAccount::release_code() {
  // @@protoc_insertion_point(field_release:executor.v1.OverrideAccount.code)
  return _impl_.code_.Release();
}
inline void OverrideAccount::set_allocated_code(std::string* code) {
  if (code != nullptr) {
    
  } else {
    
  }
  _impl_.code_.SetAllocated(code, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.code_.IsDefault()) {
    _impl_.code_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:executor.v1.OverrideAccount.code)
}

// map<string, string> state = 4;
inline int OverrideAccount::_internal_state_size() const {
  return _impl_.state_.size();
}
inline int OverrideAccount::state_size() const {
  return _internal_state_size();
}
inline void OverrideAccount::clear_state() {
  _impl_.state_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
OverrideAccount::_internal_state() const {
  return _impl_.state_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
OverrideAccount::state() const {
  // @@protoc_insertion_point(field_map:executor.v1.OverrideAccount.state)
  return _internal_state();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
OverrideAccount::_internal_mutable_state() {
  return _impl_.state_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
OverrideAccount::mutable_state() {
  // @@protoc_insertion_point(field_mutable_map:executor.v1.OverrideAccount.state)
  return _internal_mutable_state();
}

// map<string, string> state_diff = 5;
inline int OverrideAccount::_internal_state_diff_size() const {
  return _impl_.state_diff_.size();
}
inline int OverrideAccount::state_diff_size() const {
  return _internal_state_diff_size();
}
inline void OverrideAccount::clear_state_diff() {
  _impl_.state_diff_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
OverrideAccount::_internal_state_diff() const {
  return _impl_.state_diff_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
OverrideAccount::state_diff() const {
  // @@protoc_insertion_point(field_map:executor.v1.OverrideAccount.state_diff)
  return _internal_state_diff();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
OverrideAccount::_internal_mutable_state_diff() {
  return _impl_.state_diff_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
OverrideAccount::mutable_state_diff() {
  // @@protoc_insertion_point(field_mutable_map:executor.v1.OverrideAccount.state_diff)
  return _internal_mutable_state_diff();
}

// -------------------------------------------------------------------

// InfoReadWrite

// string nonce = 1;
inline void InfoReadWrite::clear_nonce() {
  _impl_.nonce_.ClearToEmpty();
}
inline const std::string& InfoReadWrite::nonce() const {
  // @@protoc_insertion_point(field_get:executor.v1.InfoReadWrite.nonce)
  return _internal_nonce();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InfoReadWrite::set_nonce(ArgT0&& arg0, ArgT... args) {
 
 _impl_.nonce_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:executor.v1.InfoReadWrite.nonce)
}
inline std::string* InfoReadWrite::mutable_nonce() {
  std::string* _s = _internal_mutable_nonce();
  // @@protoc_insertion_point(field_mutable:executor.v1.InfoReadWrite.nonce)
  return _s;
}
inline const std::string& InfoReadWrite::_internal_nonce() const {
  return _impl_.nonce_.Get();
}
inline void InfoReadWrite::_internal_set_nonce(const std::string& value) {
  
  _impl_.nonce_.Set(value, GetArenaForAllocation());
}
inline std::string* InfoReadWrite::_internal_mutable_nonce() {
  
  return _impl_.nonce_.Mutable(GetArenaForAllocation());
}
inline std::string* InfoReadWrite::release_nonce() {
  // @@protoc_insertion_point(field_release:executor.v1.InfoReadWrite.nonce)
  return _impl_.nonce_.Release();
}
inline void InfoReadWrite::set_allocated_nonce(std::string* nonce) {
  if (nonce != nullptr) {
    
  } else {
    
  }
  _impl_.nonce_.SetAllocated(nonce, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.nonce_.IsDefault()) {
    _impl_.nonce_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:executor.v1.InfoReadWrite.nonce)
}

// string balance = 2;
inline void InfoReadWrite::clear_balance() {
  _impl_.balance_.ClearToEmpty();
}
inline const std::string& InfoReadWrite::balance() const {
  // @@protoc_insertion_point(field_get:executor.v1.InfoReadWrite.balance)
  return _internal_balance();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InfoReadWrite::set_balance(ArgT0&& arg0, ArgT... args) {
 
 _impl_.balance_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:executor.v1.InfoReadWrite.balance)
}
inline std::string* InfoReadWrite::mutable_balance() {
  std::string* _s = _internal_mutable_balance();
  // @@protoc_insertion_point(field_mutable:executor.v1.InfoReadWrite.balance)
  return _s;
}
inline const std::string& InfoReadWrite::_internal_balance() const {
  return _impl_.balance_.Get();
}
inline void InfoReadWrite::_internal_set_balance(const std::string& value) {
  
  _impl_.balance_.Set(value, GetArenaForAllocation());
}
inline std::string* InfoReadWrite::_internal_mutable_balance() {
  
  return _impl_.balance_.Mutable(GetArenaForAllocation());
}
inline std::string* InfoReadWrite::release_balance() {
  // @@protoc_insertion_point(field_release:executor.v1.InfoReadWrite.balance)
  return _impl_.balance_.Release();
}
inline void InfoReadWrite::set_allocated_balance(std::string* balance) {
  if (balance != nullptr) {
    
  } else {
    
  }
  _impl_.balance_.SetAllocated(balance, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.balance_.IsDefault()) {
    _impl_.balance_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:executor.v1.InfoReadWrite.balance)
}

// -------------------------------------------------------------------

// FullTrace

// .executor.v1.TransactionContext context = 1;
inline bool FullTrace::_internal_has_context() const {
  return this != internal_default_instance() && _impl_.context_ != nullptr;
}
inline bool FullTrace::has_context() const {
  return _internal_has_context();
}
inline void FullTrace::clear_context() {
  if (GetArenaForAllocation() == nullptr && _impl_.context_ != nullptr) {
    delete _impl_.context_;
  }
  _impl_.context_ = nullptr;
}
inline const ::executor::v1::TransactionContext& FullTrace::_internal_context() const {
  const ::executor::v1::TransactionContext* p = _impl_.context_;
  return p != nullptr ? *p : reinterpret_cast<const ::executor::v1::TransactionContext&>(
      ::executor::v1::_TransactionContext_default_instance_);
}
inline const ::executor::v1::TransactionContext& FullTrace::context() const {
  // @@protoc_insertion_point(field_get:executor.v1.FullTrace.context)
  return _internal_context();
}
inline void FullTrace::unsafe_arena_set_allocated_context(
    ::executor::v1::TransactionContext* context) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.context_);
  }
  _impl_.context_ = context;
  if (context) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:executor.v1.FullTrace.context)
}
inline ::executor::v1::TransactionContext* FullTrace::release_context() {
  
  ::executor::v1::TransactionContext* temp = _impl_.context_;
  _impl_.context_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::executor::v1::TransactionContext* FullTrace::unsafe_arena_release_context() {
  // @@protoc_insertion_point(field_release:executor.v1.FullTrace.context)
  
  ::executor::v1::TransactionContext* temp = _impl_.context_;
  _impl_.context_ = nullptr;
  return temp;
}
inline ::executor::v1::TransactionContext* FullTrace::_internal_mutable_context() {
  
  if (_impl_.context_ == nullptr) {
    auto* p = CreateMaybeMessage<::executor::v1::TransactionContext>(GetArenaForAllocation());
    _impl_.context_ = p;
  }
  return _impl_.context_;
}
inline ::executor::v1::TransactionContext* FullTrace::mutable_context() {
  ::executor::v1::TransactionContext* _msg = _internal_mutable_context();
  // @@protoc_insertion_point(field_mutable:executor.v1.FullTrace.context)
  return _msg;
}
inline void FullTrace::set_allocated_context(::executor::v1::TransactionContext* context) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.context_;
  }
  if (context) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(context);
    if (message_arena != submessage_arena) {
      context = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, context, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.context_ = context;
  // @@protoc_insertion_point(field_set_allocated:executor.v1.FullTrace.context)
}

// repeated .executor.v1.TransactionStep steps = 2;
inline int FullTrace::_internal_steps_size() const {
  return _impl_.steps_.size();
}
inline int FullTrace::steps_size() const {
  return _internal_steps_size();
}
inline void FullTrace::clear_steps() {
  _impl_.steps_.Clear();
}
inline ::executor::v1::TransactionStep* FullTrace::mutable_steps(int index) {
  // @@protoc_insertion_point(field_mutable:executor.v1.FullTrace.steps)
  return _impl_.steps_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::executor::v1::TransactionStep >*
FullTrace::mutable_steps() {
  // @@protoc_insertion_point(field_mutable_list:executor.v1.FullTrace.steps)
  return &_impl_.steps_;
}
inline const ::executor::v1::TransactionStep& FullTrace::_internal_steps(int index) const {
  return _impl_.steps_.Get(index);
}
inline const ::executor::v1::TransactionStep& FullTrace::steps(int index) const {
  // @@protoc_insertion_point(field_get:executor.v1.FullTrace.steps)
  return _internal_steps(index);
}
inline ::executor::v1::TransactionStep* FullTrace::_internal_add_steps() {
  return _impl_.steps_.Add();
}
inline ::executor::v1::TransactionStep* FullTrace::add_steps() {
  ::executor::v1::TransactionStep* _add = _internal_add_steps();
  // @@protoc_insertion_point(field_add:executor.v1.FullTrace.steps)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::executor::v1::TransactionStep >&
FullTrace::steps() const {
  // @@protoc_insertion_point(field_list:executor.v1.FullTrace.steps)
  return _impl_.steps_;
}

// -------------------------------------------------------------------

// TransactionContext

// string type = 1;
inline void TransactionContext::clear_type() {
  _impl_.type_.ClearToEmpty();
}
inline const std::string& TransactionContext::type() const {
  // @@protoc_insertion_point(field_get:executor.v1.TransactionContext.type)
  return _internal_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TransactionContext::set_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:executor.v1.TransactionContext.type)
}
inline std::string* TransactionContext::mutable_type() {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:executor.v1.TransactionContext.type)
  return _s;
}
inline const std::string& TransactionContext::_internal_type() const {
  return _impl_.type_.Get();
}
inline void TransactionContext::_internal_set_type(const std::string& value) {
  
  _impl_.type_.Set(value, GetArenaForAllocation());
}
inline std::string* TransactionContext::_internal_mutable_type() {
  
  return _impl_.type_.Mutable(GetArenaForAllocation());
}
inline std::string* TransactionContext::release_type() {
  // @@protoc_insertion_point(field_release:executor.v1.TransactionContext.type)
  return _impl_.type_.Release();
}
inline void TransactionContext::set_allocated_type(std::string* type) {
  if (type != nullptr) {
    
  } else {
    
  }
  _impl_.type_.SetAllocated(type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.type_.IsDefault()) {
    _impl_.type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:executor.v1.TransactionContext.type)
}

// string from = 2;
inline void TransactionContext::clear_from() {
  _impl_.from_.ClearToEmpty();
}
inline const std::string& TransactionContext::from() const {
  // @@protoc_insertion_point(field_get:executor.v1.TransactionContext.from)
  return _internal_from();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TransactionContext::set_from(ArgT0&& arg0, ArgT... args) {
 
 _impl_.from_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:executor.v1.TransactionContext.from)
}
inline std::string* TransactionContext::mutable_from() {
  std::string* _s = _internal_mutable_from();
  // @@protoc_insertion_point(field_mutable:executor.v1.TransactionContext.from)
  return _s;
}
inline const std::string& TransactionContext::_internal_from() const {
  return _impl_.from_.Get();
}
inline void TransactionContext::_internal_set_from(const std::string& value) {
  
  _impl_.from_.Set(value, GetArenaForAllocation());
}
inline std::string* TransactionContext::_internal_mutable_from() {
  
  return _impl_.from_.Mutable(GetArenaForAllocation());
}
inline std::string* TransactionContext::release_from() {
  // @@protoc_insertion_point(field_release:executor.v1.TransactionContext.from)
  return _impl_.from_.Release();
}
inline void TransactionContext::set_allocated_from(std::string* from) {
  if (from != nullptr) {
    
  } else {
    
  }
  _impl_.from_.SetAllocated(from, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.from_.IsDefault()) {
    _impl_.from_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:executor.v1.TransactionContext.from)
}

// string to = 3;
inline void TransactionContext::clear_to() {
  _impl_.to_.ClearToEmpty();
}
inline const std::string& TransactionContext::to() const {
  // @@protoc_insertion_point(field_get:executor.v1.TransactionContext.to)
  return _internal_to();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TransactionContext::set_to(ArgT0&& arg0, ArgT... args) {
 
 _impl_.to_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:executor.v1.TransactionContext.to)
}
inline std::string* TransactionContext::mutable_to() {
  std::string* _s = _internal_mutable_to();
  // @@protoc_insertion_point(field_mutable:executor.v1.TransactionContext.to)
  return _s;
}
inline const std::string& TransactionContext::_internal_to() const {
  return _impl_.to_.Get();
}
inline void TransactionContext::_internal_set_to(const std::string& value) {
  
  _impl_.to_.Set(value, GetArenaForAllocation());
}
inline std::string* TransactionContext::_internal_mutable_to() {
  
  return _impl_.to_.Mutable(GetArenaForAllocation());
}
inline std::string* TransactionContext::release_to() {
  // @@protoc_insertion_point(field_release:executor.v1.TransactionContext.to)
  return _impl_.to_.Release();
}
inline void TransactionContext::set_allocated_to(std::string* to) {
  if (to != nullptr) {
    
  } else {
    
  }
  _impl_.to_.SetAllocated(to, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.to_.IsDefault()) {
    _impl_.to_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:executor.v1.TransactionContext.to)
}

// bytes data = 4;
inline void TransactionContext::clear_data() {
  _impl_.data_.ClearToEmpty();
}
inline const std::string& TransactionContext::data() const {
  // @@protoc_insertion_point(field_get:executor.v1.TransactionContext.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TransactionContext::set_data(ArgT0&& arg0, ArgT... args) {
 
 _impl_.data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:executor.v1.TransactionContext.data)
}
inline std::string* TransactionContext::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:executor.v1.TransactionContext.data)
  return _s;
}
inline const std::string& TransactionContext::_internal_data() const {
  return _impl_.data_.Get();
}
inline void TransactionContext::_internal_set_data(const std::string& value) {
  
  _impl_.data_.Set(value, GetArenaForAllocation());
}
inline std::string* TransactionContext::_internal_mutable_data() {
  
  return _impl_.data_.Mutable(GetArenaForAllocation());
}
inline std::string* TransactionContext::release_data() {
  // @@protoc_insertion_point(field_release:executor.v1.TransactionContext.data)
  return _impl_.data_.Release();
}
inline void TransactionContext::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  _impl_.data_.SetAllocated(data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data_.IsDefault()) {
    _impl_.data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:executor.v1.TransactionContext.data)
}

// uint64 gas = 5;
inline void TransactionContext::clear_gas() {
  _impl_.gas_ = uint64_t{0u};
}
inline uint64_t TransactionContext::_internal_gas() const {
  return _impl_.gas_;
}
inline uint64_t TransactionContext::gas() const {
  // @@protoc_insertion_point(field_get:executor.v1.TransactionContext.gas)
  return _internal_gas();
}
inline void TransactionContext::_internal_set_gas(uint64_t value) {
  
  _impl_.gas_ = value;
}
inline void TransactionContext::set_gas(uint64_t value) {
  _internal_set_gas(value);
  // @@protoc_insertion_point(field_set:executor.v1.TransactionContext.gas)
}

// string value = 6;
inline void TransactionContext::clear_value() {
  _impl_.value_.ClearToEmpty();
}
inline const std::string& TransactionContext::value() const {
  // @@protoc_insertion_point(field_get:executor.v1.TransactionContext.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TransactionContext::set_value(ArgT0&& arg0, ArgT... args) {
 
 _impl_.value_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:executor.v1.TransactionContext.value)
}
inline std::string* TransactionContext::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:executor.v1.TransactionContext.value)
  return _s;
}
inline const std::string& TransactionContext::_internal_value() const {
  return _impl_.value_.Get();
}
inline void TransactionContext::_internal_set_value(const std::string& value) {
  
  _impl_.value_.Set(value, GetArenaForAllocation());
}
inline std::string* TransactionContext::_internal_mutable_value() {
  
  return _impl_.value_.Mutable(GetArenaForAllocation());
}
inline std::string* TransactionContext::release_value() {
  // @@protoc_insertion_point(field_release:executor.v1.TransactionContext.value)
  return _impl_.value_.Release();
}
inline void TransactionContext::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  _impl_.value_.SetAllocated(value, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.value_.IsDefault()) {
    _impl_.value_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:executor.v1.TransactionContext.value)
}

// bytes batch = 7;
inline void TransactionContext::clear_batch() {
  _impl_.batch_.ClearToEmpty();
}
inline const std::string& TransactionContext::batch() const {
  // @@protoc_insertion_point(field_get:executor.v1.TransactionContext.batch)
  return _internal_batch();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TransactionContext::set_batch(ArgT0&& arg0, ArgT... args) {
 
 _impl_.batch_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:executor.v1.TransactionContext.batch)
}
inline std::string* TransactionContext::mutable_batch() {
  std::string* _s = _internal_mutable_batch();
  // @@protoc_insertion_point(field_mutable:executor.v1.TransactionContext.batch)
  return _s;
}
inline const std::string& TransactionContext::_internal_batch() const {
  return _impl_.batch_.Get();
}
inline void TransactionContext::_internal_set_batch(const std::string& value) {
  
  _impl_.batch_.Set(value, GetArenaForAllocation());
}
inline std::string* TransactionContext::_internal_mutable_batch() {
  
  return _impl_.batch_.Mutable(GetArenaForAllocation());
}
inline std::string* TransactionContext::release_batch() {
  // @@protoc_insertion_point(field_release:executor.v1.TransactionContext.batch)
  return _impl_.batch_.Release();
}
inline void TransactionContext::set_allocated_batch(std::string* batch) {
  if (batch != nullptr) {
    
  } else {
    
  }
  _impl_.batch_.SetAllocated(batch, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.batch_.IsDefault()) {
    _impl_.batch_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:executor.v1.TransactionContext.batch)
}

// bytes output = 8;
inline void TransactionContext::clear_output() {
  _impl_.output_.ClearToEmpty();
}
inline const std::string& TransactionContext::output() const {
  // @@protoc_insertion_point(field_get:executor.v1.TransactionContext.output)
  return _internal_output();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TransactionContext::set_output(ArgT0&& arg0, ArgT... args) {
 
 _impl_.output_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:executor.v1.TransactionContext.output)
}
inline std::string* TransactionContext::mutable_output() {
  std::string* _s = _internal_mutable_output();
  // @@protoc_insertion_point(field_mutable:executor.v1.TransactionContext.output)
  return _s;
}
inline const std::string& TransactionContext::_internal_output() const {
  return _impl_.output_.Get();
}
inline void TransactionContext::_internal_set_output(const std::string& value) {
  
  _impl_.output_.Set(value, GetArenaForAllocation());
}
inline std::string* TransactionContext::_internal_mutable_output() {
  
  return _impl_.output_.Mutable(GetArenaForAllocation());
}
inline std::string* TransactionContext::release_output() {
  // @@protoc_insertion_point(field_release:executor.v1.TransactionContext.output)
  return _impl_.output_.Release();
}
inline void TransactionContext::set_allocated_output(std::string* output) {
  if (output != nullptr) {
    
  } else {
    
  }
  _impl_.output_.SetAllocated(output, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.output_.IsDefault()) {
    _impl_.output_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:executor.v1.TransactionContext.output)
}

// uint64 gas_used = 9;
inline void TransactionContext::clear_gas_used() {
  _impl_.gas_used_ = uint64_t{0u};
}
inline uint64_t TransactionContext::_internal_gas_used() const {
  return _impl_.gas_used_;
}
inline uint64_t TransactionContext::gas_used() const {
  // @@protoc_insertion_point(field_get:executor.v1.TransactionContext.gas_used)
  return _internal_gas_used();
}
inline void TransactionContext::_internal_set_gas_used(uint64_t value) {
  
  _impl_.gas_used_ = value;
}
inline void TransactionContext::set_gas_used(uint64_t value) {
  _internal_set_gas_used(value);
  // @@protoc_insertion_point(field_set:executor.v1.TransactionContext.gas_used)
}

// string gas_price = 10;
inline void TransactionContext::clear_gas_price() {
  _impl_.gas_price_.ClearToEmpty();
}
inline const std::string& TransactionContext::gas_price() const {
  // @@protoc_insertion_point(field_get:executor.v1.TransactionContext.gas_price)
  return _internal_gas_price();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TransactionContext::set_gas_price(ArgT0&& arg0, ArgT... args) {
 
 _impl_.gas_price_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:executor.v1.TransactionContext.gas_price)
}
inline std::string* TransactionContext::mutable_gas_price() {
  std::string* _s = _internal_mutable_gas_price();
  // @@protoc_insertion_point(field_mutable:executor.v1.TransactionContext.gas_price)
  return _s;
}
inline const std::string& TransactionContext::_internal_gas_price() const {
  return _impl_.gas_price_.Get();
}
inline void TransactionContext::_internal_set_gas_price(const std::string& value) {
  
  _impl_.gas_price_.Set(value, GetArenaForAllocation());
}
inline std::string* TransactionContext::_internal_mutable_gas_price() {
  
  return _impl_.gas_price_.Mutable(GetArenaForAllocation());
}
inline std::string* TransactionContext::release_gas_price() {
  // @@protoc_insertion_point(field_release:executor.v1.TransactionContext.gas_price)
  return _impl_.gas_price_.Release();
}
inline void TransactionContext::set_allocated_gas_price(std::string* gas_price) {
  if (gas_price != nullptr) {
    
  } else {
    
  }
  _impl_.gas_price_.SetAllocated(gas_price, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.gas_price_.IsDefault()) {
    _impl_.gas_price_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:executor.v1.TransactionContext.gas_price)
}

// uint32 execution_time = 11;
inline void TransactionContext::clear_execution_time() {
  _impl_.execution_time_ = 0u;
}
inline uint32_t TransactionContext::_internal_execution_time() const {
  return _impl_.execution_time_;
}
inline uint32_t TransactionContext::execution_time() const {
  // @@protoc_insertion_point(field_get:executor.v1.TransactionContext.execution_time)
  return _internal_execution_time();
}
inline void TransactionContext::_internal_set_execution_time(uint32_t value) {
  
  _impl_.execution_time_ = value;
}
inline void TransactionContext::set_execution_time(uint32_t value) {
  _internal_set_execution_time(value);
  // @@protoc_insertion_point(field_set:executor.v1.TransactionContext.execution_time)
}

// bytes old_state_root = 12;
inline void TransactionContext::clear_old_state_root() {
  _impl_.old_state_root_.ClearToEmpty();
}
inline const std::string& TransactionContext::old_state_root() const {
  // @@protoc_insertion_point(field_get:executor.v1.TransactionContext.old_state_root)
  return _internal_old_state_root();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TransactionContext::set_old_state_root(ArgT0&& arg0, ArgT... args) {
 
 _impl_.old_state_root_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:executor.v1.TransactionContext.old_state_root)
}
inline std::string* TransactionContext::mutable_old_state_root() {
  std::string* _s = _internal_mutable_old_state_root();
  // @@protoc_insertion_point(field_mutable:executor.v1.TransactionContext.old_state_root)
  return _s;
}
inline const std::string& TransactionContext::_internal_old_state_root() const {
  return _impl_.old_state_root_.Get();
}
inline void TransactionContext::_internal_set_old_state_root(const std::string& value) {
  
  _impl_.old_state_root_.Set(value, GetArenaForAllocation());
}
inline std::string* TransactionContext::_internal_mutable_old_state_root() {
  
  return _impl_.old_state_root_.Mutable(GetArenaForAllocation());
}
inline std::string* TransactionContext::release_old_state_root() {
  // @@protoc_insertion_point(field_release:executor.v1.TransactionContext.old_state_root)
  return _impl_.old_state_root_.Release();
}
inline void TransactionContext::set_allocated_old_state_root(std::string* old_state_root) {
  if (old_state_root != nullptr) {
    
  } else {
    
  }
  _impl_.old_state_root_.SetAllocated(old_state_root, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.old_state_root_.IsDefault()) {
    _impl_.old_state_root_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:executor.v1.TransactionContext.old_state_root)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// TransactionStep

// bytes state_root = 1;
inline void TransactionStep::clear_state_root() {
  _impl_.state_root_.ClearToEmpty();
}
inline const std::string& TransactionStep::state_root() const {
  // @@protoc_insertion_point(field_get:executor.v1.TransactionStep.state_root)
  return _internal_state_root();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TransactionStep::set_state_root(ArgT0&& arg0, ArgT... args) {
 
 _impl_.state_root_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:executor.v1.TransactionStep.state_root)
}
inline std::string* TransactionStep::mutable_state_root() {
  std::string* _s = _internal_mutable_state_root();
  // @@protoc_insertion_point(field_mutable:executor.v1.TransactionStep.state_root)
  return _s;
}
inline const std::string& TransactionStep::_internal_state_root() const {
  return _impl_.state_root_.Get();
}
inline void TransactionStep::_internal_set_state_root(const std::string& value) {
  
  _impl_.state_root_.Set(value, GetArenaForAllocation());
}
inline std::string* TransactionStep::_internal_mutable_state_root() {
  
  return _impl_.state_root_.Mutable(GetArenaForAllocation());
}
inline std::string* TransactionStep::release_state_root() {
  // @@protoc_insertion_point(field_release:executor.v1.TransactionStep.state_root)
  return _impl_.state_root_.Release();
}
inline void TransactionStep::set_allocated_state_root(std::string* state_root) {
  if (state_root != nullptr) {
    
  } else {
    
  }
  _impl_.state_root_.SetAllocated(state_root, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.state_root_.IsDefault()) {
    _impl_.state_root_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:executor.v1.TransactionStep.state_root)
}

// uint32 depth = 2;
inline void TransactionStep::clear_depth() {
  _impl_.depth_ = 0u;
}
inline uint32_t TransactionStep::_internal_depth() const {
  return _impl_.depth_;
}
inline uint32_t TransactionStep::depth() const {
  // @@protoc_insertion_point(field_get:executor.v1.TransactionStep.depth)
  return _internal_depth();
}
inline void TransactionStep::_internal_set_depth(uint32_t value) {
  
  _impl_.depth_ = value;
}
inline void TransactionStep::set_depth(uint32_t value) {
  _internal_set_depth(value);
  // @@protoc_insertion_point(field_set:executor.v1.TransactionStep.depth)
}

// uint64 pc = 3;
inline void TransactionStep::clear_pc() {
  _impl_.pc_ = uint64_t{0u};
}
inline uint64_t TransactionStep::_internal_pc() const {
  return _impl_.pc_;
}
inline uint64_t TransactionStep::pc() const {
  // @@protoc_insertion_point(field_get:executor.v1.TransactionStep.pc)
  return _internal_pc();
}
inline void TransactionStep::_internal_set_pc(uint64_t value) {
  
  _impl_.pc_ = value;
}
inline void TransactionStep::set_pc(uint64_t value) {
  _internal_set_pc(value);
  // @@protoc_insertion_point(field_set:executor.v1.TransactionStep.pc)
}

// uint64 gas = 4;
inline void TransactionStep::clear_gas() {
  _impl_.gas_ = uint64_t{0u};
}
inline uint64_t TransactionStep::_internal_gas() const {
  return _impl_.gas_;
}
inline uint64_t TransactionStep::gas() const {
  // @@protoc_insertion_point(field_get:executor.v1.TransactionStep.gas)
  return _internal_gas();
}
inline void TransactionStep::_internal_set_gas(uint64_t value) {
  
  _impl_.gas_ = value;
}
inline void TransactionStep::set_gas(uint64_t value) {
  _internal_set_gas(value);
  // @@protoc_insertion_point(field_set:executor.v1.TransactionStep.gas)
}

// uint64 gas_cost = 5;
inline void TransactionStep::clear_gas_cost() {
  _impl_.gas_cost_ = uint64_t{0u};
}
inline uint64_t TransactionStep::_internal_gas_cost() const {
  return _impl_.gas_cost_;
}
inline uint64_t TransactionStep::gas_cost() const {
  // @@protoc_insertion_point(field_get:executor.v1.TransactionStep.gas_cost)
  return _internal_gas_cost();
}
inline void TransactionStep::_internal_set_gas_cost(uint64_t value) {
  
  _impl_.gas_cost_ = value;
}
inline void TransactionStep::set_gas_cost(uint64_t value) {
  _internal_set_gas_cost(value);
  // @@protoc_insertion_point(field_set:executor.v1.TransactionStep.gas_cost)
}

// uint64 gas_refund = 6;
inline void TransactionStep::clear_gas_refund() {
  _impl_.gas_refund_ = uint64_t{0u};
}
inline uint64_t TransactionStep::_internal_gas_refund() const {
  return _impl_.gas_refund_;
}
inline uint64_t TransactionStep::gas_refund() const {
  // @@protoc_insertion_point(field_get:executor.v1.TransactionStep.gas_refund)
  return _internal_gas_refund();
}
inline void TransactionStep::_internal_set_gas_refund(uint64_t value) {
  
  _impl_.gas_refund_ = value;
}
inline void TransactionStep::set_gas_refund(uint64_t value) {
  _internal_set_gas_refund(value);
  // @@protoc_insertion_point(field_set:executor.v1.TransactionStep.gas_refund)
}

// uint32 op = 7;
inline void TransactionStep::clear_op() {
  _impl_.op_ = 0u;
}
inline uint32_t TransactionStep::_internal_op() const {
  return _impl_.op_;
}
inline uint32_t TransactionStep::op() const {
  // @@protoc_insertion_point(field_get:executor.v1.TransactionStep.op)
  return _internal_op();
}
inline void TransactionStep::_internal_set_op(uint32_t value) {
  
  _impl_.op_ = value;
}
inline void TransactionStep::set_op(uint32_t value) {
  _internal_set_op(value);
  // @@protoc_insertion_point(field_set:executor.v1.TransactionStep.op)
}

// repeated string stack = 8;
inline int TransactionStep::_internal_stack_size() const {
  return _impl_.stack_.size();
}
inline int TransactionStep::stack_size() const {
  return _internal_stack_size();
}
inline void TransactionStep::clear_stack() {
  _impl_.stack_.Clear();
}
inline std::string* TransactionStep::add_stack() {
  std::string* _s = _internal_add_stack();
  // @@protoc_insertion_point(field_add_mutable:executor.v1.TransactionStep.stack)
  return _s;
}
inline const std::string& TransactionStep::_internal_stack(int index) const {
  return _impl_.stack_.Get(index);
}
inline const std::string& TransactionStep::stack(int index) const {
  // @@protoc_insertion_point(field_get:executor.v1.TransactionStep.stack)
  return _internal_stack(index);
}
inline std::string* TransactionStep::mutable_stack(int index) {
  // @@protoc_insertion_point(field_mutable:executor.v1.TransactionStep.stack)
  return _impl_.stack_.Mutable(index);
}
inline void TransactionStep::set_stack(int index, const std::string& value) {
  _impl_.stack_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:executor.v1.TransactionStep.stack)
}
inline void TransactionStep::set_stack(int index, std::string&& value) {
  _impl_.stack_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:executor.v1.TransactionStep.stack)
}
inline void TransactionStep::set_stack(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.stack_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:executor.v1.TransactionStep.stack)
}
inline void TransactionStep::set_stack(int index, const char* value, size_t size) {
  _impl_.stack_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:executor.v1.TransactionStep.stack)
}
inline std::string* TransactionStep::_internal_add_stack() {
  return _impl_.stack_.Add();
}
inline void TransactionStep::add_stack(const std::string& value) {
  _impl_.stack_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:executor.v1.TransactionStep.stack)
}
inline void TransactionStep::add_stack(std::string&& value) {
  _impl_.stack_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:executor.v1.TransactionStep.stack)
}
inline void TransactionStep::add_stack(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.stack_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:executor.v1.TransactionStep.stack)
}
inline void TransactionStep::add_stack(const char* value, size_t size) {
  _impl_.stack_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:executor.v1.TransactionStep.stack)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
TransactionStep::stack() const {
  // @@protoc_insertion_point(field_list:executor.v1.TransactionStep.stack)
  return _impl_.stack_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
TransactionStep::mutable_stack() {
  // @@protoc_insertion_point(field_mutable_list:executor.v1.TransactionStep.stack)
  return &_impl_.stack_;
}

// bytes memory = 9;
inline void TransactionStep::clear_memory() {
  _impl_.memory_.ClearToEmpty();
}
inline const std::string& TransactionStep::memory() const {
  // @@protoc_insertion_point(field_get:executor.v1.TransactionStep.memory)
  return _internal_memory();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TransactionStep::set_memory(ArgT0&& arg0, ArgT... args) {
 
 _impl_.memory_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:executor.v1.TransactionStep.memory)
}
inline std::string* TransactionStep::mutable_memory() {
  std::string* _s = _internal_mutable_memory();
  // @@protoc_insertion_point(field_mutable:executor.v1.TransactionStep.memory)
  return _s;
}
inline const std::string& TransactionStep::_internal_memory() const {
  return _impl_.memory_.Get();
}
inline void TransactionStep::_internal_set_memory(const std::string& value) {
  
  _impl_.memory_.Set(value, GetArenaForAllocation());
}
inline std::string* TransactionStep::_internal_mutable_memory() {
  
  return _impl_.memory_.Mutable(GetArenaForAllocation());
}
inline std::string* TransactionStep::release_memory() {
  // @@protoc_insertion_point(field_release:executor.v1.TransactionStep.memory)
  return _impl_.memory_.Release();
}
inline void TransactionStep::set_allocated_memory(std::string* memory) {
  if (memory != nullptr) {
    
  } else {
    
  }
  _impl_.memory_.SetAllocated(memory, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.memory_.IsDefault()) {
    _impl_.memory_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:executor.v1.TransactionStep.memory)
}

// uint32 memory_size = 10;
inline void TransactionStep::clear_memory_size() {
  _impl_.memory_size_ = 0u;
}
inline uint32_t TransactionStep::_internal_memory_size() const {
  return _impl_.memory_size_;
}
inline uint32_t TransactionStep::memory_size() const {
  // @@protoc_insertion_point(field_get:executor.v1.TransactionStep.memory_size)
  return _internal_memory_size();
}
inline void TransactionStep::_internal_set_memory_size(uint32_t value) {
  
  _impl_.memory_size_ = value;
}
inline void TransactionStep::set_memory_size(uint32_t value) {
  _internal_set_memory_size(value);
  // @@protoc_insertion_point(field_set:executor.v1.TransactionStep.memory_size)
}

// uint32 memory_offset = 11;
inline void TransactionStep::clear_memory_offset() {
  _impl_.memory_offset_ = 0u;
}
inline uint32_t TransactionStep::_internal_memory_offset() const {
  return _impl_.memory_offset_;
}
inline uint32_t TransactionStep::memory_offset() const {
  // @@protoc_insertion_point(field_get:executor.v1.TransactionStep.memory_offset)
  return _internal_memory_offset();
}
inline void TransactionStep::_internal_set_memory_offset(uint32_t value) {
  
  _impl_.memory_offset_ = value;
}
inline void TransactionStep::set_memory_offset(uint32_t value) {
  _internal_set_memory_offset(value);
  // @@protoc_insertion_point(field_set:executor.v1.TransactionStep.memory_offset)
}

// bytes return_data = 12;
inline void TransactionStep::clear_return_data() {
  _impl_.return_data_.ClearToEmpty();
}
inline const std::string& TransactionStep::return_data() const {
  // @@protoc_insertion_point(field_get:executor.v1.TransactionStep.return_data)
  return _internal_return_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TransactionStep::set_return_data(ArgT0&& arg0, ArgT... args) {
 
 _impl_.return_data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:executor.v1.TransactionStep.return_data)
}
inline std::string* TransactionStep::mutable_return_data() {
  std::string* _s = _internal_mutable_return_data();
  // @@protoc_insertion_point(field_mutable:executor.v1.TransactionStep.return_data)
  return _s;
}
inline const std::string& TransactionStep::_internal_return_data() const {
  return _impl_.return_data_.Get();
}
inline void TransactionStep::_internal_set_return_data(const std::string& value) {
  
  _impl_.return_data_.Set(value, GetArenaForAllocation());
}
inline std::string* TransactionStep::_internal_mutable_return_data() {
  
  return _impl_.return_data_.Mutable(GetArenaForAllocation());
}
inline std::string* TransactionStep::release_return_data() {
  // @@protoc_insertion_point(field_release:executor.v1.TransactionStep.return_data)
  return _impl_.return_data_.Release();
}
inline void TransactionStep::set_allocated_return_data(std::string* return_data) {
  if (return_data != nullptr) {
    
  } else {
    
  }
  _impl_.return_data_.SetAllocated(return_data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.return_data_.IsDefault()) {
    _impl_.return_data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:executor.v1.TransactionStep.return_data)
}

// .executor.v1.Contract contract = 13;
inline bool TransactionStep::_internal_has_contract() const {
  return this != internal_default_instance() && _impl_.contract_ != nullptr;
}
inline bool TransactionStep::has_contract() const {
  return _internal_has_contract();
}
inline void TransactionStep::clear_contract() {
  if (GetArenaForAllocation() == nullptr && _impl_.contract_ != nullptr) {
    delete _impl_.contract_;
  }
  _impl_.contract_ = nullptr;
}
inline const ::executor::v1::Contract& TransactionStep::_internal_contract() const {
  const ::executor::v1::Contract* p = _impl_.contract_;
  return p != nullptr ? *p : reinterpret_cast<const ::executor::v1::Contract&>(
      ::executor::v1::_Contract_default_instance_);
}
inline const ::executor::v1::Contract& TransactionStep::contract() const {
  // @@protoc_insertion_point(field_get:executor.v1.TransactionStep.contract)
  return _internal_contract();
}
inline void TransactionStep::unsafe_arena_set_allocated_contract(
    ::executor::v1::Contract* contract) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.contract_);
  }
  _impl_.contract_ = contract;
  if (contract) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:executor.v1.TransactionStep.contract)
}
inline ::executor::v1::Contract* TransactionStep::release_contract() {
  
  ::executor::v1::Contract* temp = _impl_.contract_;
  _impl_.contract_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::executor::v1::Contract* TransactionStep::unsafe_arena_release_contract() {
  // @@protoc_insertion_point(field_release:executor.v1.TransactionStep.contract)
  
  ::executor::v1::Contract* temp = _impl_.contract_;
  _impl_.contract_ = nullptr;
  return temp;
}
inline ::executor::v1::Contract* TransactionStep::_internal_mutable_contract() {
  
  if (_impl_.contract_ == nullptr) {
    auto* p = CreateMaybeMessage<::executor::v1::Contract>(GetArenaForAllocation());
    _impl_.contract_ = p;
  }
  return _impl_.contract_;
}
inline ::executor::v1::Contract* TransactionStep::mutable_contract() {
  ::executor::v1::Contract* _msg = _internal_mutable_contract();
  // @@protoc_insertion_point(field_mutable:executor.v1.TransactionStep.contract)
  return _msg;
}
inline void TransactionStep::set_allocated_contract(::executor::v1::Contract* contract) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.contract_;
  }
  if (contract) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(contract);
    if (message_arena != submessage_arena) {
      contract = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, contract, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.contract_ = contract;
  // @@protoc_insertion_point(field_set_allocated:executor.v1.TransactionStep.contract)
}

// .executor.v1.RomError error = 14;
inline void TransactionStep::clear_error() {
  _impl_.error_ = 0;
}
inline ::executor::v1::RomError TransactionStep::_internal_error() const {
  return static_cast< ::executor::v1::RomError >(_impl_.error_);
}
inline ::executor::v1::RomError TransactionStep::error() const {
  // @@protoc_insertion_point(field_get:executor.v1.TransactionStep.error)
  return _internal_error();
}
inline void TransactionStep::_internal_set_error(::executor::v1::RomError value) {
  
  _impl_.error_ = value;
}
inline void TransactionStep::set_error(::executor::v1::RomError value) {
  _internal_set_error(value);
  // @@protoc_insertion_point(field_set:executor.v1.TransactionStep.error)
}

// map<string, string> storage = 15;
inline int TransactionStep::_internal_storage_size() const {
  return _impl_.storage_.size();
}
inline int TransactionStep::storage_size() const {
  return _internal_storage_size();
}
inline void TransactionStep::clear_storage() {
  _impl_.storage_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
TransactionStep::_internal_storage() const {
  return _impl_.storage_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
TransactionStep::storage() const {
  // @@protoc_insertion_point(field_map:executor.v1.TransactionStep.storage)
  return _internal_storage();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
TransactionStep::_internal_mutable_storage() {
  return _impl_.storage_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
TransactionStep::mutable_storage() {
  // @@protoc_insertion_point(field_mutable_map:executor.v1.TransactionStep.storage)
  return _internal_mutable_storage();
}

// -------------------------------------------------------------------

// Contract

// string address = 1;
inline void Contract::clear_address() {
  _impl_.address_.ClearToEmpty();
}
inline const std::string& Contract::address() const {
  // @@protoc_insertion_point(field_get:executor.v1.Contract.address)
  return _internal_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Contract::set_address(ArgT0&& arg0, ArgT... args) {
 
 _impl_.address_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:executor.v1.Contract.address)
}
inline std::string* Contract::mutable_address() {
  std::string* _s = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:executor.v1.Contract.address)
  return _s;
}
inline const std::string& Contract::_internal_address() const {
  return _impl_.address_.Get();
}
inline void Contract::_internal_set_address(const std::string& value) {
  
  _impl_.address_.Set(value, GetArenaForAllocation());
}
inline std::string* Contract::_internal_mutable_address() {
  
  return _impl_.address_.Mutable(GetArenaForAllocation());
}
inline std::string* Contract::release_address() {
  // @@protoc_insertion_point(field_release:executor.v1.Contract.address)
  return _impl_.address_.Release();
}
inline void Contract::set_allocated_address(std::string* address) {
  if (address != nullptr) {
    
  } else {
    
  }
  _impl_.address_.SetAllocated(address, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.address_.IsDefault()) {
    _impl_.address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:executor.v1.Contract.address)
}

// string caller = 2;
inline void Contract::clear_caller() {
  _impl_.caller_.ClearToEmpty();
}
inline const std::string& Contract::caller() const {
  // @@protoc_insertion_point(field_get:executor.v1.Contract.caller)
  return _internal_caller();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Contract::set_caller(ArgT0&& arg0, ArgT... args) {
 
 _impl_.caller_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:executor.v1.Contract.caller)
}
inline std::string* Contract::mutable_caller() {
  std::string* _s = _internal_mutable_caller();
  // @@protoc_insertion_point(field_mutable:executor.v1.Contract.caller)
  return _s;
}
inline const std::string& Contract::_internal_caller() const {
  return _impl_.caller_.Get();
}
inline void Contract::_internal_set_caller(const std::string& value) {
  
  _impl_.caller_.Set(value, GetArenaForAllocation());
}
inline std::string* Contract::_internal_mutable_caller() {
  
  return _impl_.caller_.Mutable(GetArenaForAllocation());
}
inline std::string* Contract::release_caller() {
  // @@protoc_insertion_point(field_release:executor.v1.Contract.caller)
  return _impl_.caller_.Release();
}
inline void Contract::set_allocated_caller(std::string* caller) {
  if (caller != nullptr) {
    
  } else {
    
  }
  _impl_.caller_.SetAllocated(caller, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.caller_.IsDefault()) {
    _impl_.caller_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:executor.v1.Contract.caller)
}

// string value = 3;
inline void Contract::clear_value() {
  _impl_.value_.ClearToEmpty();
}
inline const std::string& Contract::value() const {
  // @@protoc_insertion_point(field_get:executor.v1.Contract.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Contract::set_value(ArgT0&& arg0, ArgT... args) {
 
 _impl_.value_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:executor.v1.Contract.value)
}
inline std::string* Contract::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:executor.v1.Contract.value)
  return _s;
}
inline const std::string& Contract::_internal_value() const {
  return _impl_.value_.Get();
}
inline void Contract::_internal_set_value(const std::string& value) {
  
  _impl_.value_.Set(value, GetArenaForAllocation());
}
inline std::string* Contract::_internal_mutable_value() {
  
  return _impl_.value_.Mutable(GetArenaForAllocation());
}
inline std::string* Contract::release_value() {
  // @@protoc_insertion_point(field_release:executor.v1.Contract.value)
  return _impl_.value_.Release();
}
inline void Contract::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  _impl_.value_.SetAllocated(value, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.value_.IsDefault()) {
    _impl_.value_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:executor.v1.Contract.value)
}

// bytes data = 4;
inline void Contract::clear_data() {
  _impl_.data_.ClearToEmpty();
}
inline const std::string& Contract::data() const {
  // @@protoc_insertion_point(field_get:executor.v1.Contract.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Contract::set_data(ArgT0&& arg0, ArgT... args) {
 
 _impl_.data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:executor.v1.Contract.data)
}
inline std::string* Contract::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:executor.v1.Contract.data)
  return _s;
}
inline const std::string& Contract::_internal_data() const {
  return _impl_.data_.Get();
}
inline void Contract::_internal_set_data(const std::string& value) {
  
  _impl_.data_.Set(value, GetArenaForAllocation());
}
inline std::string* Contract::_internal_mutable_data() {
  
  return _impl_.data_.Mutable(GetArenaForAllocation());
}
inline std::string* Contract::release_data() {
  // @@protoc_insertion_point(field_release:executor.v1.Contract.data)
  return _impl_.data_.Release();
}
inline void Contract::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  _impl_.data_.SetAllocated(data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data_.IsDefault()) {
    _impl_.data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:executor.v1.Contract.data)
}

// uint64 gas = 5;
inline void Contract::clear_gas() {
  _impl_.gas_ = uint64_t{0u};
}
inline uint64_t Contract::_internal_gas() const {
  return _impl_.gas_;
}
inline uint64_t Contract::gas() const {
  // @@protoc_insertion_point(field_get:executor.v1.Contract.gas)
  return _internal_gas();
}
inline void Contract::_internal_set_gas(uint64_t value) {
  
  _impl_.gas_ = value;
}
inline void Contract::set_gas(uint64_t value) {
  _internal_set_gas(value);
  // @@protoc_insertion_point(field_set:executor.v1.Contract.gas)
}

// string type = 6;
inline void Contract::clear_type() {
  _impl_.type_.ClearToEmpty();
}
inline const std::string& Contract::type() const {
  // @@protoc_insertion_point(field_get:executor.v1.Contract.type)
  return _internal_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Contract::set_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:executor.v1.Contract.type)
}
inline std::string* Contract::mutable_type() {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:executor.v1.Contract.type)
  return _s;
}
inline const std::string& Contract::_internal_type() const {
  return _impl_.type_.Get();
}
inline void Contract::_internal_set_type(const std::string& value) {
  
  _impl_.type_.Set(value, GetArenaForAllocation());
}
inline std::string* Contract::_internal_mutable_type() {
  
  return _impl_.type_.Mutable(GetArenaForAllocation());
}
inline std::string* Contract::release_type() {
  // @@protoc_insertion_point(field_release:executor.v1.Contract.type)
  return _impl_.type_.Release();
}
inline void Contract::set_allocated_type(std::string* type) {
  if (type != nullptr) {
    
  } else {
    
  }
  _impl_.type_.SetAllocated(type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.type_.IsDefault()) {
    _impl_.type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:executor.v1.Contract.type)
}

// -------------------------------------------------------------------

// ProcessTransactionResponse

// bytes tx_hash = 1;
inline void ProcessTransactionResponse::clear_tx_hash() {
  _impl_.tx_hash_.ClearToEmpty();
}
inline const std::string& ProcessTransactionResponse::tx_hash() const {
  // @@protoc_insertion_point(field_get:executor.v1.ProcessTransactionResponse.tx_hash)
  return _internal_tx_hash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProcessTransactionResponse::set_tx_hash(ArgT0&& arg0, ArgT... args) {
 
 _impl_.tx_hash_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:executor.v1.ProcessTransactionResponse.tx_hash)
}
inline std::string* ProcessTransactionResponse::mutable_tx_hash() {
  std::string* _s = _internal_mutable_tx_hash();
  // @@protoc_insertion_point(field_mutable:executor.v1.ProcessTransactionResponse.tx_hash)
  return _s;
}
inline const std::string& ProcessTransactionResponse::_internal_tx_hash() const {
  return _impl_.tx_hash_.Get();
}
inline void ProcessTransactionResponse::_internal_set_tx_hash(const std::string& value) {
  
  _impl_.tx_hash_.Set(value, GetArenaForAllocation());
}
inline std::string* ProcessTransactionResponse::_internal_mutable_tx_hash() {
  
  return _impl_.tx_hash_.Mutable(GetArenaForAllocation());
}
inline std::string* ProcessTransactionResponse::release_tx_hash() {
  // @@protoc_insertion_point(field_release:executor.v1.ProcessTransactionResponse.tx_hash)
  return _impl_.tx_hash_.Release();
}
inline void ProcessTransactionResponse::set_allocated_tx_hash(std::string* tx_hash) {
  if (tx_hash != nullptr) {
    
  } else {
    
  }
  _impl_.tx_hash_.SetAllocated(tx_hash, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.tx_hash_.IsDefault()) {
    _impl_.tx_hash_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:executor.v1.ProcessTransactionResponse.tx_hash)
}

// bytes rlp_tx = 2;
inline void ProcessTransactionResponse::clear_rlp_tx() {
  _impl_.rlp_tx_.ClearToEmpty();
}
inline const std::string& ProcessTransactionResponse::rlp_tx() const {
  // @@protoc_insertion_point(field_get:executor.v1.ProcessTransactionResponse.rlp_tx)
  return _internal_rlp_tx();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProcessTransactionResponse::set_rlp_tx(ArgT0&& arg0, ArgT... args) {
 
 _impl_.rlp_tx_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:executor.v1.ProcessTransactionResponse.rlp_tx)
}
inline std::string* ProcessTransactionResponse::mutable_rlp_tx() {
  std::string* _s = _internal_mutable_rlp_tx();
  // @@protoc_insertion_point(field_mutable:executor.v1.ProcessTransactionResponse.rlp_tx)
  return _s;
}
inline const std::string& ProcessTransactionResponse::_internal_rlp_tx() const {
  return _impl_.rlp_tx_.Get();
}
inline void ProcessTransactionResponse::_internal_set_rlp_tx(const std::string& value) {
  
  _impl_.rlp_tx_.Set(value, GetArenaForAllocation());
}
inline std::string* ProcessTransactionResponse::_internal_mutable_rlp_tx() {
  
  return _impl_.rlp_tx_.Mutable(GetArenaForAllocation());
}
inline std::string* ProcessTransactionResponse::release_rlp_tx() {
  // @@protoc_insertion_point(field_release:executor.v1.ProcessTransactionResponse.rlp_tx)
  return _impl_.rlp_tx_.Release();
}
inline void ProcessTransactionResponse::set_allocated_rlp_tx(std::string* rlp_tx) {
  if (rlp_tx != nullptr) {
    
  } else {
    
  }
  _impl_.rlp_tx_.SetAllocated(rlp_tx, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.rlp_tx_.IsDefault()) {
    _impl_.rlp_tx_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:executor.v1.ProcessTransactionResponse.rlp_tx)
}

// uint32 type = 3;
inline void ProcessTransactionResponse::clear_type() {
  _impl_.type_ = 0u;
}
inline uint32_t ProcessTransactionResponse::_internal_type() const {
  return _impl_.type_;
}
inline uint32_t ProcessTransactionResponse::type() const {
  // @@protoc_insertion_point(field_get:executor.v1.ProcessTransactionResponse.type)
  return _internal_type();
}
inline void ProcessTransactionResponse::_internal_set_type(uint32_t value) {
  
  _impl_.type_ = value;
}
inline void ProcessTransactionResponse::set_type(uint32_t value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:executor.v1.ProcessTransactionResponse.type)
}

// bytes return_value = 4;
inline void ProcessTransactionResponse::clear_return_value() {
  _impl_.return_value_.ClearToEmpty();
}
inline const std::string& ProcessTransactionResponse::return_value() const {
  // @@protoc_insertion_point(field_get:executor.v1.ProcessTransactionResponse.return_value)
  return _internal_return_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProcessTransactionResponse::set_return_value(ArgT0&& arg0, ArgT... args) {
 
 _impl_.return_value_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:executor.v1.ProcessTransactionResponse.return_value)
}
inline std::string* ProcessTransactionResponse::mutable_return_value() {
  std::string* _s = _internal_mutable_return_value();
  // @@protoc_insertion_point(field_mutable:executor.v1.ProcessTransactionResponse.return_value)
  return _s;
}
inline const std::string& ProcessTransactionResponse::_internal_return_value() const {
  return _impl_.return_value_.Get();
}
inline void ProcessTransactionResponse::_internal_set_return_value(const std::string& value) {
  
  _impl_.return_value_.Set(value, GetArenaForAllocation());
}
inline std::string* ProcessTransactionResponse::_internal_mutable_return_value() {
  
  return _impl_.return_value_.Mutable(GetArenaForAllocation());
}
inline std::string* ProcessTransactionResponse::release_return_value() {
  // @@protoc_insertion_point(field_release:executor.v1.ProcessTransactionResponse.return_value)
  return _impl_.return_value_.Release();
}
inline void ProcessTransactionResponse::set_allocated_return_value(std::string* return_value) {
  if (return_value != nullptr) {
    
  } else {
    
  }
  _impl_.return_value_.SetAllocated(return_value, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.return_value_.IsDefault()) {
    _impl_.return_value_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:executor.v1.ProcessTransactionResponse.return_value)
}

// uint64 gas_left = 5;
inline void ProcessTransactionResponse::clear_gas_left() {
  _impl_.gas_left_ = uint64_t{0u};
}
inline uint64_t ProcessTransactionResponse::_internal_gas_left() const {
  return _impl_.gas_left_;
}
inline uint64_t ProcessTransactionResponse::gas_left() const {
  // @@protoc_insertion_point(field_get:executor.v1.ProcessTransactionResponse.gas_left)
  return _internal_gas_left();
}
inline void ProcessTransactionResponse::_internal_set_gas_left(uint64_t value) {
  
  _impl_.gas_left_ = value;
}
inline void ProcessTransactionResponse::set_gas_left(uint64_t value) {
  _internal_set_gas_left(value);
  // @@protoc_insertion_point(field_set:executor.v1.ProcessTransactionResponse.gas_left)
}

// uint64 gas_used = 6;
inline void ProcessTransactionResponse::clear_gas_used() {
  _impl_.gas_used_ = uint64_t{0u};
}
inline uint64_t ProcessTransactionResponse::_internal_gas_used() const {
  return _impl_.gas_used_;
}
inline uint64_t ProcessTransactionResponse::gas_used() const {
  // @@protoc_insertion_point(field_get:executor.v1.ProcessTransactionResponse.gas_used)
  return _internal_gas_used();
}
inline void ProcessTransactionResponse::_internal_set_gas_used(uint64_t value) {
  
  _impl_.gas_used_ = value;
}
inline void ProcessTransactionResponse::set_gas_used(uint64_t value) {
  _internal_set_gas_used(value);
  // @@protoc_insertion_point(field_set:executor.v1.ProcessTransactionResponse.gas_used)
}

// uint64 gas_refunded = 7;
inline void ProcessTransactionResponse::clear_gas_refunded() {
  _impl_.gas_refunded_ = uint64_t{0u};
}
inline uint64_t ProcessTransactionResponse::_internal_gas_refunded() const {
  return _impl_.gas_refunded_;
}
inline uint64_t ProcessTransactionResponse::gas_refunded() const {
  // @@protoc_insertion_point(field_get:executor.v1.ProcessTransactionResponse.gas_refunded)
  return _internal_gas_refunded();
}
inline void ProcessTransactionResponse::_internal_set_gas_refunded(uint64_t value) {
  
  _impl_.gas_refunded_ = value;
}
inline void ProcessTransactionResponse::set_gas_refunded(uint64_t value) {
  _internal_set_gas_refunded(value);
  // @@protoc_insertion_point(field_set:executor.v1.ProcessTransactionResponse.gas_refunded)
}

// .executor.v1.RomError error = 8;
inline void ProcessTransactionResponse::clear_error() {
  _impl_.error_ = 0;
}
inline ::executor::v1::RomError ProcessTransactionResponse::_internal_error() const {
  return static_cast< ::executor::v1::RomError >(_impl_.error_);
}
inline ::executor::v1::RomError ProcessTransactionResponse::error() const {
  // @@protoc_insertion_point(field_get:executor.v1.ProcessTransactionResponse.error)
  return _internal_error();
}
inline void ProcessTransactionResponse::_internal_set_error(::executor::v1::RomError value) {
  
  _impl_.error_ = value;
}
inline void ProcessTransactionResponse::set_error(::executor::v1::RomError value) {
  _internal_set_error(value);
  // @@protoc_insertion_point(field_set:executor.v1.ProcessTransactionResponse.error)
}

// string create_address = 9;
inline void ProcessTransactionResponse::clear_create_address() {
  _impl_.create_address_.ClearToEmpty();
}
inline const std::string& ProcessTransactionResponse::create_address() const {
  // @@protoc_insertion_point(field_get:executor.v1.ProcessTransactionResponse.create_address)
  return _internal_create_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProcessTransactionResponse::set_create_address(ArgT0&& arg0, ArgT... args) {
 
 _impl_.create_address_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:executor.v1.ProcessTransactionResponse.create_address)
}
inline std::string* ProcessTransactionResponse::mutable_create_address() {
  std::string* _s = _internal_mutable_create_address();
  // @@protoc_insertion_point(field_mutable:executor.v1.ProcessTransactionResponse.create_address)
  return _s;
}
inline const std::string& ProcessTransactionResponse::_internal_create_address() const {
  return _impl_.create_address_.Get();
}
inline void ProcessTransactionResponse::_internal_set_create_address(const std::string& value) {
  
  _impl_.create_address_.Set(value, GetArenaForAllocation());
}
inline std::string* ProcessTransactionResponse::_internal_mutable_create_address() {
  
  return _impl_.create_address_.Mutable(GetArenaForAllocation());
}
inline std::string* ProcessTransactionResponse::release_create_address() {
  // @@protoc_insertion_point(field_release:executor.v1.ProcessTransactionResponse.create_address)
  return _impl_.create_address_.Release();
}
inline void ProcessTransactionResponse::set_allocated_create_address(std::string* create_address) {
  if (create_address != nullptr) {
    
  } else {
    
  }
  _impl_.create_address_.SetAllocated(create_address, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.create_address_.IsDefault()) {
    _impl_.create_address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:executor.v1.ProcessTransactionResponse.create_address)
}

// bytes state_root = 10;
inline void ProcessTransactionResponse::clear_state_root() {
  _impl_.state_root_.ClearToEmpty();
}
inline const std::string& ProcessTransactionResponse::state_root() const {
  // @@protoc_insertion_point(field_get:executor.v1.ProcessTransactionResponse.state_root)
  return _internal_state_root();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProcessTransactionResponse::set_state_root(ArgT0&& arg0, ArgT... args) {
 
 _impl_.state_root_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:executor.v1.ProcessTransactionResponse.state_root)
}
inline std::string* ProcessTransactionResponse::mutable_state_root() {
  std::string* _s = _internal_mutable_state_root();
  // @@protoc_insertion_point(field_mutable:executor.v1.ProcessTransactionResponse.state_root)
  return _s;
}
inline const std::string& ProcessTransactionResponse::_internal_state_root() const {
  return _impl_.state_root_.Get();
}
inline void ProcessTransactionResponse::_internal_set_state_root(const std::string& value) {
  
  _impl_.state_root_.Set(value, GetArenaForAllocation());
}
inline std::string* ProcessTransactionResponse::_internal_mutable_state_root() {
  
  return _impl_.state_root_.Mutable(GetArenaForAllocation());
}
inline std::string* ProcessTransactionResponse::release_state_root() {
  // @@protoc_insertion_point(field_release:executor.v1.ProcessTransactionResponse.state_root)
  return _impl_.state_root_.Release();
}
inline void ProcessTransactionResponse::set_allocated_state_root(std::string* state_root) {
  if (state_root != nullptr) {
    
  } else {
    
  }
  _impl_.state_root_.SetAllocated(state_root, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.state_root_.IsDefault()) {
    _impl_.state_root_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:executor.v1.ProcessTransactionResponse.state_root)
}

// repeated .executor.v1.Log logs = 11;
inline int ProcessTransactionResponse::_internal_logs_size() const {
  return _impl_.logs_.size();
}
inline int ProcessTransactionResponse::logs_size() const {
  return _internal_logs_size();
}
inline void ProcessTransactionResponse::clear_logs() {
  _impl_.logs_.Clear();
}
inline ::executor::v1::Log* ProcessTransactionResponse::mutable_logs(int index) {
  // @@protoc_insertion_point(field_mutable:executor.v1.ProcessTransactionResponse.logs)
  return _impl_.logs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::executor::v1::Log >*
ProcessTransactionResponse::mutable_logs() {
  // @@protoc_insertion_point(field_mutable_list:executor.v1.ProcessTransactionResponse.logs)
  return &_impl_.logs_;
}
inline const ::executor::v1::Log& ProcessTransactionResponse::_internal_logs(int index) const {
  return _impl_.logs_.Get(index);
}
inline const ::executor::v1::Log& ProcessTransactionResponse::logs(int index) const {
  // @@protoc_insertion_point(field_get:executor.v1.ProcessTransactionResponse.logs)
  return _internal_logs(index);
}
inline ::executor::v1::Log* ProcessTransactionResponse::_internal_add_logs() {
  return _impl_.logs_.Add();
}
inline ::executor::v1::Log* ProcessTransactionResponse::add_logs() {
  ::executor::v1::Log* _add = _internal_add_logs();
  // @@protoc_insertion_point(field_add:executor.v1.ProcessTransactionResponse.logs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::executor::v1::Log >&
ProcessTransactionResponse::logs() const {
  // @@protoc_insertion_point(field_list:executor.v1.ProcessTransactionResponse.logs)
  return _impl_.logs_;
}

// .executor.v1.FullTrace full_trace = 14;
inline bool ProcessTransactionResponse::_internal_has_full_trace() const {
  return this != internal_default_instance() && _impl_.full_trace_ != nullptr;
}
inline bool ProcessTransactionResponse::has_full_trace() const {
  return _internal_has_full_trace();
}
inline void ProcessTransactionResponse::clear_full_trace() {
  if (GetArenaForAllocation() == nullptr && _impl_.full_trace_ != nullptr) {
    delete _impl_.full_trace_;
  }
  _impl_.full_trace_ = nullptr;
}
inline const ::executor::v1::FullTrace& ProcessTransactionResponse::_internal_full_trace() const {
  const ::executor::v1::FullTrace* p = _impl_.full_trace_;
  return p != nullptr ? *p : reinterpret_cast<const ::executor::v1::FullTrace&>(
      ::executor::v1::_FullTrace_default_instance_);
}
inline const ::executor::v1::FullTrace& ProcessTransactionResponse::full_trace() const {
  // @@protoc_insertion_point(field_get:executor.v1.ProcessTransactionResponse.full_trace)
  return _internal_full_trace();
}
inline void ProcessTransactionResponse::unsafe_arena_set_allocated_full_trace(
    ::executor::v1::FullTrace* full_trace) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.full_trace_);
  }
  _impl_.full_trace_ = full_trace;
  if (full_trace) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:executor.v1.ProcessTransactionResponse.full_trace)
}
inline ::executor::v1::FullTrace* ProcessTransactionResponse::release_full_trace() {
  
  ::executor::v1::FullTrace* temp = _impl_.full_trace_;
  _impl_.full_trace_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::executor::v1::FullTrace* ProcessTransactionResponse::unsafe_arena_release_full_trace() {
  // @@protoc_insertion_point(field_release:executor.v1.ProcessTransactionResponse.full_trace)
  
  ::executor::v1::FullTrace* temp = _impl_.full_trace_;
  _impl_.full_trace_ = nullptr;
  return temp;
}
inline ::executor::v1::FullTrace* ProcessTransactionResponse::_internal_mutable_full_trace() {
  
  if (_impl_.full_trace_ == nullptr) {
    auto* p = CreateMaybeMessage<::executor::v1::FullTrace>(GetArenaForAllocation());
    _impl_.full_trace_ = p;
  }
  return _impl_.full_trace_;
}
inline ::executor::v1::FullTrace* ProcessTransactionResponse::mutable_full_trace() {
  ::executor::v1::FullTrace* _msg = _internal_mutable_full_trace();
  // @@protoc_insertion_point(field_mutable:executor.v1.ProcessTransactionResponse.full_trace)
  return _msg;
}
inline void ProcessTransactionResponse::set_allocated_full_trace(::executor::v1::FullTrace* full_trace) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.full_trace_;
  }
  if (full_trace) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(full_trace);
    if (message_arena != submessage_arena) {
      full_trace = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, full_trace, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.full_trace_ = full_trace;
  // @@protoc_insertion_point(field_set_allocated:executor.v1.ProcessTransactionResponse.full_trace)
}

// string effective_gas_price = 15;
inline void ProcessTransactionResponse::clear_effective_gas_price() {
  _impl_.effective_gas_price_.ClearToEmpty();
}
inline const std::string& ProcessTransactionResponse::effective_gas_price() const {
  // @@protoc_insertion_point(field_get:executor.v1.ProcessTransactionResponse.effective_gas_price)
  return _internal_effective_gas_price();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProcessTransactionResponse::set_effective_gas_price(ArgT0&& arg0, ArgT... args) {
 
 _impl_.effective_gas_price_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:executor.v1.ProcessTransactionResponse.effective_gas_price)
}
inline std::string* ProcessTransactionResponse::mutable_effective_gas_price() {
  std::string* _s = _internal_mutable_effective_gas_price();
  // @@protoc_insertion_point(field_mutable:executor.v1.ProcessTransactionResponse.effective_gas_price)
  return _s;
}
inline const std::string& ProcessTransactionResponse::_internal_effective_gas_price() const {
  return _impl_.effective_gas_price_.Get();
}
inline void ProcessTransactionResponse::_internal_set_effective_gas_price(const std::string& value) {
  
  _impl_.effective_gas_price_.Set(value, GetArenaForAllocation());
}
inline std::string* ProcessTransactionResponse::_internal_mutable_effective_gas_price() {
  
  return _impl_.effective_gas_price_.Mutable(GetArenaForAllocation());
}
inline std::string* ProcessTransactionResponse::release_effective_gas_price() {
  // @@protoc_insertion_point(field_release:executor.v1.ProcessTransactionResponse.effective_gas_price)
  return _impl_.effective_gas_price_.Release();
}
inline void ProcessTransactionResponse::set_allocated_effective_gas_price(std::string* effective_gas_price) {
  if (effective_gas_price != nullptr) {
    
  } else {
    
  }
  _impl_.effective_gas_price_.SetAllocated(effective_gas_price, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.effective_gas_price_.IsDefault()) {
    _impl_.effective_gas_price_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:executor.v1.ProcessTransactionResponse.effective_gas_price)
}

// uint32 effective_percentage = 16;
inline void ProcessTransactionResponse::clear_effective_percentage() {
  _impl_.effective_percentage_ = 0u;
}
inline uint32_t ProcessTransactionResponse::_internal_effective_percentage() const {
  return _impl_.effective_percentage_;
}
inline uint32_t ProcessTransactionResponse::effective_percentage() const {
  // @@protoc_insertion_point(field_get:executor.v1.ProcessTransactionResponse.effective_percentage)
  return _internal_effective_percentage();
}
inline void ProcessTransactionResponse::_internal_set_effective_percentage(uint32_t value) {
  
  _impl_.effective_percentage_ = value;
}
inline void ProcessTransactionResponse::set_effective_percentage(uint32_t value) {
  _internal_set_effective_percentage(value);
  // @@protoc_insertion_point(field_set:executor.v1.ProcessTransactionResponse.effective_percentage)
}

// uint32 has_gasprice_opcode = 17;
inline void ProcessTransactionResponse::clear_has_gasprice_opcode() {
  _impl_.has_gasprice_opcode_ = 0u;
}
inline uint32_t ProcessTransactionResponse::_internal_has_gasprice_opcode() const {
  return _impl_.has_gasprice_opcode_;
}
inline uint32_t ProcessTransactionResponse::has_gasprice_opcode() const {
  // @@protoc_insertion_point(field_get:executor.v1.ProcessTransactionResponse.has_gasprice_opcode)
  return _internal_has_gasprice_opcode();
}
inline void ProcessTransactionResponse::_internal_set_has_gasprice_opcode(uint32_t value) {
  
  _impl_.has_gasprice_opcode_ = value;
}
inline void ProcessTransactionResponse::set_has_gasprice_opcode(uint32_t value) {
  _internal_set_has_gasprice_opcode(value);
  // @@protoc_insertion_point(field_set:executor.v1.ProcessTransactionResponse.has_gasprice_opcode)
}

// uint32 has_balance_opcode = 18;
inline void ProcessTransactionResponse::clear_has_balance_opcode() {
  _impl_.has_balance_opcode_ = 0u;
}
inline uint32_t ProcessTransactionResponse::_internal_has_balance_opcode() const {
  return _impl_.has_balance_opcode_;
}
inline uint32_t ProcessTransactionResponse::has_balance_opcode() const {
  // @@protoc_insertion_point(field_get:executor.v1.ProcessTransactionResponse.has_balance_opcode)
  return _internal_has_balance_opcode();
}
inline void ProcessTransactionResponse::_internal_set_has_balance_opcode(uint32_t value) {
  
  _impl_.has_balance_opcode_ = value;
}
inline void ProcessTransactionResponse::set_has_balance_opcode(uint32_t value) {
  _internal_set_has_balance_opcode(value);
  // @@protoc_insertion_point(field_set:executor.v1.ProcessTransactionResponse.has_balance_opcode)
}

// -------------------------------------------------------------------

// Log

// string address = 1;
inline void Log::clear_address() {
  _impl_.address_.ClearToEmpty();
}
inline const std::string& Log::address() const {
  // @@protoc_insertion_point(field_get:executor.v1.Log.address)
  return _internal_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Log::set_address(ArgT0&& arg0, ArgT... args) {
 
 _impl_.address_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:executor.v1.Log.address)
}
inline std::string* Log::mutable_address() {
  std::string* _s = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:executor.v1.Log.address)
  return _s;
}
inline const std::string& Log::_internal_address() const {
  return _impl_.address_.Get();
}
inline void Log::_internal_set_address(const std::string& value) {
  
  _impl_.address_.Set(value, GetArenaForAllocation());
}
inline std::string* Log::_internal_mutable_address() {
  
  return _impl_.address_.Mutable(GetArenaForAllocation());
}
inline std::string* Log::release_address() {
  // @@protoc_insertion_point(field_release:executor.v1.Log.address)
  return _impl_.address_.Release();
}
inline void Log::set_allocated_address(std::string* address) {
  if (address != nullptr) {
    
  } else {
    
  }
  _impl_.address_.SetAllocated(address, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.address_.IsDefault()) {
    _impl_.address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:executor.v1.Log.address)
}

// repeated bytes topics = 2;
inline int Log::_internal_topics_size() const {
  return _impl_.topics_.size();
}
inline int Log::topics_size() const {
  return _internal_topics_size();
}
inline void Log::clear_topics() {
  _impl_.topics_.Clear();
}
inline std::string* Log::add_topics() {
  std::string* _s = _internal_add_topics();
  // @@protoc_insertion_point(field_add_mutable:executor.v1.Log.topics)
  return _s;
}
inline const std::string& Log::_internal_topics(int index) const {
  return _impl_.topics_.Get(index);
}
inline const std::string& Log::topics(int index) const {
  // @@protoc_insertion_point(field_get:executor.v1.Log.topics)
  return _internal_topics(index);
}
inline std::string* Log::mutable_topics(int index) {
  // @@protoc_insertion_point(field_mutable:executor.v1.Log.topics)
  return _impl_.topics_.Mutable(index);
}
inline void Log::set_topics(int index, const std::string& value) {
  _impl_.topics_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:executor.v1.Log.topics)
}
inline void Log::set_topics(int index, std::string&& value) {
  _impl_.topics_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:executor.v1.Log.topics)
}
inline void Log::set_topics(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.topics_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:executor.v1.Log.topics)
}
inline void Log::set_topics(int index, const void* value, size_t size) {
  _impl_.topics_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:executor.v1.Log.topics)
}
inline std::string* Log::_internal_add_topics() {
  return _impl_.topics_.Add();
}
inline void Log::add_topics(const std::string& value) {
  _impl_.topics_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:executor.v1.Log.topics)
}
inline void Log::add_topics(std::string&& value) {
  _impl_.topics_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:executor.v1.Log.topics)
}
inline void Log::add_topics(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.topics_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:executor.v1.Log.topics)
}
inline void Log::add_topics(const void* value, size_t size) {
  _impl_.topics_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:executor.v1.Log.topics)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Log::topics() const {
  // @@protoc_insertion_point(field_list:executor.v1.Log.topics)
  return _impl_.topics_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Log::mutable_topics() {
  // @@protoc_insertion_point(field_mutable_list:executor.v1.Log.topics)
  return &_impl_.topics_;
}

// bytes data = 3;
inline void Log::clear_data() {
  _impl_.data_.ClearToEmpty();
}
inline const std::string& Log::data() const {
  // @@protoc_insertion_point(field_get:executor.v1.Log.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Log::set_data(ArgT0&& arg0, ArgT... args) {
 
 _impl_.data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:executor.v1.Log.data)
}
inline std::string* Log::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:executor.v1.Log.data)
  return _s;
}
inline const std::string& Log::_internal_data() const {
  return _impl_.data_.Get();
}
inline void Log::_internal_set_data(const std::string& value) {
  
  _impl_.data_.Set(value, GetArenaForAllocation());
}
inline std::string* Log::_internal_mutable_data() {
  
  return _impl_.data_.Mutable(GetArenaForAllocation());
}
inline std::string* Log::release_data() {
  // @@protoc_insertion_point(field_release:executor.v1.Log.data)
  return _impl_.data_.Release();
}
inline void Log::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  _impl_.data_.SetAllocated(data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data_.IsDefault()) {
    _impl_.data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:executor.v1.Log.data)
}

// uint64 batch_number = 4;
inline void Log::clear_batch_number() {
  _impl_.batch_number_ = uint64_t{0u};
}
inline uint64_t Log::_internal_batch_number() const {
  return _impl_.batch_number_;
}
inline uint64_t Log::batch_number() const {
  // @@protoc_insertion_point(field_get:executor.v1.Log.batch_number)
  return _internal_batch_number();
}
inline void Log::_internal_set_batch_number(uint64_t value) {
  
  _impl_.batch_number_ = value;
}
inline void Log::set_batch_number(uint64_t value) {
  _internal_set_batch_number(value);
  // @@protoc_insertion_point(field_set:executor.v1.Log.batch_number)
}

// bytes tx_hash = 5;
inline void Log::clear_tx_hash() {
  _impl_.tx_hash_.ClearToEmpty();
}
inline const std::string& Log::tx_hash() const {
  // @@protoc_insertion_point(field_get:executor.v1.Log.tx_hash)
  return _internal_tx_hash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Log::set_tx_hash(ArgT0&& arg0, ArgT... args) {
 
 _impl_.tx_hash_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:executor.v1.Log.tx_hash)
}
inline std::string* Log::mutable_tx_hash() {
  std::string* _s = _internal_mutable_tx_hash();
  // @@protoc_insertion_point(field_mutable:executor.v1.Log.tx_hash)
  return _s;
}
inline const std::string& Log::_internal_tx_hash() const {
  return _impl_.tx_hash_.Get();
}
inline void Log::_internal_set_tx_hash(const std::string& value) {
  
  _impl_.tx_hash_.Set(value, GetArenaForAllocation());
}
inline std::string* Log::_internal_mutable_tx_hash() {
  
  return _impl_.tx_hash_.Mutable(GetArenaForAllocation());
}
inline std::string* Log::release_tx_hash() {
  // @@protoc_insertion_point(field_release:executor.v1.Log.tx_hash)
  return _impl_.tx_hash_.Release();
}
inline void Log::set_allocated_tx_hash(std::string* tx_hash) {
  if (tx_hash != nullptr) {
    
  } else {
    
  }
  _impl_.tx_hash_.SetAllocated(tx_hash, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.tx_hash_.IsDefault()) {
    _impl_.tx_hash_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:executor.v1.Log.tx_hash)
}

// uint32 tx_index = 6;
inline void Log::clear_tx_index() {
  _impl_.tx_index_ = 0u;
}
inline uint32_t Log::_internal_tx_index() const {
  return _impl_.tx_index_;
}
inline uint32_t Log::tx_index() const {
  // @@protoc_insertion_point(field_get:executor.v1.Log.tx_index)
  return _internal_tx_index();
}
inline void Log::_internal_set_tx_index(uint32_t value) {
  
  _impl_.tx_index_ = value;
}
inline void Log::set_tx_index(uint32_t value) {
  _internal_set_tx_index(value);
  // @@protoc_insertion_point(field_set:executor.v1.Log.tx_index)
}

// bytes batch_hash = 7;
inline void Log::clear_batch_hash() {
  _impl_.batch_hash_.ClearToEmpty();
}
inline const std::string& Log::batch_hash() const {
  // @@protoc_insertion_point(field_get:executor.v1.Log.batch_hash)
  return _internal_batch_hash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Log::set_batch_hash(ArgT0&& arg0, ArgT... args) {
 
 _impl_.batch_hash_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:executor.v1.Log.batch_hash)
}
inline std::string* Log::mutable_batch_hash() {
  std::string* _s = _internal_mutable_batch_hash();
  // @@protoc_insertion_point(field_mutable:executor.v1.Log.batch_hash)
  return _s;
}
inline const std::string& Log::_internal_batch_hash() const {
  return _impl_.batch_hash_.Get();
}
inline void Log::_internal_set_batch_hash(const std::string& value) {
  
  _impl_.batch_hash_.Set(value, GetArenaForAllocation());
}
inline std::string* Log::_internal_mutable_batch_hash() {
  
  return _impl_.batch_hash_.Mutable(GetArenaForAllocation());
}
inline std::string* Log::release_batch_hash() {
  // @@protoc_insertion_point(field_release:executor.v1.Log.batch_hash)
  return _impl_.batch_hash_.Release();
}
inline void Log::set_allocated_batch_hash(std::string* batch_hash) {
  if (batch_hash != nullptr) {
    
  } else {
    
  }
  _impl_.batch_hash_.SetAllocated(batch_hash, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.batch_hash_.IsDefault()) {
    _impl_.batch_hash_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:executor.v1.Log.batch_hash)
}

// uint32 index = 8;
inline void Log::clear_index() {
  _impl_.index_ = 0u;
}
inline uint32_t Log::_internal_index() const {
  return _impl_.index_;
}
inline uint32_t Log::index() const {
  // @@protoc_insertion_point(field_get:executor.v1.Log.index)
  return _internal_index();
}
inline void Log::_internal_set_index(uint32_t value) {
  
  _impl_.index_ = value;
}
inline void Log::set_index(uint32_t value) {
  _internal_set_index(value);
  // @@protoc_insertion_point(field_set:executor.v1.Log.index)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// ProcessBatchRequestV2

// bytes old_state_root = 1;
inline void ProcessBatchRequestV2::clear_old_state_root() {
  _impl_.old_state_root_.ClearToEmpty();
}
inline const std::string& ProcessBatchRequestV2::old_state_root() const {
  // @@protoc_insertion_point(field_get:executor.v1.ProcessBatchRequestV2.old_state_root)
  return _internal_old_state_root();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProcessBatchRequestV2::set_old_state_root(ArgT0&& arg0, ArgT... args) {
 
 _impl_.old_state_root_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:executor.v1.ProcessBatchRequestV2.old_state_root)
}
inline std::string* ProcessBatchRequestV2::mutable_old_state_root() {
  std::string* _s = _internal_mutable_old_state_root();
  // @@protoc_insertion_point(field_mutable:executor.v1.ProcessBatchRequestV2.old_state_root)
  return _s;
}
inline const std::string& ProcessBatchRequestV2::_internal_old_state_root() const {
  return _impl_.old_state_root_.Get();
}
inline void ProcessBatchRequestV2::_internal_set_old_state_root(const std::string& value) {
  
  _impl_.old_state_root_.Set(value, GetArenaForAllocation());
}
inline std::string* ProcessBatchRequestV2::_internal_mutable_old_state_root() {
  
  return _impl_.old_state_root_.Mutable(GetArenaForAllocation());
}
inline std::string* ProcessBatchRequestV2::release_old_state_root() {
  // @@protoc_insertion_point(field_release:executor.v1.ProcessBatchRequestV2.old_state_root)
  return _impl_.old_state_root_.Release();
}
inline void ProcessBatchRequestV2::set_allocated_old_state_root(std::string* old_state_root) {
  if (old_state_root != nullptr) {
    
  } else {
    
  }
  _impl_.old_state_root_.SetAllocated(old_state_root, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.old_state_root_.IsDefault()) {
    _impl_.old_state_root_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:executor.v1.ProcessBatchRequestV2.old_state_root)
}

// bytes old_acc_input_hash = 2;
inline void ProcessBatchRequestV2::clear_old_acc_input_hash() {
  _impl_.old_acc_input_hash_.ClearToEmpty();
}
inline const std::string& ProcessBatchRequestV2::old_acc_input_hash() const {
  // @@protoc_insertion_point(field_get:executor.v1.ProcessBatchRequestV2.old_acc_input_hash)
  return _internal_old_acc_input_hash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProcessBatchRequestV2::set_old_acc_input_hash(ArgT0&& arg0, ArgT... args) {
 
 _impl_.old_acc_input_hash_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:executor.v1.ProcessBatchRequestV2.old_acc_input_hash)
}
inline std::string* ProcessBatchRequestV2::mutable_old_acc_input_hash() {
  std::string* _s = _internal_mutable_old_acc_input_hash();
  // @@protoc_insertion_point(field_mutable:executor.v1.ProcessBatchRequestV2.old_acc_input_hash)
  return _s;
}
inline const std::string& ProcessBatchRequestV2::_internal_old_acc_input_hash() const {
  return _impl_.old_acc_input_hash_.Get();
}
inline void ProcessBatchRequestV2::_internal_set_old_acc_input_hash(const std::string& value) {
  
  _impl_.old_acc_input_hash_.Set(value, GetArenaForAllocation());
}
inline std::string* ProcessBatchRequestV2::_internal_mutable_old_acc_input_hash() {
  
  return _impl_.old_acc_input_hash_.Mutable(GetArenaForAllocation());
}
inline std::string* ProcessBatchRequestV2::release_old_acc_input_hash() {
  // @@protoc_insertion_point(field_release:executor.v1.ProcessBatchRequestV2.old_acc_input_hash)
  return _impl_.old_acc_input_hash_.Release();
}
inline void ProcessBatchRequestV2::set_allocated_old_acc_input_hash(std::string* old_acc_input_hash) {
  if (old_acc_input_hash != nullptr) {
    
  } else {
    
  }
  _impl_.old_acc_input_hash_.SetAllocated(old_acc_input_hash, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.old_acc_input_hash_.IsDefault()) {
    _impl_.old_acc_input_hash_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:executor.v1.ProcessBatchRequestV2.old_acc_input_hash)
}

// uint64 old_batch_num = 3;
inline void ProcessBatchRequestV2::clear_old_batch_num() {
  _impl_.old_batch_num_ = uint64_t{0u};
}
inline uint64_t ProcessBatchRequestV2::_internal_old_batch_num() const {
  return _impl_.old_batch_num_;
}
inline uint64_t ProcessBatchRequestV2::old_batch_num() const {
  // @@protoc_insertion_point(field_get:executor.v1.ProcessBatchRequestV2.old_batch_num)
  return _internal_old_batch_num();
}
inline void ProcessBatchRequestV2::_internal_set_old_batch_num(uint64_t value) {
  
  _impl_.old_batch_num_ = value;
}
inline void ProcessBatchRequestV2::set_old_batch_num(uint64_t value) {
  _internal_set_old_batch_num(value);
  // @@protoc_insertion_point(field_set:executor.v1.ProcessBatchRequestV2.old_batch_num)
}

// uint64 chain_id = 4;
inline void ProcessBatchRequestV2::clear_chain_id() {
  _impl_.chain_id_ = uint64_t{0u};
}
inline uint64_t ProcessBatchRequestV2::_internal_chain_id() const {
  return _impl_.chain_id_;
}
inline uint64_t ProcessBatchRequestV2::chain_id() const {
  // @@protoc_insertion_point(field_get:executor.v1.ProcessBatchRequestV2.chain_id)
  return _internal_chain_id();
}
inline void ProcessBatchRequestV2::_internal_set_chain_id(uint64_t value) {
  
  _impl_.chain_id_ = value;
}
inline void ProcessBatchRequestV2::set_chain_id(uint64_t value) {
  _internal_set_chain_id(value);
  // @@protoc_insertion_point(field_set:executor.v1.ProcessBatchRequestV2.chain_id)
}

// uint64 fork_id = 5;
inline void ProcessBatchRequestV2::clear_fork_id() {
  _impl_.fork_id_ = uint64_t{0u};
}
inline uint64_t ProcessBatchRequestV2::_internal_fork_id() const {
  return _impl_.fork_id_;
}
inline uint64_t ProcessBatchRequestV2::fork_id() const {
  // @@protoc_insertion_point(field_get:executor.v1.ProcessBatchRequestV2.fork_id)
  return _internal_fork_id();
}
inline void ProcessBatchRequestV2::_internal_set_fork_id(uint64_t value) {
  
  _impl_.fork_id_ = value;
}
inline void ProcessBatchRequestV2::set_fork_id(uint64_t value) {
  _internal_set_fork_id(value);
  // @@protoc_insertion_point(field_set:executor.v1.ProcessBatchRequestV2.fork_id)
}

// bytes batch_l2_data = 6;
inline void ProcessBatchRequestV2::clear_batch_l2_data() {
  _impl_.batch_l2_data_.ClearToEmpty();
}
inline const std::string& ProcessBatchRequestV2::batch_l2_data() const {
  // @@protoc_insertion_point(field_get:executor.v1.ProcessBatchRequestV2.batch_l2_data)
  return _internal_batch_l2_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProcessBatchRequestV2::set_batch_l2_data(ArgT0&& arg0, ArgT... args) {
 
 _impl_.batch_l2_data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:executor.v1.ProcessBatchRequestV2.batch_l2_data)
}
inline std::string* ProcessBatchRequestV2::mutable_batch_l2_data() {
  std::string* _s = _internal_mutable_batch_l2_data();
  // @@protoc_insertion_point(field_mutable:executor.v1.ProcessBatchRequestV2.batch_l2_data)
  return _s;
}
inline const std::string& ProcessBatchRequestV2::_internal_batch_l2_data() const {
  return _impl_.batch_l2_data_.Get();
}
inline void ProcessBatchRequestV2::_internal_set_batch_l2_data(const std::string& value) {
  
  _impl_.batch_l2_data_.Set(value, GetArenaForAllocation());
}
inline std::string* ProcessBatchRequestV2::_internal_mutable_batch_l2_data() {
  
  return _impl_.batch_l2_data_.Mutable(GetArenaForAllocation());
}
inline std::string* ProcessBatchRequestV2::release_batch_l2_data() {
  // @@protoc_insertion_point(field_release:executor.v1.ProcessBatchRequestV2.batch_l2_data)
  return _impl_.batch_l2_data_.Release();
}
inline void ProcessBatchRequestV2::set_allocated_batch_l2_data(std::string* batch_l2_data) {
  if (batch_l2_data != nullptr) {
    
  } else {
    
  }
  _impl_.batch_l2_data_.SetAllocated(batch_l2_data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.batch_l2_data_.IsDefault()) {
    _impl_.batch_l2_data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:executor.v1.ProcessBatchRequestV2.batch_l2_data)
}

// bytes l1_info_root = 7;
inline void ProcessBatchRequestV2::clear_l1_info_root() {
  _impl_.l1_info_root_.ClearToEmpty();
}
inline const std::string& ProcessBatchRequestV2::l1_info_root() const {
  // @@protoc_insertion_point(field_get:executor.v1.ProcessBatchRequestV2.l1_info_root)
  return _internal_l1_info_root();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProcessBatchRequestV2::set_l1_info_root(ArgT0&& arg0, ArgT... args) {
 
 _impl_.l1_info_root_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:executor.v1.ProcessBatchRequestV2.l1_info_root)
}
inline std::string* ProcessBatchRequestV2::mutable_l1_info_root() {
  std::string* _s = _internal_mutable_l1_info_root();
  // @@protoc_insertion_point(field_mutable:executor.v1.ProcessBatchRequestV2.l1_info_root)
  return _s;
}
inline const std::string& ProcessBatchRequestV2::_internal_l1_info_root() const {
  return _impl_.l1_info_root_.Get();
}
inline void ProcessBatchRequestV2::_internal_set_l1_info_root(const std::string& value) {
  
  _impl_.l1_info_root_.Set(value, GetArenaForAllocation());
}
inline std::string* ProcessBatchRequestV2::_internal_mutable_l1_info_root() {
  
  return _impl_.l1_info_root_.Mutable(GetArenaForAllocation());
}
inline std::string* ProcessBatchRequestV2::release_l1_info_root() {
  // @@protoc_insertion_point(field_release:executor.v1.ProcessBatchRequestV2.l1_info_root)
  return _impl_.l1_info_root_.Release();
}
inline void ProcessBatchRequestV2::set_allocated_l1_info_root(std::string* l1_info_root) {
  if (l1_info_root != nullptr) {
    
  } else {
    
  }
  _impl_.l1_info_root_.SetAllocated(l1_info_root, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.l1_info_root_.IsDefault()) {
    _impl_.l1_info_root_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:executor.v1.ProcessBatchRequestV2.l1_info_root)
}

// uint64 timestamp_limit = 8;
inline void ProcessBatchRequestV2::clear_timestamp_limit() {
  _impl_.timestamp_limit_ = uint64_t{0u};
}
inline uint64_t ProcessBatchRequestV2::_internal_timestamp_limit() const {
  return _impl_.timestamp_limit_;
}
inline uint64_t ProcessBatchRequestV2::timestamp_limit() const {
  // @@protoc_insertion_point(field_get:executor.v1.ProcessBatchRequestV2.timestamp_limit)
  return _internal_timestamp_limit();
}
inline void ProcessBatchRequestV2::_internal_set_timestamp_limit(uint64_t value) {
  
  _impl_.timestamp_limit_ = value;
}
inline void ProcessBatchRequestV2::set_timestamp_limit(uint64_t value) {
  _internal_set_timestamp_limit(value);
  // @@protoc_insertion_point(field_set:executor.v1.ProcessBatchRequestV2.timestamp_limit)
}

// string coinbase = 9;
inline void ProcessBatchRequestV2::clear_coinbase() {
  _impl_.coinbase_.ClearToEmpty();
}
inline const std::string& ProcessBatchRequestV2::coinbase() const {
  // @@protoc_insertion_point(field_get:executor.v1.ProcessBatchRequestV2.coinbase)
  return _internal_coinbase();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProcessBatchRequestV2::set_coinbase(ArgT0&& arg0, ArgT... args) {
 
 _impl_.coinbase_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:executor.v1.ProcessBatchRequestV2.coinbase)
}
inline std::string* ProcessBatchRequestV2::mutable_coinbase() {
  std::string* _s = _internal_mutable_coinbase();
  // @@protoc_insertion_point(field_mutable:executor.v1.ProcessBatchRequestV2.coinbase)
  return _s;
}
inline const std::string& ProcessBatchRequestV2::_internal_coinbase() const {
  return _impl_.coinbase_.Get();
}
inline void ProcessBatchRequestV2::_internal_set_coinbase(const std::string& value) {
  
  _impl_.coinbase_.Set(value, GetArenaForAllocation());
}
inline std::string* ProcessBatchRequestV2::_internal_mutable_coinbase() {
  
  return _impl_.coinbase_.Mutable(GetArenaForAllocation());
}
inline std::string* ProcessBatchRequestV2::release_coinbase() {
  // @@protoc_insertion_point(field_release:executor.v1.ProcessBatchRequestV2.coinbase)
  return _impl_.coinbase_.Release();
}
inline void ProcessBatchRequestV2::set_allocated_coinbase(std::string* coinbase) {
  if (coinbase != nullptr) {
    
  } else {
    
  }
  _impl_.coinbase_.SetAllocated(coinbase, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.coinbase_.IsDefault()) {
    _impl_.coinbase_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:executor.v1.ProcessBatchRequestV2.coinbase)
}

// bytes forced_blockhash_l1 = 10;
inline void ProcessBatchRequestV2::clear_forced_blockhash_l1() {
  _impl_.forced_blockhash_l1_.ClearToEmpty();
}
inline const std::string& ProcessBatchRequestV2::forced_blockhash_l1() const {
  // @@protoc_insertion_point(field_get:executor.v1.ProcessBatchRequestV2.forced_blockhash_l1)
  return _internal_forced_blockhash_l1();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProcessBatchRequestV2::set_forced_blockhash_l1(ArgT0&& arg0, ArgT... args) {
 
 _impl_.forced_blockhash_l1_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:executor.v1.ProcessBatchRequestV2.forced_blockhash_l1)
}
inline std::string* ProcessBatchRequestV2::mutable_forced_blockhash_l1() {
  std::string* _s = _internal_mutable_forced_blockhash_l1();
  // @@protoc_insertion_point(field_mutable:executor.v1.ProcessBatchRequestV2.forced_blockhash_l1)
  return _s;
}
inline const std::string& ProcessBatchRequestV2::_internal_forced_blockhash_l1() const {
  return _impl_.forced_blockhash_l1_.Get();
}
inline void ProcessBatchRequestV2::_internal_set_forced_blockhash_l1(const std::string& value) {
  
  _impl_.forced_blockhash_l1_.Set(value, GetArenaForAllocation());
}
inline std::string* ProcessBatchRequestV2::_internal_mutable_forced_blockhash_l1() {
  
  return _impl_.forced_blockhash_l1_.Mutable(GetArenaForAllocation());
}
inline std::string* ProcessBatchRequestV2::release_forced_blockhash_l1() {
  // @@protoc_insertion_point(field_release:executor.v1.ProcessBatchRequestV2.forced_blockhash_l1)
  return _impl_.forced_blockhash_l1_.Release();
}
inline void ProcessBatchRequestV2::set_allocated_forced_blockhash_l1(std::string* forced_blockhash_l1) {
  if (forced_blockhash_l1 != nullptr) {
    
  } else {
    
  }
  _impl_.forced_blockhash_l1_.SetAllocated(forced_blockhash_l1, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.forced_blockhash_l1_.IsDefault()) {
    _impl_.forced_blockhash_l1_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:executor.v1.ProcessBatchRequestV2.forced_blockhash_l1)
}

// uint32 update_merkle_tree = 11;
inline void ProcessBatchRequestV2::clear_update_merkle_tree() {
  _impl_.update_merkle_tree_ = 0u;
}
inline uint32_t ProcessBatchRequestV2::_internal_update_merkle_tree() const {
  return _impl_.update_merkle_tree_;
}
inline uint32_t ProcessBatchRequestV2::update_merkle_tree() const {
  // @@protoc_insertion_point(field_get:executor.v1.ProcessBatchRequestV2.update_merkle_tree)
  return _internal_update_merkle_tree();
}
inline void ProcessBatchRequestV2::_internal_set_update_merkle_tree(uint32_t value) {
  
  _impl_.update_merkle_tree_ = value;
}
inline void ProcessBatchRequestV2::set_update_merkle_tree(uint32_t value) {
  _internal_set_update_merkle_tree(value);
  // @@protoc_insertion_point(field_set:executor.v1.ProcessBatchRequestV2.update_merkle_tree)
}

// uint32 no_counters = 12;
inline void ProcessBatchRequestV2::clear_no_counters() {
  _impl_.no_counters_ = 0u;
}
inline uint32_t ProcessBatchRequestV2::_internal_no_counters() const {
  return _impl_.no_counters_;
}
inline uint32_t ProcessBatchRequestV2::no_counters() const {
  // @@protoc_insertion_point(field_get:executor.v1.ProcessBatchRequestV2.no_counters)
  return _internal_no_counters();
}
inline void ProcessBatchRequestV2::_internal_set_no_counters(uint32_t value) {
  
  _impl_.no_counters_ = value;
}
inline void ProcessBatchRequestV2::set_no_counters(uint32_t value) {
  _internal_set_no_counters(value);
  // @@protoc_insertion_point(field_set:executor.v1.ProcessBatchRequestV2.no_counters)
}

// string from = 13;
inline void ProcessBatchRequestV2::clear_from() {
  _impl_.from_.ClearToEmpty();
}
inline const std::string& ProcessBatchRequestV2::from() const {
  // @@protoc_insertion_point(field_get:executor.v1.ProcessBatchRequestV2.from)
  return _internal_from();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProcessBatchRequestV2::set_from(ArgT0&& arg0, ArgT... args) {
 
 _impl_.from_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:executor.v1.ProcessBatchRequestV2.from)
}
inline std::string* ProcessBatchRequestV2::mutable_from() {
  std::string* _s = _internal_mutable_from();
  // @@protoc_insertion_point(field_mutable:executor.v1.ProcessBatchRequestV2.from)
  return _s;
}
inline const std::string& ProcessBatchRequestV2::_internal_from() const {
  return _impl_.from_.Get();
}
inline void ProcessBatchRequestV2::_internal_set_from(const std::string& value) {
  
  _impl_.from_.Set(value, GetArenaForAllocation());
}
inline std::string* ProcessBatchRequestV2::_internal_mutable_from() {
  
  return _impl_.from_.Mutable(GetArenaForAllocation());
}
inline std::string* ProcessBatchRequestV2::release_from() {
  // @@protoc_insertion_point(field_release:executor.v1.ProcessBatchRequestV2.from)
  return _impl_.from_.Release();
}
inline void ProcessBatchRequestV2::set_allocated_from(std::string* from) {
  if (from != nullptr) {
    
  } else {
    
  }
  _impl_.from_.SetAllocated(from, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.from_.IsDefault()) {
    _impl_.from_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:executor.v1.ProcessBatchRequestV2.from)
}

// uint32 skip_verify_l1_info_root = 14;
inline void ProcessBatchRequestV2::clear_skip_verify_l1_info_root() {
  _impl_.skip_verify_l1_info_root_ = 0u;
}
inline uint32_t ProcessBatchRequestV2::_internal_skip_verify_l1_info_root() const {
  return _impl_.skip_verify_l1_info_root_;
}
inline uint32_t ProcessBatchRequestV2::skip_verify_l1_info_root() const {
  // @@protoc_insertion_point(field_get:executor.v1.ProcessBatchRequestV2.skip_verify_l1_info_root)
  return _internal_skip_verify_l1_info_root();
}
inline void ProcessBatchRequestV2::_internal_set_skip_verify_l1_info_root(uint32_t value) {
  
  _impl_.skip_verify_l1_info_root_ = value;
}
inline void ProcessBatchRequestV2::set_skip_verify_l1_info_root(uint32_t value) {
  _internal_set_skip_verify_l1_info_root(value);
  // @@protoc_insertion_point(field_set:executor.v1.ProcessBatchRequestV2.skip_verify_l1_info_root)
}

// uint32 skip_first_change_l2_block = 15;
inline void ProcessBatchRequestV2::clear_skip_first_change_l2_block() {
  _impl_.skip_first_change_l2_block_ = 0u;
}
inline uint32_t ProcessBatchRequestV2::_internal_skip_first_change_l2_block() const {
  return _impl_.skip_first_change_l2_block_;
}
inline uint32_t ProcessBatchRequestV2::skip_first_change_l2_block() const {
  // @@protoc_insertion_point(field_get:executor.v1.ProcessBatchRequestV2.skip_first_change_l2_block)
  return _internal_skip_first_change_l2_block();
}
inline void ProcessBatchRequestV2::_internal_set_skip_first_change_l2_block(uint32_t value) {
  
  _impl_.skip_first_change_l2_block_ = value;
}
inline void ProcessBatchRequestV2::set_skip_first_change_l2_block(uint32_t value) {
  _internal_set_skip_first_change_l2_block(value);
  // @@protoc_insertion_point(field_set:executor.v1.ProcessBatchRequestV2.skip_first_change_l2_block)
}

// uint32 skip_write_block_info_root = 16;
inline void ProcessBatchRequestV2::clear_skip_write_block_info_root() {
  skip_write_block_info_root_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ProcessBatchRequestV2::_internal_skip_write_block_info_root() const {
  return skip_write_block_info_root_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ProcessBatchRequestV2::skip_write_block_info_root() const {
  // @@protoc_insertion_point(field_get:executor.v1.ProcessBatchRequestV2.skip_write_block_info_root)
  return _internal_skip_write_block_info_root();
}
inline void ProcessBatchRequestV2::_internal_set_skip_write_block_info_root(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  skip_write_block_info_root_ = value;
}
inline void ProcessBatchRequestV2::set_skip_write_block_info_root(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_skip_write_block_info_root(value);
  // @@protoc_insertion_point(field_set:executor.v1.ProcessBatchRequestV2.skip_write_block_info_root)
}

// map<uint32, .executor.v1.L1DataV2> l1_info_tree_data = 17;
inline int ProcessBatchRequestV2::_internal_l1_info_tree_data_size() const {
  return _impl_.l1_info_tree_data_.size();
}
inline int ProcessBatchRequestV2::l1_info_tree_data_size() const {
  return _internal_l1_info_tree_data_size();
}
inline void ProcessBatchRequestV2::clear_l1_info_tree_data() {
  _impl_.l1_info_tree_data_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< uint32_t, ::executor::v1::L1DataV2 >&
ProcessBatchRequestV2::_internal_l1_info_tree_data() const {
  return _impl_.l1_info_tree_data_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< uint32_t, ::executor::v1::L1DataV2 >&
ProcessBatchRequestV2::l1_info_tree_data() const {
  // @@protoc_insertion_point(field_map:executor.v1.ProcessBatchRequestV2.l1_info_tree_data)
  return _internal_l1_info_tree_data();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< uint32_t, ::executor::v1::L1DataV2 >*
ProcessBatchRequestV2::_internal_mutable_l1_info_tree_data() {
  return _impl_.l1_info_tree_data_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< uint32_t, ::executor::v1::L1DataV2 >*
ProcessBatchRequestV2::mutable_l1_info_tree_data() {
  // @@protoc_insertion_point(field_mutable_map:executor.v1.ProcessBatchRequestV2.l1_info_tree_data)
  return _internal_mutable_l1_info_tree_data();
}

// map<string, string> db = 18;
inline int ProcessBatchRequestV2::_internal_db_size() const {
  return _impl_.db_.size();
}
inline int ProcessBatchRequestV2::db_size() const {
  return _internal_db_size();
}
inline void ProcessBatchRequestV2::clear_db() {
  _impl_.db_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
ProcessBatchRequestV2::_internal_db() const {
  return _impl_.db_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
ProcessBatchRequestV2::db() const {
  // @@protoc_insertion_point(field_map:executor.v1.ProcessBatchRequestV2.db)
  return _internal_db();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
ProcessBatchRequestV2::_internal_mutable_db() {
  return _impl_.db_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
ProcessBatchRequestV2::mutable_db() {
  // @@protoc_insertion_point(field_mutable_map:executor.v1.ProcessBatchRequestV2.db)
  return _internal_mutable_db();
}

// map<string, string> contracts_bytecode = 19;
inline int ProcessBatchRequestV2::_internal_contracts_bytecode_size() const {
  return _impl_.contracts_bytecode_.size();
}
inline int ProcessBatchRequestV2::contracts_bytecode_size() const {
  return _internal_contracts_bytecode_size();
}
inline void ProcessBatchRequestV2::clear_contracts_bytecode() {
  _impl_.contracts_bytecode_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
ProcessBatchRequestV2::_internal_contracts_bytecode() const {
  return _impl_.contracts_bytecode_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
ProcessBatchRequestV2::contracts_bytecode() const {
  // @@protoc_insertion_point(field_map:executor.v1.ProcessBatchRequestV2.contracts_bytecode)
  return _internal_contracts_bytecode();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
ProcessBatchRequestV2::_internal_mutable_contracts_bytecode() {
  return _impl_.contracts_bytecode_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
ProcessBatchRequestV2::mutable_contracts_bytecode() {
  // @@protoc_insertion_point(field_mutable_map:executor.v1.ProcessBatchRequestV2.contracts_bytecode)
  return _internal_mutable_contracts_bytecode();
}

// .executor.v1.TraceConfigV2 trace_config = 20;
inline bool ProcessBatchRequestV2::_internal_has_trace_config() const {
  return this != internal_default_instance() && _impl_.trace_config_ != nullptr;
}
inline bool ProcessBatchRequestV2::has_trace_config() const {
  return _internal_has_trace_config();
}
inline void ProcessBatchRequestV2::clear_trace_config() {
  if (GetArenaForAllocation() == nullptr && _impl_.trace_config_ != nullptr) {
    delete _impl_.trace_config_;
  }
  _impl_.trace_config_ = nullptr;
}
inline const ::executor::v1::TraceConfigV2& ProcessBatchRequestV2::_internal_trace_config() const {
  const ::executor::v1::TraceConfigV2* p = _impl_.trace_config_;
  return p != nullptr ? *p : reinterpret_cast<const ::executor::v1::TraceConfigV2&>(
      ::executor::v1::_TraceConfigV2_default_instance_);
}
inline const ::executor::v1::TraceConfigV2& ProcessBatchRequestV2::trace_config() const {
  // @@protoc_insertion_point(field_get:executor.v1.ProcessBatchRequestV2.trace_config)
  return _internal_trace_config();
}
inline void ProcessBatchRequestV2::unsafe_arena_set_allocated_trace_config(
    ::executor::v1::TraceConfigV2* trace_config) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.trace_config_);
  }
  _impl_.trace_config_ = trace_config;
  if (trace_config) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:executor.v1.ProcessBatchRequestV2.trace_config)
}
inline ::executor::v1::TraceConfigV2* ProcessBatchRequestV2::release_trace_config() {
  
  ::executor::v1::TraceConfigV2* temp = _impl_.trace_config_;
  _impl_.trace_config_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::executor::v1::TraceConfigV2* ProcessBatchRequestV2::unsafe_arena_release_trace_config() {
  // @@protoc_insertion_point(field_release:executor.v1.ProcessBatchRequestV2.trace_config)
  
  ::executor::v1::TraceConfigV2* temp = _impl_.trace_config_;
  _impl_.trace_config_ = nullptr;
  return temp;
}
inline ::executor::v1::TraceConfigV2* ProcessBatchRequestV2::_internal_mutable_trace_config() {
  
  if (_impl_.trace_config_ == nullptr) {
    auto* p = CreateMaybeMessage<::executor::v1::TraceConfigV2>(GetArenaForAllocation());
    _impl_.trace_config_ = p;
  }
  return _impl_.trace_config_;
}
inline ::executor::v1::TraceConfigV2* ProcessBatchRequestV2::mutable_trace_config() {
  ::executor::v1::TraceConfigV2* _msg = _internal_mutable_trace_config();
  // @@protoc_insertion_point(field_mutable:executor.v1.ProcessBatchRequestV2.trace_config)
  return _msg;
}
inline void ProcessBatchRequestV2::set_allocated_trace_config(::executor::v1::TraceConfigV2* trace_config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.trace_config_;
  }
  if (trace_config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(trace_config);
    if (message_arena != submessage_arena) {
      trace_config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, trace_config, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.trace_config_ = trace_config;
  // @@protoc_insertion_point(field_set_allocated:executor.v1.ProcessBatchRequestV2.trace_config)
}

// string context_id = 21;
inline void ProcessBatchRequestV2::clear_context_id() {
  _impl_.context_id_.ClearToEmpty();
}
inline const std::string& ProcessBatchRequestV2::context_id() const {
  // @@protoc_insertion_point(field_get:executor.v1.ProcessBatchRequestV2.context_id)
  return _internal_context_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProcessBatchRequestV2::set_context_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.context_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:executor.v1.ProcessBatchRequestV2.context_id)
}
inline std::string* ProcessBatchRequestV2::mutable_context_id() {
  std::string* _s = _internal_mutable_context_id();
  // @@protoc_insertion_point(field_mutable:executor.v1.ProcessBatchRequestV2.context_id)
  return _s;
}
inline const std::string& ProcessBatchRequestV2::_internal_context_id() const {
  return _impl_.context_id_.Get();
}
inline void ProcessBatchRequestV2::_internal_set_context_id(const std::string& value) {
  
  _impl_.context_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ProcessBatchRequestV2::_internal_mutable_context_id() {
  
  return _impl_.context_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ProcessBatchRequestV2::release_context_id() {
  // @@protoc_insertion_point(field_release:executor.v1.ProcessBatchRequestV2.context_id)
  return _impl_.context_id_.Release();
}
inline void ProcessBatchRequestV2::set_allocated_context_id(std::string* context_id) {
  if (context_id != nullptr) {
    
  } else {
    
  }
  _impl_.context_id_.SetAllocated(context_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.context_id_.IsDefault()) {
    _impl_.context_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:executor.v1.ProcessBatchRequestV2.context_id)
}

// uint32 get_keys = 22;
inline void ProcessBatchRequestV2::clear_get_keys() {
  _impl_.get_keys_ = 0u;
}
inline uint32_t ProcessBatchRequestV2::_internal_get_keys() const {
  return _impl_.get_keys_;
}
inline uint32_t ProcessBatchRequestV2::get_keys() const {
  // @@protoc_insertion_point(field_get:executor.v1.ProcessBatchRequestV2.get_keys)
  return _internal_get_keys();
}
inline void ProcessBatchRequestV2::_internal_set_get_keys(uint32_t value) {
  
  _impl_.get_keys_ = value;
}
inline void ProcessBatchRequestV2::set_get_keys(uint32_t value) {
  _internal_set_get_keys(value);
  // @@protoc_insertion_point(field_set:executor.v1.ProcessBatchRequestV2.get_keys)
}

// map<string, .executor.v1.OverrideAccountV2> state_override = 23;
inline int ProcessBatchRequestV2::_internal_state_override_size() const {
  return _impl_.state_override_.size();
}
inline int ProcessBatchRequestV2::state_override_size() const {
  return _internal_state_override_size();
}
inline void ProcessBatchRequestV2::clear_state_override() {
  _impl_.state_override_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::executor::v1::OverrideAccountV2 >&
ProcessBatchRequestV2::_internal_state_override() const {
  return _impl_.state_override_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::executor::v1::OverrideAccountV2 >&
ProcessBatchRequestV2::state_override() const {
  // @@protoc_insertion_point(field_map:executor.v1.ProcessBatchRequestV2.state_override)
  return _internal_state_override();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::executor::v1::OverrideAccountV2 >*
ProcessBatchRequestV2::_internal_mutable_state_override() {
  return _impl_.state_override_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::executor::v1::OverrideAccountV2 >*
ProcessBatchRequestV2::mutable_state_override() {
  // @@protoc_insertion_point(field_mutable_map:executor.v1.ProcessBatchRequestV2.state_override)
  return _internal_mutable_state_override();
}

// .executor.v1.DebugV2 debug = 24;
inline bool ProcessBatchRequestV2::_internal_has_debug() const {
  return this != internal_default_instance() && debug_ != nullptr;
}
inline bool ProcessBatchRequestV2::has_debug() const {
  return _internal_has_debug();
}
inline void ProcessBatchRequestV2::clear_debug() {
  if (GetArena() == nullptr && debug_ != nullptr) {
    delete debug_;
  }
  debug_ = nullptr;
}
inline const ::executor::v1::DebugV2& ProcessBatchRequestV2::_internal_debug() const {
  const ::executor::v1::DebugV2* p = debug_;
  return p != nullptr ? *p : *reinterpret_cast<const ::executor::v1::DebugV2*>(
      &::executor::v1::_DebugV2_default_instance_);
}
inline const ::executor::v1::DebugV2& ProcessBatchRequestV2::debug() const {
  // @@protoc_insertion_point(field_get:executor.v1.ProcessBatchRequestV2.debug)
  return _internal_debug();
}
inline void ProcessBatchRequestV2::unsafe_arena_set_allocated_debug(
    ::executor::v1::DebugV2* debug) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(debug_);
  }
  debug_ = debug;
  if (debug) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:executor.v1.ProcessBatchRequestV2.debug)
}
inline ::executor::v1::DebugV2* ProcessBatchRequestV2::release_debug() {
  auto temp = unsafe_arena_release_debug();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::executor::v1::DebugV2* ProcessBatchRequestV2::unsafe_arena_release_debug() {
  // @@protoc_insertion_point(field_release:executor.v1.ProcessBatchRequestV2.debug)
  
  ::executor::v1::DebugV2* temp = debug_;
  debug_ = nullptr;
  return temp;
}
inline ::executor::v1::DebugV2* ProcessBatchRequestV2::_internal_mutable_debug() {
  
  if (debug_ == nullptr) {
    auto* p = CreateMaybeMessage<::executor::v1::DebugV2>(GetArena());
    debug_ = p;
  }
  return debug_;
}
inline ::executor::v1::DebugV2* ProcessBatchRequestV2::mutable_debug() {
  // @@protoc_insertion_point(field_mutable:executor.v1.ProcessBatchRequestV2.debug)
  return _internal_mutable_debug();
}
inline void ProcessBatchRequestV2::set_allocated_debug(::executor::v1::DebugV2* debug) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete debug_;
  }
  if (debug) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(debug);
    if (message_arena != submessage_arena) {
      debug = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, debug, submessage_arena);
    }
    
  } else {
    
  }
  debug_ = debug;
  // @@protoc_insertion_point(field_set_allocated:executor.v1.ProcessBatchRequestV2.debug)
}

// -------------------------------------------------------------------

// L1DataV2

// bytes global_exit_root = 1;
inline void L1DataV2::clear_global_exit_root() {
  _impl_.global_exit_root_.ClearToEmpty();
}
inline const std::string& L1DataV2::global_exit_root() const {
  // @@protoc_insertion_point(field_get:executor.v1.L1DataV2.global_exit_root)
  return _internal_global_exit_root();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void L1DataV2::set_global_exit_root(ArgT0&& arg0, ArgT... args) {
 
 _impl_.global_exit_root_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:executor.v1.L1DataV2.global_exit_root)
}
inline std::string* L1DataV2::mutable_global_exit_root() {
  std::string* _s = _internal_mutable_global_exit_root();
  // @@protoc_insertion_point(field_mutable:executor.v1.L1DataV2.global_exit_root)
  return _s;
}
inline const std::string& L1DataV2::_internal_global_exit_root() const {
  return _impl_.global_exit_root_.Get();
}
inline void L1DataV2::_internal_set_global_exit_root(const std::string& value) {
  
  _impl_.global_exit_root_.Set(value, GetArenaForAllocation());
}
inline std::string* L1DataV2::_internal_mutable_global_exit_root() {
  
  return _impl_.global_exit_root_.Mutable(GetArenaForAllocation());
}
inline std::string* L1DataV2::release_global_exit_root() {
  // @@protoc_insertion_point(field_release:executor.v1.L1DataV2.global_exit_root)
  return _impl_.global_exit_root_.Release();
}
inline void L1DataV2::set_allocated_global_exit_root(std::string* global_exit_root) {
  if (global_exit_root != nullptr) {
    
  } else {
    
  }
  _impl_.global_exit_root_.SetAllocated(global_exit_root, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.global_exit_root_.IsDefault()) {
    _impl_.global_exit_root_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:executor.v1.L1DataV2.global_exit_root)
}

// bytes block_hash_l1 = 2;
inline void L1DataV2::clear_block_hash_l1() {
  _impl_.block_hash_l1_.ClearToEmpty();
}
inline const std::string& L1DataV2::block_hash_l1() const {
  // @@protoc_insertion_point(field_get:executor.v1.L1DataV2.block_hash_l1)
  return _internal_block_hash_l1();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void L1DataV2::set_block_hash_l1(ArgT0&& arg0, ArgT... args) {
 
 _impl_.block_hash_l1_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:executor.v1.L1DataV2.block_hash_l1)
}
inline std::string* L1DataV2::mutable_block_hash_l1() {
  std::string* _s = _internal_mutable_block_hash_l1();
  // @@protoc_insertion_point(field_mutable:executor.v1.L1DataV2.block_hash_l1)
  return _s;
}
inline const std::string& L1DataV2::_internal_block_hash_l1() const {
  return _impl_.block_hash_l1_.Get();
}
inline void L1DataV2::_internal_set_block_hash_l1(const std::string& value) {
  
  _impl_.block_hash_l1_.Set(value, GetArenaForAllocation());
}
inline std::string* L1DataV2::_internal_mutable_block_hash_l1() {
  
  return _impl_.block_hash_l1_.Mutable(GetArenaForAllocation());
}
inline std::string* L1DataV2::release_block_hash_l1() {
  // @@protoc_insertion_point(field_release:executor.v1.L1DataV2.block_hash_l1)
  return _impl_.block_hash_l1_.Release();
}
inline void L1DataV2::set_allocated_block_hash_l1(std::string* block_hash_l1) {
  if (block_hash_l1 != nullptr) {
    
  } else {
    
  }
  _impl_.block_hash_l1_.SetAllocated(block_hash_l1, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.block_hash_l1_.IsDefault()) {
    _impl_.block_hash_l1_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:executor.v1.L1DataV2.block_hash_l1)
}

// uint64 min_timestamp = 3;
inline void L1DataV2::clear_min_timestamp() {
  _impl_.min_timestamp_ = uint64_t{0u};
}
inline uint64_t L1DataV2::_internal_min_timestamp() const {
  return _impl_.min_timestamp_;
}
inline uint64_t L1DataV2::min_timestamp() const {
  // @@protoc_insertion_point(field_get:executor.v1.L1DataV2.min_timestamp)
  return _internal_min_timestamp();
}
inline void L1DataV2::_internal_set_min_timestamp(uint64_t value) {
  
  _impl_.min_timestamp_ = value;
}
inline void L1DataV2::set_min_timestamp(uint64_t value) {
  _internal_set_min_timestamp(value);
  // @@protoc_insertion_point(field_set:executor.v1.L1DataV2.min_timestamp)
}

// repeated bytes smt_proof = 4;
inline int L1DataV2::_internal_smt_proof_size() const {
  return _impl_.smt_proof_.size();
}
inline int L1DataV2::smt_proof_size() const {
  return _internal_smt_proof_size();
}
inline void L1DataV2::clear_smt_proof() {
  _impl_.smt_proof_.Clear();
}
inline std::string* L1DataV2::add_smt_proof() {
  std::string* _s = _internal_add_smt_proof();
  // @@protoc_insertion_point(field_add_mutable:executor.v1.L1DataV2.smt_proof)
  return _s;
}
inline const std::string& L1DataV2::_internal_smt_proof(int index) const {
  return _impl_.smt_proof_.Get(index);
}
inline const std::string& L1DataV2::smt_proof(int index) const {
  // @@protoc_insertion_point(field_get:executor.v1.L1DataV2.smt_proof)
  return _internal_smt_proof(index);
}
inline std::string* L1DataV2::mutable_smt_proof(int index) {
  // @@protoc_insertion_point(field_mutable:executor.v1.L1DataV2.smt_proof)
  return _impl_.smt_proof_.Mutable(index);
}
inline void L1DataV2::set_smt_proof(int index, const std::string& value) {
  _impl_.smt_proof_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:executor.v1.L1DataV2.smt_proof)
}
inline void L1DataV2::set_smt_proof(int index, std::string&& value) {
  _impl_.smt_proof_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:executor.v1.L1DataV2.smt_proof)
}
inline void L1DataV2::set_smt_proof(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.smt_proof_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:executor.v1.L1DataV2.smt_proof)
}
inline void L1DataV2::set_smt_proof(int index, const void* value, size_t size) {
  _impl_.smt_proof_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:executor.v1.L1DataV2.smt_proof)
}
inline std::string* L1DataV2::_internal_add_smt_proof() {
  return _impl_.smt_proof_.Add();
}
inline void L1DataV2::add_smt_proof(const std::string& value) {
  _impl_.smt_proof_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:executor.v1.L1DataV2.smt_proof)
}
inline void L1DataV2::add_smt_proof(std::string&& value) {
  _impl_.smt_proof_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:executor.v1.L1DataV2.smt_proof)
}
inline void L1DataV2::add_smt_proof(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.smt_proof_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:executor.v1.L1DataV2.smt_proof)
}
inline void L1DataV2::add_smt_proof(const void* value, size_t size) {
  _impl_.smt_proof_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:executor.v1.L1DataV2.smt_proof)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
L1DataV2::smt_proof() const {
  // @@protoc_insertion_point(field_list:executor.v1.L1DataV2.smt_proof)
  return _impl_.smt_proof_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
L1DataV2::mutable_smt_proof() {
  // @@protoc_insertion_point(field_mutable_list:executor.v1.L1DataV2.smt_proof)
  return &_impl_.smt_proof_;
}

// -------------------------------------------------------------------

// DebugV2

// uint64 gas_limit = 1;
inline void DebugV2::clear_gas_limit() {
  gas_limit_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 DebugV2::_internal_gas_limit() const {
  return gas_limit_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 DebugV2::gas_limit() const {
  // @@protoc_insertion_point(field_get:executor.v1.DebugV2.gas_limit)
  return _internal_gas_limit();
}
inline void DebugV2::_internal_set_gas_limit(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  gas_limit_ = value;
}
inline void DebugV2::set_gas_limit(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_gas_limit(value);
  // @@protoc_insertion_point(field_set:executor.v1.DebugV2.gas_limit)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// ProcessBatchResponseV2

// bytes new_state_root = 1;
inline void ProcessBatchResponseV2::clear_new_state_root() {
  _impl_.new_state_root_.ClearToEmpty();
}
inline const std::string& ProcessBatchResponseV2::new_state_root() const {
  // @@protoc_insertion_point(field_get:executor.v1.ProcessBatchResponseV2.new_state_root)
  return _internal_new_state_root();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProcessBatchResponseV2::set_new_state_root(ArgT0&& arg0, ArgT... args) {
 
 _impl_.new_state_root_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:executor.v1.ProcessBatchResponseV2.new_state_root)
}
inline std::string* ProcessBatchResponseV2::mutable_new_state_root() {
  std::string* _s = _internal_mutable_new_state_root();
  // @@protoc_insertion_point(field_mutable:executor.v1.ProcessBatchResponseV2.new_state_root)
  return _s;
}
inline const std::string& ProcessBatchResponseV2::_internal_new_state_root() const {
  return _impl_.new_state_root_.Get();
}
inline void ProcessBatchResponseV2::_internal_set_new_state_root(const std::string& value) {
  
  _impl_.new_state_root_.Set(value, GetArenaForAllocation());
}
inline std::string* ProcessBatchResponseV2::_internal_mutable_new_state_root() {
  
  return _impl_.new_state_root_.Mutable(GetArenaForAllocation());
}
inline std::string* ProcessBatchResponseV2::release_new_state_root() {
  // @@protoc_insertion_point(field_release:executor.v1.ProcessBatchResponseV2.new_state_root)
  return _impl_.new_state_root_.Release();
}
inline void ProcessBatchResponseV2::set_allocated_new_state_root(std::string* new_state_root) {
  if (new_state_root != nullptr) {
    
  } else {
    
  }
  _impl_.new_state_root_.SetAllocated(new_state_root, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.new_state_root_.IsDefault()) {
    _impl_.new_state_root_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:executor.v1.ProcessBatchResponseV2.new_state_root)
}

// bytes new_acc_input_hash = 2;
inline void ProcessBatchResponseV2::clear_new_acc_input_hash() {
  _impl_.new_acc_input_hash_.ClearToEmpty();
}
inline const std::string& ProcessBatchResponseV2::new_acc_input_hash() const {
  // @@protoc_insertion_point(field_get:executor.v1.ProcessBatchResponseV2.new_acc_input_hash)
  return _internal_new_acc_input_hash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProcessBatchResponseV2::set_new_acc_input_hash(ArgT0&& arg0, ArgT... args) {
 
 _impl_.new_acc_input_hash_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:executor.v1.ProcessBatchResponseV2.new_acc_input_hash)
}
inline std::string* ProcessBatchResponseV2::mutable_new_acc_input_hash() {
  std::string* _s = _internal_mutable_new_acc_input_hash();
  // @@protoc_insertion_point(field_mutable:executor.v1.ProcessBatchResponseV2.new_acc_input_hash)
  return _s;
}
inline const std::string& ProcessBatchResponseV2::_internal_new_acc_input_hash() const {
  return _impl_.new_acc_input_hash_.Get();
}
inline void ProcessBatchResponseV2::_internal_set_new_acc_input_hash(const std::string& value) {
  
  _impl_.new_acc_input_hash_.Set(value, GetArenaForAllocation());
}
inline std::string* ProcessBatchResponseV2::_internal_mutable_new_acc_input_hash() {
  
  return _impl_.new_acc_input_hash_.Mutable(GetArenaForAllocation());
}
inline std::string* ProcessBatchResponseV2::release_new_acc_input_hash() {
  // @@protoc_insertion_point(field_release:executor.v1.ProcessBatchResponseV2.new_acc_input_hash)
  return _impl_.new_acc_input_hash_.Release();
}
inline void ProcessBatchResponseV2::set_allocated_new_acc_input_hash(std::string* new_acc_input_hash) {
  if (new_acc_input_hash != nullptr) {
    
  } else {
    
  }
  _impl_.new_acc_input_hash_.SetAllocated(new_acc_input_hash, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.new_acc_input_hash_.IsDefault()) {
    _impl_.new_acc_input_hash_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:executor.v1.ProcessBatchResponseV2.new_acc_input_hash)
}

// bytes new_local_exit_root = 3;
inline void ProcessBatchResponseV2::clear_new_local_exit_root() {
  _impl_.new_local_exit_root_.ClearToEmpty();
}
inline const std::string& ProcessBatchResponseV2::new_local_exit_root() const {
  // @@protoc_insertion_point(field_get:executor.v1.ProcessBatchResponseV2.new_local_exit_root)
  return _internal_new_local_exit_root();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProcessBatchResponseV2::set_new_local_exit_root(ArgT0&& arg0, ArgT... args) {
 
 _impl_.new_local_exit_root_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:executor.v1.ProcessBatchResponseV2.new_local_exit_root)
}
inline std::string* ProcessBatchResponseV2::mutable_new_local_exit_root() {
  std::string* _s = _internal_mutable_new_local_exit_root();
  // @@protoc_insertion_point(field_mutable:executor.v1.ProcessBatchResponseV2.new_local_exit_root)
  return _s;
}
inline const std::string& ProcessBatchResponseV2::_internal_new_local_exit_root() const {
  return _impl_.new_local_exit_root_.Get();
}
inline void ProcessBatchResponseV2::_internal_set_new_local_exit_root(const std::string& value) {
  
  _impl_.new_local_exit_root_.Set(value, GetArenaForAllocation());
}
inline std::string* ProcessBatchResponseV2::_internal_mutable_new_local_exit_root() {
  
  return _impl_.new_local_exit_root_.Mutable(GetArenaForAllocation());
}
inline std::string* ProcessBatchResponseV2::release_new_local_exit_root() {
  // @@protoc_insertion_point(field_release:executor.v1.ProcessBatchResponseV2.new_local_exit_root)
  return _impl_.new_local_exit_root_.Release();
}
inline void ProcessBatchResponseV2::set_allocated_new_local_exit_root(std::string* new_local_exit_root) {
  if (new_local_exit_root != nullptr) {
    
  } else {
    
  }
  _impl_.new_local_exit_root_.SetAllocated(new_local_exit_root, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.new_local_exit_root_.IsDefault()) {
    _impl_.new_local_exit_root_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:executor.v1.ProcessBatchResponseV2.new_local_exit_root)
}

// uint64 new_batch_num = 4;
inline void ProcessBatchResponseV2::clear_new_batch_num() {
  _impl_.new_batch_num_ = uint64_t{0u};
}
inline uint64_t ProcessBatchResponseV2::_internal_new_batch_num() const {
  return _impl_.new_batch_num_;
}
inline uint64_t ProcessBatchResponseV2::new_batch_num() const {
  // @@protoc_insertion_point(field_get:executor.v1.ProcessBatchResponseV2.new_batch_num)
  return _internal_new_batch_num();
}
inline void ProcessBatchResponseV2::_internal_set_new_batch_num(uint64_t value) {
  
  _impl_.new_batch_num_ = value;
}
inline void ProcessBatchResponseV2::set_new_batch_num(uint64_t value) {
  _internal_set_new_batch_num(value);
  // @@protoc_insertion_point(field_set:executor.v1.ProcessBatchResponseV2.new_batch_num)
}

// uint32 cnt_keccak_hashes = 5;
inline void ProcessBatchResponseV2::clear_cnt_keccak_hashes() {
  _impl_.cnt_keccak_hashes_ = 0u;
}
inline uint32_t ProcessBatchResponseV2::_internal_cnt_keccak_hashes() const {
  return _impl_.cnt_keccak_hashes_;
}
inline uint32_t ProcessBatchResponseV2::cnt_keccak_hashes() const {
  // @@protoc_insertion_point(field_get:executor.v1.ProcessBatchResponseV2.cnt_keccak_hashes)
  return _internal_cnt_keccak_hashes();
}
inline void ProcessBatchResponseV2::_internal_set_cnt_keccak_hashes(uint32_t value) {
  
  _impl_.cnt_keccak_hashes_ = value;
}
inline void ProcessBatchResponseV2::set_cnt_keccak_hashes(uint32_t value) {
  _internal_set_cnt_keccak_hashes(value);
  // @@protoc_insertion_point(field_set:executor.v1.ProcessBatchResponseV2.cnt_keccak_hashes)
}

// uint32 cnt_poseidon_hashes = 6;
inline void ProcessBatchResponseV2::clear_cnt_poseidon_hashes() {
  _impl_.cnt_poseidon_hashes_ = 0u;
}
inline uint32_t ProcessBatchResponseV2::_internal_cnt_poseidon_hashes() const {
  return _impl_.cnt_poseidon_hashes_;
}
inline uint32_t ProcessBatchResponseV2::cnt_poseidon_hashes() const {
  // @@protoc_insertion_point(field_get:executor.v1.ProcessBatchResponseV2.cnt_poseidon_hashes)
  return _internal_cnt_poseidon_hashes();
}
inline void ProcessBatchResponseV2::_internal_set_cnt_poseidon_hashes(uint32_t value) {
  
  _impl_.cnt_poseidon_hashes_ = value;
}
inline void ProcessBatchResponseV2::set_cnt_poseidon_hashes(uint32_t value) {
  _internal_set_cnt_poseidon_hashes(value);
  // @@protoc_insertion_point(field_set:executor.v1.ProcessBatchResponseV2.cnt_poseidon_hashes)
}

// uint32 cnt_poseidon_paddings = 7;
inline void ProcessBatchResponseV2::clear_cnt_poseidon_paddings() {
  _impl_.cnt_poseidon_paddings_ = 0u;
}
inline uint32_t ProcessBatchResponseV2::_internal_cnt_poseidon_paddings() const {
  return _impl_.cnt_poseidon_paddings_;
}
inline uint32_t ProcessBatchResponseV2::cnt_poseidon_paddings() const {
  // @@protoc_insertion_point(field_get:executor.v1.ProcessBatchResponseV2.cnt_poseidon_paddings)
  return _internal_cnt_poseidon_paddings();
}
inline void ProcessBatchResponseV2::_internal_set_cnt_poseidon_paddings(uint32_t value) {
  
  _impl_.cnt_poseidon_paddings_ = value;
}
inline void ProcessBatchResponseV2::set_cnt_poseidon_paddings(uint32_t value) {
  _internal_set_cnt_poseidon_paddings(value);
  // @@protoc_insertion_point(field_set:executor.v1.ProcessBatchResponseV2.cnt_poseidon_paddings)
}

// uint32 cnt_mem_aligns = 8;
inline void ProcessBatchResponseV2::clear_cnt_mem_aligns() {
  _impl_.cnt_mem_aligns_ = 0u;
}
inline uint32_t ProcessBatchResponseV2::_internal_cnt_mem_aligns() const {
  return _impl_.cnt_mem_aligns_;
}
inline uint32_t ProcessBatchResponseV2::cnt_mem_aligns() const {
  // @@protoc_insertion_point(field_get:executor.v1.ProcessBatchResponseV2.cnt_mem_aligns)
  return _internal_cnt_mem_aligns();
}
inline void ProcessBatchResponseV2::_internal_set_cnt_mem_aligns(uint32_t value) {
  
  _impl_.cnt_mem_aligns_ = value;
}
inline void ProcessBatchResponseV2::set_cnt_mem_aligns(uint32_t value) {
  _internal_set_cnt_mem_aligns(value);
  // @@protoc_insertion_point(field_set:executor.v1.ProcessBatchResponseV2.cnt_mem_aligns)
}

// uint32 cnt_arithmetics = 9;
inline void ProcessBatchResponseV2::clear_cnt_arithmetics() {
  _impl_.cnt_arithmetics_ = 0u;
}
inline uint32_t ProcessBatchResponseV2::_internal_cnt_arithmetics() const {
  return _impl_.cnt_arithmetics_;
}
inline uint32_t ProcessBatchResponseV2::cnt_arithmetics() const {
  // @@protoc_insertion_point(field_get:executor.v1.ProcessBatchResponseV2.cnt_arithmetics)
  return _internal_cnt_arithmetics();
}
inline void ProcessBatchResponseV2::_internal_set_cnt_arithmetics(uint32_t value) {
  
  _impl_.cnt_arithmetics_ = value;
}
inline void ProcessBatchResponseV2::set_cnt_arithmetics(uint32_t value) {
  _internal_set_cnt_arithmetics(value);
  // @@protoc_insertion_point(field_set:executor.v1.ProcessBatchResponseV2.cnt_arithmetics)
}

// uint32 cnt_binaries = 10;
inline void ProcessBatchResponseV2::clear_cnt_binaries() {
  _impl_.cnt_binaries_ = 0u;
}
inline uint32_t ProcessBatchResponseV2::_internal_cnt_binaries() const {
  return _impl_.cnt_binaries_;
}
inline uint32_t ProcessBatchResponseV2::cnt_binaries() const {
  // @@protoc_insertion_point(field_get:executor.v1.ProcessBatchResponseV2.cnt_binaries)
  return _internal_cnt_binaries();
}
inline void ProcessBatchResponseV2::_internal_set_cnt_binaries(uint32_t value) {
  
  _impl_.cnt_binaries_ = value;
}
inline void ProcessBatchResponseV2::set_cnt_binaries(uint32_t value) {
  _internal_set_cnt_binaries(value);
  // @@protoc_insertion_point(field_set:executor.v1.ProcessBatchResponseV2.cnt_binaries)
}

// uint32 cnt_steps = 11;
inline void ProcessBatchResponseV2::clear_cnt_steps() {
  _impl_.cnt_steps_ = 0u;
}
inline uint32_t ProcessBatchResponseV2::_internal_cnt_steps() const {
  return _impl_.cnt_steps_;
}
inline uint32_t ProcessBatchResponseV2::cnt_steps() const {
  // @@protoc_insertion_point(field_get:executor.v1.ProcessBatchResponseV2.cnt_steps)
  return _internal_cnt_steps();
}
inline void ProcessBatchResponseV2::_internal_set_cnt_steps(uint32_t value) {
  
  _impl_.cnt_steps_ = value;
}
inline void ProcessBatchResponseV2::set_cnt_steps(uint32_t value) {
  _internal_set_cnt_steps(value);
  // @@protoc_insertion_point(field_set:executor.v1.ProcessBatchResponseV2.cnt_steps)
}

// uint32 cnt_sha256_hashes = 12;
inline void ProcessBatchResponseV2::clear_cnt_sha256_hashes() {
  _impl_.cnt_sha256_hashes_ = 0u;
}
inline uint32_t ProcessBatchResponseV2::_internal_cnt_sha256_hashes() const {
  return _impl_.cnt_sha256_hashes_;
}
inline uint32_t ProcessBatchResponseV2::cnt_sha256_hashes() const {
  // @@protoc_insertion_point(field_get:executor.v1.ProcessBatchResponseV2.cnt_sha256_hashes)
  return _internal_cnt_sha256_hashes();
}
inline void ProcessBatchResponseV2::_internal_set_cnt_sha256_hashes(uint32_t value) {
  
  _impl_.cnt_sha256_hashes_ = value;
}
inline void ProcessBatchResponseV2::set_cnt_sha256_hashes(uint32_t value) {
  _internal_set_cnt_sha256_hashes(value);
  // @@protoc_insertion_point(field_set:executor.v1.ProcessBatchResponseV2.cnt_sha256_hashes)
}

// repeated .executor.v1.ProcessBlockResponseV2 block_responses = 13;
inline int ProcessBatchResponseV2::_internal_block_responses_size() const {
  return _impl_.block_responses_.size();
}
inline int ProcessBatchResponseV2::block_responses_size() const {
  return _internal_block_responses_size();
}
inline void ProcessBatchResponseV2::clear_block_responses() {
  _impl_.block_responses_.Clear();
}
inline ::executor::v1::ProcessBlockResponseV2* ProcessBatchResponseV2::mutable_block_responses(int index) {
  // @@protoc_insertion_point(field_mutable:executor.v1.ProcessBatchResponseV2.block_responses)
  return _impl_.block_responses_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::executor::v1::ProcessBlockResponseV2 >*
ProcessBatchResponseV2::mutable_block_responses() {
  // @@protoc_insertion_point(field_mutable_list:executor.v1.ProcessBatchResponseV2.block_responses)
  return &_impl_.block_responses_;
}
inline const ::executor::v1::ProcessBlockResponseV2& ProcessBatchResponseV2::_internal_block_responses(int index) const {
  return _impl_.block_responses_.Get(index);
}
inline const ::executor::v1::ProcessBlockResponseV2& ProcessBatchResponseV2::block_responses(int index) const {
  // @@protoc_insertion_point(field_get:executor.v1.ProcessBatchResponseV2.block_responses)
  return _internal_block_responses(index);
}
inline ::executor::v1::ProcessBlockResponseV2* ProcessBatchResponseV2::_internal_add_block_responses() {
  return _impl_.block_responses_.Add();
}
inline ::executor::v1::ProcessBlockResponseV2* ProcessBatchResponseV2::add_block_responses() {
  ::executor::v1::ProcessBlockResponseV2* _add = _internal_add_block_responses();
  // @@protoc_insertion_point(field_add:executor.v1.ProcessBatchResponseV2.block_responses)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::executor::v1::ProcessBlockResponseV2 >&
ProcessBatchResponseV2::block_responses() const {
  // @@protoc_insertion_point(field_list:executor.v1.ProcessBatchResponseV2.block_responses)
  return _impl_.block_responses_;
}

// .executor.v1.ExecutorError error = 14;
inline void ProcessBatchResponseV2::clear_error() {
  _impl_.error_ = 0;
}
inline ::executor::v1::ExecutorError ProcessBatchResponseV2::_internal_error() const {
  return static_cast< ::executor::v1::ExecutorError >(_impl_.error_);
}
inline ::executor::v1::ExecutorError ProcessBatchResponseV2::error() const {
  // @@protoc_insertion_point(field_get:executor.v1.ProcessBatchResponseV2.error)
  return _internal_error();
}
inline void ProcessBatchResponseV2::_internal_set_error(::executor::v1::ExecutorError value) {
  
  _impl_.error_ = value;
}
inline void ProcessBatchResponseV2::set_error(::executor::v1::ExecutorError value) {
  _internal_set_error(value);
  // @@protoc_insertion_point(field_set:executor.v1.ProcessBatchResponseV2.error)
}

// map<string, .executor.v1.InfoReadWriteV2> read_write_addresses = 15;
inline int ProcessBatchResponseV2::_internal_read_write_addresses_size() const {
  return _impl_.read_write_addresses_.size();
}
inline int ProcessBatchResponseV2::read_write_addresses_size() const {
  return _internal_read_write_addresses_size();
}
inline void ProcessBatchResponseV2::clear_read_write_addresses() {
  _impl_.read_write_addresses_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::executor::v1::InfoReadWriteV2 >&
ProcessBatchResponseV2::_internal_read_write_addresses() const {
  return _impl_.read_write_addresses_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::executor::v1::InfoReadWriteV2 >&
ProcessBatchResponseV2::read_write_addresses() const {
  // @@protoc_insertion_point(field_map:executor.v1.ProcessBatchResponseV2.read_write_addresses)
  return _internal_read_write_addresses();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::executor::v1::InfoReadWriteV2 >*
ProcessBatchResponseV2::_internal_mutable_read_write_addresses() {
  return _impl_.read_write_addresses_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::executor::v1::InfoReadWriteV2 >*
ProcessBatchResponseV2::mutable_read_write_addresses() {
  // @@protoc_insertion_point(field_mutable_map:executor.v1.ProcessBatchResponseV2.read_write_addresses)
  return _internal_mutable_read_write_addresses();
}

// uint64 flush_id = 16;
inline void ProcessBatchResponseV2::clear_flush_id() {
  _impl_.flush_id_ = uint64_t{0u};
}
inline uint64_t ProcessBatchResponseV2::_internal_flush_id() const {
  return _impl_.flush_id_;
}
inline uint64_t ProcessBatchResponseV2::flush_id() const {
  // @@protoc_insertion_point(field_get:executor.v1.ProcessBatchResponseV2.flush_id)
  return _internal_flush_id();
}
inline void ProcessBatchResponseV2::_internal_set_flush_id(uint64_t value) {
  
  _impl_.flush_id_ = value;
}
inline void ProcessBatchResponseV2::set_flush_id(uint64_t value) {
  _internal_set_flush_id(value);
  // @@protoc_insertion_point(field_set:executor.v1.ProcessBatchResponseV2.flush_id)
}

// uint64 stored_flush_id = 17;
inline void ProcessBatchResponseV2::clear_stored_flush_id() {
  _impl_.stored_flush_id_ = uint64_t{0u};
}
inline uint64_t ProcessBatchResponseV2::_internal_stored_flush_id() const {
  return _impl_.stored_flush_id_;
}
inline uint64_t ProcessBatchResponseV2::stored_flush_id() const {
  // @@protoc_insertion_point(field_get:executor.v1.ProcessBatchResponseV2.stored_flush_id)
  return _internal_stored_flush_id();
}
inline void ProcessBatchResponseV2::_internal_set_stored_flush_id(uint64_t value) {
  
  _impl_.stored_flush_id_ = value;
}
inline void ProcessBatchResponseV2::set_stored_flush_id(uint64_t value) {
  _internal_set_stored_flush_id(value);
  // @@protoc_insertion_point(field_set:executor.v1.ProcessBatchResponseV2.stored_flush_id)
}

// string prover_id = 18;
inline void ProcessBatchResponseV2::clear_prover_id() {
  _impl_.prover_id_.ClearToEmpty();
}
inline const std::string& ProcessBatchResponseV2::prover_id() const {
  // @@protoc_insertion_point(field_get:executor.v1.ProcessBatchResponseV2.prover_id)
  return _internal_prover_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProcessBatchResponseV2::set_prover_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.prover_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:executor.v1.ProcessBatchResponseV2.prover_id)
}
inline std::string* ProcessBatchResponseV2::mutable_prover_id() {
  std::string* _s = _internal_mutable_prover_id();
  // @@protoc_insertion_point(field_mutable:executor.v1.ProcessBatchResponseV2.prover_id)
  return _s;
}
inline const std::string& ProcessBatchResponseV2::_internal_prover_id() const {
  return _impl_.prover_id_.Get();
}
inline void ProcessBatchResponseV2::_internal_set_prover_id(const std::string& value) {
  
  _impl_.prover_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ProcessBatchResponseV2::_internal_mutable_prover_id() {
  
  return _impl_.prover_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ProcessBatchResponseV2::release_prover_id() {
  // @@protoc_insertion_point(field_release:executor.v1.ProcessBatchResponseV2.prover_id)
  return _impl_.prover_id_.Release();
}
inline void ProcessBatchResponseV2::set_allocated_prover_id(std::string* prover_id) {
  if (prover_id != nullptr) {
    
  } else {
    
  }
  _impl_.prover_id_.SetAllocated(prover_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.prover_id_.IsDefault()) {
    _impl_.prover_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:executor.v1.ProcessBatchResponseV2.prover_id)
}

// uint64 gas_used = 19;
inline void ProcessBatchResponseV2::clear_gas_used() {
  _impl_.gas_used_ = uint64_t{0u};
}
inline uint64_t ProcessBatchResponseV2::_internal_gas_used() const {
  return _impl_.gas_used_;
}
inline uint64_t ProcessBatchResponseV2::gas_used() const {
  // @@protoc_insertion_point(field_get:executor.v1.ProcessBatchResponseV2.gas_used)
  return _internal_gas_used();
}
inline void ProcessBatchResponseV2::_internal_set_gas_used(uint64_t value) {
  
  _impl_.gas_used_ = value;
}
inline void ProcessBatchResponseV2::set_gas_used(uint64_t value) {
  _internal_set_gas_used(value);
  // @@protoc_insertion_point(field_set:executor.v1.ProcessBatchResponseV2.gas_used)
}

// repeated bytes smt_keys = 20;
inline int ProcessBatchResponseV2::_internal_smt_keys_size() const {
  return _impl_.smt_keys_.size();
}
inline int ProcessBatchResponseV2::smt_keys_size() const {
  return _internal_smt_keys_size();
}
inline void ProcessBatchResponseV2::clear_smt_keys() {
  _impl_.smt_keys_.Clear();
}
inline std::string* ProcessBatchResponseV2::add_smt_keys() {
  std::string* _s = _internal_add_smt_keys();
  // @@protoc_insertion_point(field_add_mutable:executor.v1.ProcessBatchResponseV2.smt_keys)
  return _s;
}
inline const std::string& ProcessBatchResponseV2::_internal_smt_keys(int index) const {
  return _impl_.smt_keys_.Get(index);
}
inline const std::string& ProcessBatchResponseV2::smt_keys(int index) const {
  // @@protoc_insertion_point(field_get:executor.v1.ProcessBatchResponseV2.smt_keys)
  return _internal_smt_keys(index);
}
inline std::string* ProcessBatchResponseV2::mutable_smt_keys(int index) {
  // @@protoc_insertion_point(field_mutable:executor.v1.ProcessBatchResponseV2.smt_keys)
  return _impl_.smt_keys_.Mutable(index);
}
inline void ProcessBatchResponseV2::set_smt_keys(int index, const std::string& value) {
  _impl_.smt_keys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:executor.v1.ProcessBatchResponseV2.smt_keys)
}
inline void ProcessBatchResponseV2::set_smt_keys(int index, std::string&& value) {
  _impl_.smt_keys_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:executor.v1.ProcessBatchResponseV2.smt_keys)
}
inline void ProcessBatchResponseV2::set_smt_keys(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.smt_keys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:executor.v1.ProcessBatchResponseV2.smt_keys)
}
inline void ProcessBatchResponseV2::set_smt_keys(int index, const void* value, size_t size) {
  _impl_.smt_keys_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:executor.v1.ProcessBatchResponseV2.smt_keys)
}
inline std::string* ProcessBatchResponseV2::_internal_add_smt_keys() {
  return _impl_.smt_keys_.Add();
}
inline void ProcessBatchResponseV2::add_smt_keys(const std::string& value) {
  _impl_.smt_keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:executor.v1.ProcessBatchResponseV2.smt_keys)
}
inline void ProcessBatchResponseV2::add_smt_keys(std::string&& value) {
  _impl_.smt_keys_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:executor.v1.ProcessBatchResponseV2.smt_keys)
}
inline void ProcessBatchResponseV2::add_smt_keys(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.smt_keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:executor.v1.ProcessBatchResponseV2.smt_keys)
}
inline void ProcessBatchResponseV2::add_smt_keys(const void* value, size_t size) {
  _impl_.smt_keys_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:executor.v1.ProcessBatchResponseV2.smt_keys)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ProcessBatchResponseV2::smt_keys() const {
  // @@protoc_insertion_point(field_list:executor.v1.ProcessBatchResponseV2.smt_keys)
  return _impl_.smt_keys_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ProcessBatchResponseV2::mutable_smt_keys() {
  // @@protoc_insertion_point(field_mutable_list:executor.v1.ProcessBatchResponseV2.smt_keys)
  return &_impl_.smt_keys_;
}

// repeated bytes program_keys = 21;
inline int ProcessBatchResponseV2::_internal_program_keys_size() const {
  return _impl_.program_keys_.size();
}
inline int ProcessBatchResponseV2::program_keys_size() const {
  return _internal_program_keys_size();
}
inline void ProcessBatchResponseV2::clear_program_keys() {
  _impl_.program_keys_.Clear();
}
inline std::string* ProcessBatchResponseV2::add_program_keys() {
  std::string* _s = _internal_add_program_keys();
  // @@protoc_insertion_point(field_add_mutable:executor.v1.ProcessBatchResponseV2.program_keys)
  return _s;
}
inline const std::string& ProcessBatchResponseV2::_internal_program_keys(int index) const {
  return _impl_.program_keys_.Get(index);
}
inline const std::string& ProcessBatchResponseV2::program_keys(int index) const {
  // @@protoc_insertion_point(field_get:executor.v1.ProcessBatchResponseV2.program_keys)
  return _internal_program_keys(index);
}
inline std::string* ProcessBatchResponseV2::mutable_program_keys(int index) {
  // @@protoc_insertion_point(field_mutable:executor.v1.ProcessBatchResponseV2.program_keys)
  return _impl_.program_keys_.Mutable(index);
}
inline void ProcessBatchResponseV2::set_program_keys(int index, const std::string& value) {
  _impl_.program_keys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:executor.v1.ProcessBatchResponseV2.program_keys)
}
inline void ProcessBatchResponseV2::set_program_keys(int index, std::string&& value) {
  _impl_.program_keys_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:executor.v1.ProcessBatchResponseV2.program_keys)
}
inline void ProcessBatchResponseV2::set_program_keys(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.program_keys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:executor.v1.ProcessBatchResponseV2.program_keys)
}
inline void ProcessBatchResponseV2::set_program_keys(int index, const void* value, size_t size) {
  _impl_.program_keys_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:executor.v1.ProcessBatchResponseV2.program_keys)
}
inline std::string* ProcessBatchResponseV2::_internal_add_program_keys() {
  return _impl_.program_keys_.Add();
}
inline void ProcessBatchResponseV2::add_program_keys(const std::string& value) {
  _impl_.program_keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:executor.v1.ProcessBatchResponseV2.program_keys)
}
inline void ProcessBatchResponseV2::add_program_keys(std::string&& value) {
  _impl_.program_keys_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:executor.v1.ProcessBatchResponseV2.program_keys)
}
inline void ProcessBatchResponseV2::add_program_keys(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.program_keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:executor.v1.ProcessBatchResponseV2.program_keys)
}
inline void ProcessBatchResponseV2::add_program_keys(const void* value, size_t size) {
  _impl_.program_keys_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:executor.v1.ProcessBatchResponseV2.program_keys)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ProcessBatchResponseV2::program_keys() const {
  // @@protoc_insertion_point(field_list:executor.v1.ProcessBatchResponseV2.program_keys)
  return _impl_.program_keys_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ProcessBatchResponseV2::mutable_program_keys() {
  // @@protoc_insertion_point(field_mutable_list:executor.v1.ProcessBatchResponseV2.program_keys)
  return &_impl_.program_keys_;
}

// uint64 fork_id = 22;
inline void ProcessBatchResponseV2::clear_fork_id() {
  _impl_.fork_id_ = uint64_t{0u};
}
inline uint64_t ProcessBatchResponseV2::_internal_fork_id() const {
  return _impl_.fork_id_;
}
inline uint64_t ProcessBatchResponseV2::fork_id() const {
  // @@protoc_insertion_point(field_get:executor.v1.ProcessBatchResponseV2.fork_id)
  return _internal_fork_id();
}
inline void ProcessBatchResponseV2::_internal_set_fork_id(uint64_t value) {
  
  _impl_.fork_id_ = value;
}
inline void ProcessBatchResponseV2::set_fork_id(uint64_t value) {
  _internal_set_fork_id(value);
  // @@protoc_insertion_point(field_set:executor.v1.ProcessBatchResponseV2.fork_id)
}

// -------------------------------------------------------------------

// TraceConfigV2

// uint32 disable_storage = 1;
inline void TraceConfigV2::clear_disable_storage() {
  _impl_.disable_storage_ = 0u;
}
inline uint32_t TraceConfigV2::_internal_disable_storage() const {
  return _impl_.disable_storage_;
}
inline uint32_t TraceConfigV2::disable_storage() const {
  // @@protoc_insertion_point(field_get:executor.v1.TraceConfigV2.disable_storage)
  return _internal_disable_storage();
}
inline void TraceConfigV2::_internal_set_disable_storage(uint32_t value) {
  
  _impl_.disable_storage_ = value;
}
inline void TraceConfigV2::set_disable_storage(uint32_t value) {
  _internal_set_disable_storage(value);
  // @@protoc_insertion_point(field_set:executor.v1.TraceConfigV2.disable_storage)
}

// uint32 disable_stack = 2;
inline void TraceConfigV2::clear_disable_stack() {
  _impl_.disable_stack_ = 0u;
}
inline uint32_t TraceConfigV2::_internal_disable_stack() const {
  return _impl_.disable_stack_;
}
inline uint32_t TraceConfigV2::disable_stack() const {
  // @@protoc_insertion_point(field_get:executor.v1.TraceConfigV2.disable_stack)
  return _internal_disable_stack();
}
inline void TraceConfigV2::_internal_set_disable_stack(uint32_t value) {
  
  _impl_.disable_stack_ = value;
}
inline void TraceConfigV2::set_disable_stack(uint32_t value) {
  _internal_set_disable_stack(value);
  // @@protoc_insertion_point(field_set:executor.v1.TraceConfigV2.disable_stack)
}

// uint32 enable_memory = 3;
inline void TraceConfigV2::clear_enable_memory() {
  _impl_.enable_memory_ = 0u;
}
inline uint32_t TraceConfigV2::_internal_enable_memory() const {
  return _impl_.enable_memory_;
}
inline uint32_t TraceConfigV2::enable_memory() const {
  // @@protoc_insertion_point(field_get:executor.v1.TraceConfigV2.enable_memory)
  return _internal_enable_memory();
}
inline void TraceConfigV2::_internal_set_enable_memory(uint32_t value) {
  
  _impl_.enable_memory_ = value;
}
inline void TraceConfigV2::set_enable_memory(uint32_t value) {
  _internal_set_enable_memory(value);
  // @@protoc_insertion_point(field_set:executor.v1.TraceConfigV2.enable_memory)
}

// uint32 enable_return_data = 4;
inline void TraceConfigV2::clear_enable_return_data() {
  _impl_.enable_return_data_ = 0u;
}
inline uint32_t TraceConfigV2::_internal_enable_return_data() const {
  return _impl_.enable_return_data_;
}
inline uint32_t TraceConfigV2::enable_return_data() const {
  // @@protoc_insertion_point(field_get:executor.v1.TraceConfigV2.enable_return_data)
  return _internal_enable_return_data();
}
inline void TraceConfigV2::_internal_set_enable_return_data(uint32_t value) {
  
  _impl_.enable_return_data_ = value;
}
inline void TraceConfigV2::set_enable_return_data(uint32_t value) {
  _internal_set_enable_return_data(value);
  // @@protoc_insertion_point(field_set:executor.v1.TraceConfigV2.enable_return_data)
}

// bytes tx_hash_to_generate_full_trace = 5;
inline void TraceConfigV2::clear_tx_hash_to_generate_full_trace() {
  _impl_.tx_hash_to_generate_full_trace_.ClearToEmpty();
}
inline const std::string& TraceConfigV2::tx_hash_to_generate_full_trace() const {
  // @@protoc_insertion_point(field_get:executor.v1.TraceConfigV2.tx_hash_to_generate_full_trace)
  return _internal_tx_hash_to_generate_full_trace();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TraceConfigV2::set_tx_hash_to_generate_full_trace(ArgT0&& arg0, ArgT... args) {
 
 _impl_.tx_hash_to_generate_full_trace_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:executor.v1.TraceConfigV2.tx_hash_to_generate_full_trace)
}
inline std::string* TraceConfigV2::mutable_tx_hash_to_generate_full_trace() {
  std::string* _s = _internal_mutable_tx_hash_to_generate_full_trace();
  // @@protoc_insertion_point(field_mutable:executor.v1.TraceConfigV2.tx_hash_to_generate_full_trace)
  return _s;
}
inline const std::string& TraceConfigV2::_internal_tx_hash_to_generate_full_trace() const {
  return _impl_.tx_hash_to_generate_full_trace_.Get();
}
inline void TraceConfigV2::_internal_set_tx_hash_to_generate_full_trace(const std::string& value) {
  
  _impl_.tx_hash_to_generate_full_trace_.Set(value, GetArenaForAllocation());
}
inline std::string* TraceConfigV2::_internal_mutable_tx_hash_to_generate_full_trace() {
  
  return _impl_.tx_hash_to_generate_full_trace_.Mutable(GetArenaForAllocation());
}
inline std::string* TraceConfigV2::release_tx_hash_to_generate_full_trace() {
  // @@protoc_insertion_point(field_release:executor.v1.TraceConfigV2.tx_hash_to_generate_full_trace)
  return _impl_.tx_hash_to_generate_full_trace_.Release();
}
inline void TraceConfigV2::set_allocated_tx_hash_to_generate_full_trace(std::string* tx_hash_to_generate_full_trace) {
  if (tx_hash_to_generate_full_trace != nullptr) {
    
  } else {
    
  }
  _impl_.tx_hash_to_generate_full_trace_.SetAllocated(tx_hash_to_generate_full_trace, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.tx_hash_to_generate_full_trace_.IsDefault()) {
    _impl_.tx_hash_to_generate_full_trace_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:executor.v1.TraceConfigV2.tx_hash_to_generate_full_trace)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// OverrideAccountV2

// bytes balance = 1;
inline void OverrideAccountV2::clear_balance() {
  _impl_.balance_.ClearToEmpty();
}
inline const std::string& OverrideAccountV2::balance() const {
  // @@protoc_insertion_point(field_get:executor.v1.OverrideAccountV2.balance)
  return _internal_balance();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OverrideAccountV2::set_balance(ArgT0&& arg0, ArgT... args) {
 
 _impl_.balance_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:executor.v1.OverrideAccountV2.balance)
}
inline std::string* OverrideAccountV2::mutable_balance() {
  std::string* _s = _internal_mutable_balance();
  // @@protoc_insertion_point(field_mutable:executor.v1.OverrideAccountV2.balance)
  return _s;
}
inline const std::string& OverrideAccountV2::_internal_balance() const {
  return _impl_.balance_.Get();
}
inline void OverrideAccountV2::_internal_set_balance(const std::string& value) {
  
  _impl_.balance_.Set(value, GetArenaForAllocation());
}
inline std::string* OverrideAccountV2::_internal_mutable_balance() {
  
  return _impl_.balance_.Mutable(GetArenaForAllocation());
}
inline std::string* OverrideAccountV2::release_balance() {
  // @@protoc_insertion_point(field_release:executor.v1.OverrideAccountV2.balance)
  return _impl_.balance_.Release();
}
inline void OverrideAccountV2::set_allocated_balance(std::string* balance) {
  if (balance != nullptr) {
    
  } else {
    
  }
  _impl_.balance_.SetAllocated(balance, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.balance_.IsDefault()) {
    _impl_.balance_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:executor.v1.OverrideAccountV2.balance)
}

// uint64 nonce = 2;
inline void OverrideAccountV2::clear_nonce() {
  _impl_.nonce_ = uint64_t{0u};
}
inline uint64_t OverrideAccountV2::_internal_nonce() const {
  return _impl_.nonce_;
}
inline uint64_t OverrideAccountV2::nonce() const {
  // @@protoc_insertion_point(field_get:executor.v1.OverrideAccountV2.nonce)
  return _internal_nonce();
}
inline void OverrideAccountV2::_internal_set_nonce(uint64_t value) {
  
  _impl_.nonce_ = value;
}
inline void OverrideAccountV2::set_nonce(uint64_t value) {
  _internal_set_nonce(value);
  // @@protoc_insertion_point(field_set:executor.v1.OverrideAccountV2.nonce)
}

// bytes code = 3;
inline void OverrideAccountV2::clear_code() {
  _impl_.code_.ClearToEmpty();
}
inline const std::string& OverrideAccountV2::code() const {
  // @@protoc_insertion_point(field_get:executor.v1.OverrideAccountV2.code)
  return _internal_code();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OverrideAccountV2::set_code(ArgT0&& arg0, ArgT... args) {
 
 _impl_.code_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:executor.v1.OverrideAccountV2.code)
}
inline std::string* OverrideAccountV2::mutable_code() {
  std::string* _s = _internal_mutable_code();
  // @@protoc_insertion_point(field_mutable:executor.v1.OverrideAccountV2.code)
  return _s;
}
inline const std::string& OverrideAccountV2::_internal_code() const {
  return _impl_.code_.Get();
}
inline void OverrideAccountV2::_internal_set_code(const std::string& value) {
  
  _impl_.code_.Set(value, GetArenaForAllocation());
}
inline std::string* OverrideAccountV2::_internal_mutable_code() {
  
  return _impl_.code_.Mutable(GetArenaForAllocation());
}
inline std::string* OverrideAccountV2::release_code() {
  // @@protoc_insertion_point(field_release:executor.v1.OverrideAccountV2.code)
  return _impl_.code_.Release();
}
inline void OverrideAccountV2::set_allocated_code(std::string* code) {
  if (code != nullptr) {
    
  } else {
    
  }
  _impl_.code_.SetAllocated(code, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.code_.IsDefault()) {
    _impl_.code_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:executor.v1.OverrideAccountV2.code)
}

// map<string, string> state = 4;
inline int OverrideAccountV2::_internal_state_size() const {
  return _impl_.state_.size();
}
inline int OverrideAccountV2::state_size() const {
  return _internal_state_size();
}
inline void OverrideAccountV2::clear_state() {
  _impl_.state_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
OverrideAccountV2::_internal_state() const {
  return _impl_.state_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
OverrideAccountV2::state() const {
  // @@protoc_insertion_point(field_map:executor.v1.OverrideAccountV2.state)
  return _internal_state();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
OverrideAccountV2::_internal_mutable_state() {
  return _impl_.state_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
OverrideAccountV2::mutable_state() {
  // @@protoc_insertion_point(field_mutable_map:executor.v1.OverrideAccountV2.state)
  return _internal_mutable_state();
}

// map<string, string> state_diff = 5;
inline int OverrideAccountV2::_internal_state_diff_size() const {
  return _impl_.state_diff_.size();
}
inline int OverrideAccountV2::state_diff_size() const {
  return _internal_state_diff_size();
}
inline void OverrideAccountV2::clear_state_diff() {
  _impl_.state_diff_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
OverrideAccountV2::_internal_state_diff() const {
  return _impl_.state_diff_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
OverrideAccountV2::state_diff() const {
  // @@protoc_insertion_point(field_map:executor.v1.OverrideAccountV2.state_diff)
  return _internal_state_diff();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
OverrideAccountV2::_internal_mutable_state_diff() {
  return _impl_.state_diff_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
OverrideAccountV2::mutable_state_diff() {
  // @@protoc_insertion_point(field_mutable_map:executor.v1.OverrideAccountV2.state_diff)
  return _internal_mutable_state_diff();
}

// -------------------------------------------------------------------

// InfoReadWriteV2

// string nonce = 1;
inline void InfoReadWriteV2::clear_nonce() {
  _impl_.nonce_.ClearToEmpty();
}
inline const std::string& InfoReadWriteV2::nonce() const {
  // @@protoc_insertion_point(field_get:executor.v1.InfoReadWriteV2.nonce)
  return _internal_nonce();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InfoReadWriteV2::set_nonce(ArgT0&& arg0, ArgT... args) {
 
 _impl_.nonce_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:executor.v1.InfoReadWriteV2.nonce)
}
inline std::string* InfoReadWriteV2::mutable_nonce() {
  std::string* _s = _internal_mutable_nonce();
  // @@protoc_insertion_point(field_mutable:executor.v1.InfoReadWriteV2.nonce)
  return _s;
}
inline const std::string& InfoReadWriteV2::_internal_nonce() const {
  return _impl_.nonce_.Get();
}
inline void InfoReadWriteV2::_internal_set_nonce(const std::string& value) {
  
  _impl_.nonce_.Set(value, GetArenaForAllocation());
}
inline std::string* InfoReadWriteV2::_internal_mutable_nonce() {
  
  return _impl_.nonce_.Mutable(GetArenaForAllocation());
}
inline std::string* InfoReadWriteV2::release_nonce() {
  // @@protoc_insertion_point(field_release:executor.v1.InfoReadWriteV2.nonce)
  return _impl_.nonce_.Release();
}
inline void InfoReadWriteV2::set_allocated_nonce(std::string* nonce) {
  if (nonce != nullptr) {
    
  } else {
    
  }
  _impl_.nonce_.SetAllocated(nonce, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.nonce_.IsDefault()) {
    _impl_.nonce_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:executor.v1.InfoReadWriteV2.nonce)
}

// string balance = 2;
inline void InfoReadWriteV2::clear_balance() {
  _impl_.balance_.ClearToEmpty();
}
inline const std::string& InfoReadWriteV2::balance() const {
  // @@protoc_insertion_point(field_get:executor.v1.InfoReadWriteV2.balance)
  return _internal_balance();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InfoReadWriteV2::set_balance(ArgT0&& arg0, ArgT... args) {
 
 _impl_.balance_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:executor.v1.InfoReadWriteV2.balance)
}
inline std::string* InfoReadWriteV2::mutable_balance() {
  std::string* _s = _internal_mutable_balance();
  // @@protoc_insertion_point(field_mutable:executor.v1.InfoReadWriteV2.balance)
  return _s;
}
inline const std::string& InfoReadWriteV2::_internal_balance() const {
  return _impl_.balance_.Get();
}
inline void InfoReadWriteV2::_internal_set_balance(const std::string& value) {
  
  _impl_.balance_.Set(value, GetArenaForAllocation());
}
inline std::string* InfoReadWriteV2::_internal_mutable_balance() {
  
  return _impl_.balance_.Mutable(GetArenaForAllocation());
}
inline std::string* InfoReadWriteV2::release_balance() {
  // @@protoc_insertion_point(field_release:executor.v1.InfoReadWriteV2.balance)
  return _impl_.balance_.Release();
}
inline void InfoReadWriteV2::set_allocated_balance(std::string* balance) {
  if (balance != nullptr) {
    
  } else {
    
  }
  _impl_.balance_.SetAllocated(balance, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.balance_.IsDefault()) {
    _impl_.balance_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:executor.v1.InfoReadWriteV2.balance)
}

// -------------------------------------------------------------------

// FullTraceV2

// .executor.v1.TransactionContextV2 context = 1;
inline bool FullTraceV2::_internal_has_context() const {
  return this != internal_default_instance() && _impl_.context_ != nullptr;
}
inline bool FullTraceV2::has_context() const {
  return _internal_has_context();
}
inline void FullTraceV2::clear_context() {
  if (GetArenaForAllocation() == nullptr && _impl_.context_ != nullptr) {
    delete _impl_.context_;
  }
  _impl_.context_ = nullptr;
}
inline const ::executor::v1::TransactionContextV2& FullTraceV2::_internal_context() const {
  const ::executor::v1::TransactionContextV2* p = _impl_.context_;
  return p != nullptr ? *p : reinterpret_cast<const ::executor::v1::TransactionContextV2&>(
      ::executor::v1::_TransactionContextV2_default_instance_);
}
inline const ::executor::v1::TransactionContextV2& FullTraceV2::context() const {
  // @@protoc_insertion_point(field_get:executor.v1.FullTraceV2.context)
  return _internal_context();
}
inline void FullTraceV2::unsafe_arena_set_allocated_context(
    ::executor::v1::TransactionContextV2* context) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.context_);
  }
  _impl_.context_ = context;
  if (context) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:executor.v1.FullTraceV2.context)
}
inline ::executor::v1::TransactionContextV2* FullTraceV2::release_context() {
  
  ::executor::v1::TransactionContextV2* temp = _impl_.context_;
  _impl_.context_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::executor::v1::TransactionContextV2* FullTraceV2::unsafe_arena_release_context() {
  // @@protoc_insertion_point(field_release:executor.v1.FullTraceV2.context)
  
  ::executor::v1::TransactionContextV2* temp = _impl_.context_;
  _impl_.context_ = nullptr;
  return temp;
}
inline ::executor::v1::TransactionContextV2* FullTraceV2::_internal_mutable_context() {
  
  if (_impl_.context_ == nullptr) {
    auto* p = CreateMaybeMessage<::executor::v1::TransactionContextV2>(GetArenaForAllocation());
    _impl_.context_ = p;
  }
  return _impl_.context_;
}
inline ::executor::v1::TransactionContextV2* FullTraceV2::mutable_context() {
  ::executor::v1::TransactionContextV2* _msg = _internal_mutable_context();
  // @@protoc_insertion_point(field_mutable:executor.v1.FullTraceV2.context)
  return _msg;
}
inline void FullTraceV2::set_allocated_context(::executor::v1::TransactionContextV2* context) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.context_;
  }
  if (context) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(context);
    if (message_arena != submessage_arena) {
      context = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, context, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.context_ = context;
  // @@protoc_insertion_point(field_set_allocated:executor.v1.FullTraceV2.context)
}

// repeated .executor.v1.TransactionStepV2 steps = 2;
inline int FullTraceV2::_internal_steps_size() const {
  return _impl_.steps_.size();
}
inline int FullTraceV2::steps_size() const {
  return _internal_steps_size();
}
inline void FullTraceV2::clear_steps() {
  _impl_.steps_.Clear();
}
inline ::executor::v1::TransactionStepV2* FullTraceV2::mutable_steps(int index) {
  // @@protoc_insertion_point(field_mutable:executor.v1.FullTraceV2.steps)
  return _impl_.steps_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::executor::v1::TransactionStepV2 >*
FullTraceV2::mutable_steps() {
  // @@protoc_insertion_point(field_mutable_list:executor.v1.FullTraceV2.steps)
  return &_impl_.steps_;
}
inline const ::executor::v1::TransactionStepV2& FullTraceV2::_internal_steps(int index) const {
  return _impl_.steps_.Get(index);
}
inline const ::executor::v1::TransactionStepV2& FullTraceV2::steps(int index) const {
  // @@protoc_insertion_point(field_get:executor.v1.FullTraceV2.steps)
  return _internal_steps(index);
}
inline ::executor::v1::TransactionStepV2* FullTraceV2::_internal_add_steps() {
  return _impl_.steps_.Add();
}
inline ::executor::v1::TransactionStepV2* FullTraceV2::add_steps() {
  ::executor::v1::TransactionStepV2* _add = _internal_add_steps();
  // @@protoc_insertion_point(field_add:executor.v1.FullTraceV2.steps)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::executor::v1::TransactionStepV2 >&
FullTraceV2::steps() const {
  // @@protoc_insertion_point(field_list:executor.v1.FullTraceV2.steps)
  return _impl_.steps_;
}

// -------------------------------------------------------------------

// TransactionContextV2

// string type = 1;
inline void TransactionContextV2::clear_type() {
  _impl_.type_.ClearToEmpty();
}
inline const std::string& TransactionContextV2::type() const {
  // @@protoc_insertion_point(field_get:executor.v1.TransactionContextV2.type)
  return _internal_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TransactionContextV2::set_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:executor.v1.TransactionContextV2.type)
}
inline std::string* TransactionContextV2::mutable_type() {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:executor.v1.TransactionContextV2.type)
  return _s;
}
inline const std::string& TransactionContextV2::_internal_type() const {
  return _impl_.type_.Get();
}
inline void TransactionContextV2::_internal_set_type(const std::string& value) {
  
  _impl_.type_.Set(value, GetArenaForAllocation());
}
inline std::string* TransactionContextV2::_internal_mutable_type() {
  
  return _impl_.type_.Mutable(GetArenaForAllocation());
}
inline std::string* TransactionContextV2::release_type() {
  // @@protoc_insertion_point(field_release:executor.v1.TransactionContextV2.type)
  return _impl_.type_.Release();
}
inline void TransactionContextV2::set_allocated_type(std::string* type) {
  if (type != nullptr) {
    
  } else {
    
  }
  _impl_.type_.SetAllocated(type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.type_.IsDefault()) {
    _impl_.type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:executor.v1.TransactionContextV2.type)
}

// string from = 2;
inline void TransactionContextV2::clear_from() {
  _impl_.from_.ClearToEmpty();
}
inline const std::string& TransactionContextV2::from() const {
  // @@protoc_insertion_point(field_get:executor.v1.TransactionContextV2.from)
  return _internal_from();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TransactionContextV2::set_from(ArgT0&& arg0, ArgT... args) {
 
 _impl_.from_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:executor.v1.TransactionContextV2.from)
}
inline std::string* TransactionContextV2::mutable_from() {
  std::string* _s = _internal_mutable_from();
  // @@protoc_insertion_point(field_mutable:executor.v1.TransactionContextV2.from)
  return _s;
}
inline const std::string& TransactionContextV2::_internal_from() const {
  return _impl_.from_.Get();
}
inline void TransactionContextV2::_internal_set_from(const std::string& value) {
  
  _impl_.from_.Set(value, GetArenaForAllocation());
}
inline std::string* TransactionContextV2::_internal_mutable_from() {
  
  return _impl_.from_.Mutable(GetArenaForAllocation());
}
inline std::string* TransactionContextV2::release_from() {
  // @@protoc_insertion_point(field_release:executor.v1.TransactionContextV2.from)
  return _impl_.from_.Release();
}
inline void TransactionContextV2::set_allocated_from(std::string* from) {
  if (from != nullptr) {
    
  } else {
    
  }
  _impl_.from_.SetAllocated(from, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.from_.IsDefault()) {
    _impl_.from_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:executor.v1.TransactionContextV2.from)
}

// string to = 3;
inline void TransactionContextV2::clear_to() {
  _impl_.to_.ClearToEmpty();
}
inline const std::string& TransactionContextV2::to() const {
  // @@protoc_insertion_point(field_get:executor.v1.TransactionContextV2.to)
  return _internal_to();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TransactionContextV2::set_to(ArgT0&& arg0, ArgT... args) {
 
 _impl_.to_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:executor.v1.TransactionContextV2.to)
}
inline std::string* TransactionContextV2::mutable_to() {
  std::string* _s = _internal_mutable_to();
  // @@protoc_insertion_point(field_mutable:executor.v1.TransactionContextV2.to)
  return _s;
}
inline const std::string& TransactionContextV2::_internal_to() const {
  return _impl_.to_.Get();
}
inline void TransactionContextV2::_internal_set_to(const std::string& value) {
  
  _impl_.to_.Set(value, GetArenaForAllocation());
}
inline std::string* TransactionContextV2::_internal_mutable_to() {
  
  return _impl_.to_.Mutable(GetArenaForAllocation());
}
inline std::string* TransactionContextV2::release_to() {
  // @@protoc_insertion_point(field_release:executor.v1.TransactionContextV2.to)
  return _impl_.to_.Release();
}
inline void TransactionContextV2::set_allocated_to(std::string* to) {
  if (to != nullptr) {
    
  } else {
    
  }
  _impl_.to_.SetAllocated(to, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.to_.IsDefault()) {
    _impl_.to_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:executor.v1.TransactionContextV2.to)
}

// bytes data = 4;
inline void TransactionContextV2::clear_data() {
  _impl_.data_.ClearToEmpty();
}
inline const std::string& TransactionContextV2::data() const {
  // @@protoc_insertion_point(field_get:executor.v1.TransactionContextV2.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TransactionContextV2::set_data(ArgT0&& arg0, ArgT... args) {
 
 _impl_.data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:executor.v1.TransactionContextV2.data)
}
inline std::string* TransactionContextV2::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:executor.v1.TransactionContextV2.data)
  return _s;
}
inline const std::string& TransactionContextV2::_internal_data() const {
  return _impl_.data_.Get();
}
inline void TransactionContextV2::_internal_set_data(const std::string& value) {
  
  _impl_.data_.Set(value, GetArenaForAllocation());
}
inline std::string* TransactionContextV2::_internal_mutable_data() {
  
  return _impl_.data_.Mutable(GetArenaForAllocation());
}
inline std::string* TransactionContextV2::release_data() {
  // @@protoc_insertion_point(field_release:executor.v1.TransactionContextV2.data)
  return _impl_.data_.Release();
}
inline void TransactionContextV2::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  _impl_.data_.SetAllocated(data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data_.IsDefault()) {
    _impl_.data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:executor.v1.TransactionContextV2.data)
}

// uint64 gas = 5;
inline void TransactionContextV2::clear_gas() {
  _impl_.gas_ = uint64_t{0u};
}
inline uint64_t TransactionContextV2::_internal_gas() const {
  return _impl_.gas_;
}
inline uint64_t TransactionContextV2::gas() const {
  // @@protoc_insertion_point(field_get:executor.v1.TransactionContextV2.gas)
  return _internal_gas();
}
inline void TransactionContextV2::_internal_set_gas(uint64_t value) {
  
  _impl_.gas_ = value;
}
inline void TransactionContextV2::set_gas(uint64_t value) {
  _internal_set_gas(value);
  // @@protoc_insertion_point(field_set:executor.v1.TransactionContextV2.gas)
}

// string value = 6;
inline void TransactionContextV2::clear_value() {
  _impl_.value_.ClearToEmpty();
}
inline const std::string& TransactionContextV2::value() const {
  // @@protoc_insertion_point(field_get:executor.v1.TransactionContextV2.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TransactionContextV2::set_value(ArgT0&& arg0, ArgT... args) {
 
 _impl_.value_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:executor.v1.TransactionContextV2.value)
}
inline std::string* TransactionContextV2::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:executor.v1.TransactionContextV2.value)
  return _s;
}
inline const std::string& TransactionContextV2::_internal_value() const {
  return _impl_.value_.Get();
}
inline void TransactionContextV2::_internal_set_value(const std::string& value) {
  
  _impl_.value_.Set(value, GetArenaForAllocation());
}
inline std::string* TransactionContextV2::_internal_mutable_value() {
  
  return _impl_.value_.Mutable(GetArenaForAllocation());
}
inline std::string* TransactionContextV2::release_value() {
  // @@protoc_insertion_point(field_release:executor.v1.TransactionContextV2.value)
  return _impl_.value_.Release();
}
inline void TransactionContextV2::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  _impl_.value_.SetAllocated(value, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.value_.IsDefault()) {
    _impl_.value_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:executor.v1.TransactionContextV2.value)
}

// bytes block_hash = 7;
inline void TransactionContextV2::clear_block_hash() {
  _impl_.block_hash_.ClearToEmpty();
}
inline const std::string& TransactionContextV2::block_hash() const {
  // @@protoc_insertion_point(field_get:executor.v1.TransactionContextV2.block_hash)
  return _internal_block_hash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TransactionContextV2::set_block_hash(ArgT0&& arg0, ArgT... args) {
 
 _impl_.block_hash_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:executor.v1.TransactionContextV2.block_hash)
}
inline std::string* TransactionContextV2::mutable_block_hash() {
  std::string* _s = _internal_mutable_block_hash();
  // @@protoc_insertion_point(field_mutable:executor.v1.TransactionContextV2.block_hash)
  return _s;
}
inline const std::string& TransactionContextV2::_internal_block_hash() const {
  return _impl_.block_hash_.Get();
}
inline void TransactionContextV2::_internal_set_block_hash(const std::string& value) {
  
  _impl_.block_hash_.Set(value, GetArenaForAllocation());
}
inline std::string* TransactionContextV2::_internal_mutable_block_hash() {
  
  return _impl_.block_hash_.Mutable(GetArenaForAllocation());
}
inline std::string* TransactionContextV2::release_block_hash() {
  // @@protoc_insertion_point(field_release:executor.v1.TransactionContextV2.block_hash)
  return _impl_.block_hash_.Release();
}
inline void TransactionContextV2::set_allocated_block_hash(std::string* block_hash) {
  if (block_hash != nullptr) {
    
  } else {
    
  }
  _impl_.block_hash_.SetAllocated(block_hash, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.block_hash_.IsDefault()) {
    _impl_.block_hash_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:executor.v1.TransactionContextV2.block_hash)
}

// bytes output = 8;
inline void TransactionContextV2::clear_output() {
  _impl_.output_.ClearToEmpty();
}
inline const std::string& TransactionContextV2::output() const {
  // @@protoc_insertion_point(field_get:executor.v1.TransactionContextV2.output)
  return _internal_output();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TransactionContextV2::set_output(ArgT0&& arg0, ArgT... args) {
 
 _impl_.output_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:executor.v1.TransactionContextV2.output)
}
inline std::string* TransactionContextV2::mutable_output() {
  std::string* _s = _internal_mutable_output();
  // @@protoc_insertion_point(field_mutable:executor.v1.TransactionContextV2.output)
  return _s;
}
inline const std::string& TransactionContextV2::_internal_output() const {
  return _impl_.output_.Get();
}
inline void TransactionContextV2::_internal_set_output(const std::string& value) {
  
  _impl_.output_.Set(value, GetArenaForAllocation());
}
inline std::string* TransactionContextV2::_internal_mutable_output() {
  
  return _impl_.output_.Mutable(GetArenaForAllocation());
}
inline std::string* TransactionContextV2::release_output() {
  // @@protoc_insertion_point(field_release:executor.v1.TransactionContextV2.output)
  return _impl_.output_.Release();
}
inline void TransactionContextV2::set_allocated_output(std::string* output) {
  if (output != nullptr) {
    
  } else {
    
  }
  _impl_.output_.SetAllocated(output, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.output_.IsDefault()) {
    _impl_.output_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:executor.v1.TransactionContextV2.output)
}

// uint64 gas_used = 9;
inline void TransactionContextV2::clear_gas_used() {
  _impl_.gas_used_ = uint64_t{0u};
}
inline uint64_t TransactionContextV2::_internal_gas_used() const {
  return _impl_.gas_used_;
}
inline uint64_t TransactionContextV2::gas_used() const {
  // @@protoc_insertion_point(field_get:executor.v1.TransactionContextV2.gas_used)
  return _internal_gas_used();
}
inline void TransactionContextV2::_internal_set_gas_used(uint64_t value) {
  
  _impl_.gas_used_ = value;
}
inline void TransactionContextV2::set_gas_used(uint64_t value) {
  _internal_set_gas_used(value);
  // @@protoc_insertion_point(field_set:executor.v1.TransactionContextV2.gas_used)
}

// string gas_price = 10;
inline void TransactionContextV2::clear_gas_price() {
  _impl_.gas_price_.ClearToEmpty();
}
inline const std::string& TransactionContextV2::gas_price() const {
  // @@protoc_insertion_point(field_get:executor.v1.TransactionContextV2.gas_price)
  return _internal_gas_price();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TransactionContextV2::set_gas_price(ArgT0&& arg0, ArgT... args) {
 
 _impl_.gas_price_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:executor.v1.TransactionContextV2.gas_price)
}
inline std::string* TransactionContextV2::mutable_gas_price() {
  std::string* _s = _internal_mutable_gas_price();
  // @@protoc_insertion_point(field_mutable:executor.v1.TransactionContextV2.gas_price)
  return _s;
}
inline const std::string& TransactionContextV2::_internal_gas_price() const {
  return _impl_.gas_price_.Get();
}
inline void TransactionContextV2::_internal_set_gas_price(const std::string& value) {
  
  _impl_.gas_price_.Set(value, GetArenaForAllocation());
}
inline std::string* TransactionContextV2::_internal_mutable_gas_price() {
  
  return _impl_.gas_price_.Mutable(GetArenaForAllocation());
}
inline std::string* TransactionContextV2::release_gas_price() {
  // @@protoc_insertion_point(field_release:executor.v1.TransactionContextV2.gas_price)
  return _impl_.gas_price_.Release();
}
inline void TransactionContextV2::set_allocated_gas_price(std::string* gas_price) {
  if (gas_price != nullptr) {
    
  } else {
    
  }
  _impl_.gas_price_.SetAllocated(gas_price, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.gas_price_.IsDefault()) {
    _impl_.gas_price_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:executor.v1.TransactionContextV2.gas_price)
}

// uint32 execution_time = 11;
inline void TransactionContextV2::clear_execution_time() {
  _impl_.execution_time_ = 0u;
}
inline uint32_t TransactionContextV2::_internal_execution_time() const {
  return _impl_.execution_time_;
}
inline uint32_t TransactionContextV2::execution_time() const {
  // @@protoc_insertion_point(field_get:executor.v1.TransactionContextV2.execution_time)
  return _internal_execution_time();
}
inline void TransactionContextV2::_internal_set_execution_time(uint32_t value) {
  
  _impl_.execution_time_ = value;
}
inline void TransactionContextV2::set_execution_time(uint32_t value) {
  _internal_set_execution_time(value);
  // @@protoc_insertion_point(field_set:executor.v1.TransactionContextV2.execution_time)
}

// bytes old_state_root = 12;
inline void TransactionContextV2::clear_old_state_root() {
  _impl_.old_state_root_.ClearToEmpty();
}
inline const std::string& TransactionContextV2::old_state_root() const {
  // @@protoc_insertion_point(field_get:executor.v1.TransactionContextV2.old_state_root)
  return _internal_old_state_root();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TransactionContextV2::set_old_state_root(ArgT0&& arg0, ArgT... args) {
 
 _impl_.old_state_root_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:executor.v1.TransactionContextV2.old_state_root)
}
inline std::string* TransactionContextV2::mutable_old_state_root() {
  std::string* _s = _internal_mutable_old_state_root();
  // @@protoc_insertion_point(field_mutable:executor.v1.TransactionContextV2.old_state_root)
  return _s;
}
inline const std::string& TransactionContextV2::_internal_old_state_root() const {
  return _impl_.old_state_root_.Get();
}
inline void TransactionContextV2::_internal_set_old_state_root(const std::string& value) {
  
  _impl_.old_state_root_.Set(value, GetArenaForAllocation());
}
inline std::string* TransactionContextV2::_internal_mutable_old_state_root() {
  
  return _impl_.old_state_root_.Mutable(GetArenaForAllocation());
}
inline std::string* TransactionContextV2::release_old_state_root() {
  // @@protoc_insertion_point(field_release:executor.v1.TransactionContextV2.old_state_root)
  return _impl_.old_state_root_.Release();
}
inline void TransactionContextV2::set_allocated_old_state_root(std::string* old_state_root) {
  if (old_state_root != nullptr) {
    
  } else {
    
  }
  _impl_.old_state_root_.SetAllocated(old_state_root, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.old_state_root_.IsDefault()) {
    _impl_.old_state_root_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:executor.v1.TransactionContextV2.old_state_root)
}

// uint64 nonce = 13;
inline void TransactionContextV2::clear_nonce() {
  _impl_.nonce_ = uint64_t{0u};
}
inline uint64_t TransactionContextV2::_internal_nonce() const {
  return _impl_.nonce_;
}
inline uint64_t TransactionContextV2::nonce() const {
  // @@protoc_insertion_point(field_get:executor.v1.TransactionContextV2.nonce)
  return _internal_nonce();
}
inline void TransactionContextV2::_internal_set_nonce(uint64_t value) {
  
  _impl_.nonce_ = value;
}
inline void TransactionContextV2::set_nonce(uint64_t value) {
  _internal_set_nonce(value);
  // @@protoc_insertion_point(field_set:executor.v1.TransactionContextV2.nonce)
}

// uint64 tx_index = 14;
inline void TransactionContextV2::clear_tx_index() {
  _impl_.tx_index_ = uint64_t{0u};
}
inline uint64_t TransactionContextV2::_internal_tx_index() const {
  return _impl_.tx_index_;
}
inline uint64_t TransactionContextV2::tx_index() const {
  // @@protoc_insertion_point(field_get:executor.v1.TransactionContextV2.tx_index)
  return _internal_tx_index();
}
inline void TransactionContextV2::_internal_set_tx_index(uint64_t value) {
  
  _impl_.tx_index_ = value;
}
inline void TransactionContextV2::set_tx_index(uint64_t value) {
  _internal_set_tx_index(value);
  // @@protoc_insertion_point(field_set:executor.v1.TransactionContextV2.tx_index)
}

// uint64 chain_id = 15;
inline void TransactionContextV2::clear_chain_id() {
  _impl_.chain_id_ = uint64_t{0u};
}
inline uint64_t TransactionContextV2::_internal_chain_id() const {
  return _impl_.chain_id_;
}
inline uint64_t TransactionContextV2::chain_id() const {
  // @@protoc_insertion_point(field_get:executor.v1.TransactionContextV2.chain_id)
  return _internal_chain_id();
}
inline void TransactionContextV2::_internal_set_chain_id(uint64_t value) {
  
  _impl_.chain_id_ = value;
}
inline void TransactionContextV2::set_chain_id(uint64_t value) {
  _internal_set_chain_id(value);
  // @@protoc_insertion_point(field_set:executor.v1.TransactionContextV2.chain_id)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// TransactionStepV2

// bytes state_root = 1;
inline void TransactionStepV2::clear_state_root() {
  _impl_.state_root_.ClearToEmpty();
}
inline const std::string& TransactionStepV2::state_root() const {
  // @@protoc_insertion_point(field_get:executor.v1.TransactionStepV2.state_root)
  return _internal_state_root();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TransactionStepV2::set_state_root(ArgT0&& arg0, ArgT... args) {
 
 _impl_.state_root_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:executor.v1.TransactionStepV2.state_root)
}
inline std::string* TransactionStepV2::mutable_state_root() {
  std::string* _s = _internal_mutable_state_root();
  // @@protoc_insertion_point(field_mutable:executor.v1.TransactionStepV2.state_root)
  return _s;
}
inline const std::string& TransactionStepV2::_internal_state_root() const {
  return _impl_.state_root_.Get();
}
inline void TransactionStepV2::_internal_set_state_root(const std::string& value) {
  
  _impl_.state_root_.Set(value, GetArenaForAllocation());
}
inline std::string* TransactionStepV2::_internal_mutable_state_root() {
  
  return _impl_.state_root_.Mutable(GetArenaForAllocation());
}
inline std::string* TransactionStepV2::release_state_root() {
  // @@protoc_insertion_point(field_release:executor.v1.TransactionStepV2.state_root)
  return _impl_.state_root_.Release();
}
inline void TransactionStepV2::set_allocated_state_root(std::string* state_root) {
  if (state_root != nullptr) {
    
  } else {
    
  }
  _impl_.state_root_.SetAllocated(state_root, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.state_root_.IsDefault()) {
    _impl_.state_root_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:executor.v1.TransactionStepV2.state_root)
}

// uint32 depth = 2;
inline void TransactionStepV2::clear_depth() {
  _impl_.depth_ = 0u;
}
inline uint32_t TransactionStepV2::_internal_depth() const {
  return _impl_.depth_;
}
inline uint32_t TransactionStepV2::depth() const {
  // @@protoc_insertion_point(field_get:executor.v1.TransactionStepV2.depth)
  return _internal_depth();
}
inline void TransactionStepV2::_internal_set_depth(uint32_t value) {
  
  _impl_.depth_ = value;
}
inline void TransactionStepV2::set_depth(uint32_t value) {
  _internal_set_depth(value);
  // @@protoc_insertion_point(field_set:executor.v1.TransactionStepV2.depth)
}

// uint64 pc = 3;
inline void TransactionStepV2::clear_pc() {
  _impl_.pc_ = uint64_t{0u};
}
inline uint64_t TransactionStepV2::_internal_pc() const {
  return _impl_.pc_;
}
inline uint64_t TransactionStepV2::pc() const {
  // @@protoc_insertion_point(field_get:executor.v1.TransactionStepV2.pc)
  return _internal_pc();
}
inline void TransactionStepV2::_internal_set_pc(uint64_t value) {
  
  _impl_.pc_ = value;
}
inline void TransactionStepV2::set_pc(uint64_t value) {
  _internal_set_pc(value);
  // @@protoc_insertion_point(field_set:executor.v1.TransactionStepV2.pc)
}

// uint64 gas = 4;
inline void TransactionStepV2::clear_gas() {
  _impl_.gas_ = uint64_t{0u};
}
inline uint64_t TransactionStepV2::_internal_gas() const {
  return _impl_.gas_;
}
inline uint64_t TransactionStepV2::gas() const {
  // @@protoc_insertion_point(field_get:executor.v1.TransactionStepV2.gas)
  return _internal_gas();
}
inline void TransactionStepV2::_internal_set_gas(uint64_t value) {
  
  _impl_.gas_ = value;
}
inline void TransactionStepV2::set_gas(uint64_t value) {
  _internal_set_gas(value);
  // @@protoc_insertion_point(field_set:executor.v1.TransactionStepV2.gas)
}

// uint64 gas_cost = 5;
inline void TransactionStepV2::clear_gas_cost() {
  _impl_.gas_cost_ = uint64_t{0u};
}
inline uint64_t TransactionStepV2::_internal_gas_cost() const {
  return _impl_.gas_cost_;
}
inline uint64_t TransactionStepV2::gas_cost() const {
  // @@protoc_insertion_point(field_get:executor.v1.TransactionStepV2.gas_cost)
  return _internal_gas_cost();
}
inline void TransactionStepV2::_internal_set_gas_cost(uint64_t value) {
  
  _impl_.gas_cost_ = value;
}
inline void TransactionStepV2::set_gas_cost(uint64_t value) {
  _internal_set_gas_cost(value);
  // @@protoc_insertion_point(field_set:executor.v1.TransactionStepV2.gas_cost)
}

// uint64 gas_refund = 6;
inline void TransactionStepV2::clear_gas_refund() {
  _impl_.gas_refund_ = uint64_t{0u};
}
inline uint64_t TransactionStepV2::_internal_gas_refund() const {
  return _impl_.gas_refund_;
}
inline uint64_t TransactionStepV2::gas_refund() const {
  // @@protoc_insertion_point(field_get:executor.v1.TransactionStepV2.gas_refund)
  return _internal_gas_refund();
}
inline void TransactionStepV2::_internal_set_gas_refund(uint64_t value) {
  
  _impl_.gas_refund_ = value;
}
inline void TransactionStepV2::set_gas_refund(uint64_t value) {
  _internal_set_gas_refund(value);
  // @@protoc_insertion_point(field_set:executor.v1.TransactionStepV2.gas_refund)
}

// uint32 op = 7;
inline void TransactionStepV2::clear_op() {
  _impl_.op_ = 0u;
}
inline uint32_t TransactionStepV2::_internal_op() const {
  return _impl_.op_;
}
inline uint32_t TransactionStepV2::op() const {
  // @@protoc_insertion_point(field_get:executor.v1.TransactionStepV2.op)
  return _internal_op();
}
inline void TransactionStepV2::_internal_set_op(uint32_t value) {
  
  _impl_.op_ = value;
}
inline void TransactionStepV2::set_op(uint32_t value) {
  _internal_set_op(value);
  // @@protoc_insertion_point(field_set:executor.v1.TransactionStepV2.op)
}

// repeated string stack = 8;
inline int TransactionStepV2::_internal_stack_size() const {
  return _impl_.stack_.size();
}
inline int TransactionStepV2::stack_size() const {
  return _internal_stack_size();
}
inline void TransactionStepV2::clear_stack() {
  _impl_.stack_.Clear();
}
inline std::string* TransactionStepV2::add_stack() {
  std::string* _s = _internal_add_stack();
  // @@protoc_insertion_point(field_add_mutable:executor.v1.TransactionStepV2.stack)
  return _s;
}
inline const std::string& TransactionStepV2::_internal_stack(int index) const {
  return _impl_.stack_.Get(index);
}
inline const std::string& TransactionStepV2::stack(int index) const {
  // @@protoc_insertion_point(field_get:executor.v1.TransactionStepV2.stack)
  return _internal_stack(index);
}
inline std::string* TransactionStepV2::mutable_stack(int index) {
  // @@protoc_insertion_point(field_mutable:executor.v1.TransactionStepV2.stack)
  return _impl_.stack_.Mutable(index);
}
inline void TransactionStepV2::set_stack(int index, const std::string& value) {
  _impl_.stack_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:executor.v1.TransactionStepV2.stack)
}
inline void TransactionStepV2::set_stack(int index, std::string&& value) {
  _impl_.stack_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:executor.v1.TransactionStepV2.stack)
}
inline void TransactionStepV2::set_stack(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.stack_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:executor.v1.TransactionStepV2.stack)
}
inline void TransactionStepV2::set_stack(int index, const char* value, size_t size) {
  _impl_.stack_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:executor.v1.TransactionStepV2.stack)
}
inline std::string* TransactionStepV2::_internal_add_stack() {
  return _impl_.stack_.Add();
}
inline void TransactionStepV2::add_stack(const std::string& value) {
  _impl_.stack_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:executor.v1.TransactionStepV2.stack)
}
inline void TransactionStepV2::add_stack(std::string&& value) {
  _impl_.stack_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:executor.v1.TransactionStepV2.stack)
}
inline void TransactionStepV2::add_stack(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.stack_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:executor.v1.TransactionStepV2.stack)
}
inline void TransactionStepV2::add_stack(const char* value, size_t size) {
  _impl_.stack_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:executor.v1.TransactionStepV2.stack)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
TransactionStepV2::stack() const {
  // @@protoc_insertion_point(field_list:executor.v1.TransactionStepV2.stack)
  return _impl_.stack_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
TransactionStepV2::mutable_stack() {
  // @@protoc_insertion_point(field_mutable_list:executor.v1.TransactionStepV2.stack)
  return &_impl_.stack_;
}

// bytes memory = 9;
inline void TransactionStepV2::clear_memory() {
  _impl_.memory_.ClearToEmpty();
}
inline const std::string& TransactionStepV2::memory() const {
  // @@protoc_insertion_point(field_get:executor.v1.TransactionStepV2.memory)
  return _internal_memory();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TransactionStepV2::set_memory(ArgT0&& arg0, ArgT... args) {
 
 _impl_.memory_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:executor.v1.TransactionStepV2.memory)
}
inline std::string* TransactionStepV2::mutable_memory() {
  std::string* _s = _internal_mutable_memory();
  // @@protoc_insertion_point(field_mutable:executor.v1.TransactionStepV2.memory)
  return _s;
}
inline const std::string& TransactionStepV2::_internal_memory() const {
  return _impl_.memory_.Get();
}
inline void TransactionStepV2::_internal_set_memory(const std::string& value) {
  
  _impl_.memory_.Set(value, GetArenaForAllocation());
}
inline std::string* TransactionStepV2::_internal_mutable_memory() {
  
  return _impl_.memory_.Mutable(GetArenaForAllocation());
}
inline std::string* TransactionStepV2::release_memory() {
  // @@protoc_insertion_point(field_release:executor.v1.TransactionStepV2.memory)
  return _impl_.memory_.Release();
}
inline void TransactionStepV2::set_allocated_memory(std::string* memory) {
  if (memory != nullptr) {
    
  } else {
    
  }
  _impl_.memory_.SetAllocated(memory, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.memory_.IsDefault()) {
    _impl_.memory_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:executor.v1.TransactionStepV2.memory)
}

// uint32 memory_size = 10;
inline void TransactionStepV2::clear_memory_size() {
  _impl_.memory_size_ = 0u;
}
inline uint32_t TransactionStepV2::_internal_memory_size() const {
  return _impl_.memory_size_;
}
inline uint32_t TransactionStepV2::memory_size() const {
  // @@protoc_insertion_point(field_get:executor.v1.TransactionStepV2.memory_size)
  return _internal_memory_size();
}
inline void TransactionStepV2::_internal_set_memory_size(uint32_t value) {
  
  _impl_.memory_size_ = value;
}
inline void TransactionStepV2::set_memory_size(uint32_t value) {
  _internal_set_memory_size(value);
  // @@protoc_insertion_point(field_set:executor.v1.TransactionStepV2.memory_size)
}

// uint32 memory_offset = 11;
inline void TransactionStepV2::clear_memory_offset() {
  _impl_.memory_offset_ = 0u;
}
inline uint32_t TransactionStepV2::_internal_memory_offset() const {
  return _impl_.memory_offset_;
}
inline uint32_t TransactionStepV2::memory_offset() const {
  // @@protoc_insertion_point(field_get:executor.v1.TransactionStepV2.memory_offset)
  return _internal_memory_offset();
}
inline void TransactionStepV2::_internal_set_memory_offset(uint32_t value) {
  
  _impl_.memory_offset_ = value;
}
inline void TransactionStepV2::set_memory_offset(uint32_t value) {
  _internal_set_memory_offset(value);
  // @@protoc_insertion_point(field_set:executor.v1.TransactionStepV2.memory_offset)
}

// bytes return_data = 12;
inline void TransactionStepV2::clear_return_data() {
  _impl_.return_data_.ClearToEmpty();
}
inline const std::string& TransactionStepV2::return_data() const {
  // @@protoc_insertion_point(field_get:executor.v1.TransactionStepV2.return_data)
  return _internal_return_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TransactionStepV2::set_return_data(ArgT0&& arg0, ArgT... args) {
 
 _impl_.return_data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:executor.v1.TransactionStepV2.return_data)
}
inline std::string* TransactionStepV2::mutable_return_data() {
  std::string* _s = _internal_mutable_return_data();
  // @@protoc_insertion_point(field_mutable:executor.v1.TransactionStepV2.return_data)
  return _s;
}
inline const std::string& TransactionStepV2::_internal_return_data() const {
  return _impl_.return_data_.Get();
}
inline void TransactionStepV2::_internal_set_return_data(const std::string& value) {
  
  _impl_.return_data_.Set(value, GetArenaForAllocation());
}
inline std::string* TransactionStepV2::_internal_mutable_return_data() {
  
  return _impl_.return_data_.Mutable(GetArenaForAllocation());
}
inline std::string* TransactionStepV2::release_return_data() {
  // @@protoc_insertion_point(field_release:executor.v1.TransactionStepV2.return_data)
  return _impl_.return_data_.Release();
}
inline void TransactionStepV2::set_allocated_return_data(std::string* return_data) {
  if (return_data != nullptr) {
    
  } else {
    
  }
  _impl_.return_data_.SetAllocated(return_data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.return_data_.IsDefault()) {
    _impl_.return_data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:executor.v1.TransactionStepV2.return_data)
}

// .executor.v1.ContractV2 contract = 13;
inline bool TransactionStepV2::_internal_has_contract() const {
  return this != internal_default_instance() && _impl_.contract_ != nullptr;
}
inline bool TransactionStepV2::has_contract() const {
  return _internal_has_contract();
}
inline void TransactionStepV2::clear_contract() {
  if (GetArenaForAllocation() == nullptr && _impl_.contract_ != nullptr) {
    delete _impl_.contract_;
  }
  _impl_.contract_ = nullptr;
}
inline const ::executor::v1::ContractV2& TransactionStepV2::_internal_contract() const {
  const ::executor::v1::ContractV2* p = _impl_.contract_;
  return p != nullptr ? *p : reinterpret_cast<const ::executor::v1::ContractV2&>(
      ::executor::v1::_ContractV2_default_instance_);
}
inline const ::executor::v1::ContractV2& TransactionStepV2::contract() const {
  // @@protoc_insertion_point(field_get:executor.v1.TransactionStepV2.contract)
  return _internal_contract();
}
inline void TransactionStepV2::unsafe_arena_set_allocated_contract(
    ::executor::v1::ContractV2* contract) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.contract_);
  }
  _impl_.contract_ = contract;
  if (contract) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:executor.v1.TransactionStepV2.contract)
}
inline ::executor::v1::ContractV2* TransactionStepV2::release_contract() {
  
  ::executor::v1::ContractV2* temp = _impl_.contract_;
  _impl_.contract_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::executor::v1::ContractV2* TransactionStepV2::unsafe_arena_release_contract() {
  // @@protoc_insertion_point(field_release:executor.v1.TransactionStepV2.contract)
  
  ::executor::v1::ContractV2* temp = _impl_.contract_;
  _impl_.contract_ = nullptr;
  return temp;
}
inline ::executor::v1::ContractV2* TransactionStepV2::_internal_mutable_contract() {
  
  if (_impl_.contract_ == nullptr) {
    auto* p = CreateMaybeMessage<::executor::v1::ContractV2>(GetArenaForAllocation());
    _impl_.contract_ = p;
  }
  return _impl_.contract_;
}
inline ::executor::v1::ContractV2* TransactionStepV2::mutable_contract() {
  ::executor::v1::ContractV2* _msg = _internal_mutable_contract();
  // @@protoc_insertion_point(field_mutable:executor.v1.TransactionStepV2.contract)
  return _msg;
}
inline void TransactionStepV2::set_allocated_contract(::executor::v1::ContractV2* contract) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.contract_;
  }
  if (contract) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(contract);
    if (message_arena != submessage_arena) {
      contract = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, contract, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.contract_ = contract;
  // @@protoc_insertion_point(field_set_allocated:executor.v1.TransactionStepV2.contract)
}

// .executor.v1.RomError error = 14;
inline void TransactionStepV2::clear_error() {
  _impl_.error_ = 0;
}
inline ::executor::v1::RomError TransactionStepV2::_internal_error() const {
  return static_cast< ::executor::v1::RomError >(_impl_.error_);
}
inline ::executor::v1::RomError TransactionStepV2::error() const {
  // @@protoc_insertion_point(field_get:executor.v1.TransactionStepV2.error)
  return _internal_error();
}
inline void TransactionStepV2::_internal_set_error(::executor::v1::RomError value) {
  
  _impl_.error_ = value;
}
inline void TransactionStepV2::set_error(::executor::v1::RomError value) {
  _internal_set_error(value);
  // @@protoc_insertion_point(field_set:executor.v1.TransactionStepV2.error)
}

// map<string, string> storage = 15;
inline int TransactionStepV2::_internal_storage_size() const {
  return _impl_.storage_.size();
}
inline int TransactionStepV2::storage_size() const {
  return _internal_storage_size();
}
inline void TransactionStepV2::clear_storage() {
  _impl_.storage_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
TransactionStepV2::_internal_storage() const {
  return _impl_.storage_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
TransactionStepV2::storage() const {
  // @@protoc_insertion_point(field_map:executor.v1.TransactionStepV2.storage)
  return _internal_storage();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
TransactionStepV2::_internal_mutable_storage() {
  return _impl_.storage_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
TransactionStepV2::mutable_storage() {
  // @@protoc_insertion_point(field_mutable_map:executor.v1.TransactionStepV2.storage)
  return _internal_mutable_storage();
}

// -------------------------------------------------------------------

// ContractV2

// string address = 1;
inline void ContractV2::clear_address() {
  _impl_.address_.ClearToEmpty();
}
inline const std::string& ContractV2::address() const {
  // @@protoc_insertion_point(field_get:executor.v1.ContractV2.address)
  return _internal_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ContractV2::set_address(ArgT0&& arg0, ArgT... args) {
 
 _impl_.address_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:executor.v1.ContractV2.address)
}
inline std::string* ContractV2::mutable_address() {
  std::string* _s = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:executor.v1.ContractV2.address)
  return _s;
}
inline const std::string& ContractV2::_internal_address() const {
  return _impl_.address_.Get();
}
inline void ContractV2::_internal_set_address(const std::string& value) {
  
  _impl_.address_.Set(value, GetArenaForAllocation());
}
inline std::string* ContractV2::_internal_mutable_address() {
  
  return _impl_.address_.Mutable(GetArenaForAllocation());
}
inline std::string* ContractV2::release_address() {
  // @@protoc_insertion_point(field_release:executor.v1.ContractV2.address)
  return _impl_.address_.Release();
}
inline void ContractV2::set_allocated_address(std::string* address) {
  if (address != nullptr) {
    
  } else {
    
  }
  _impl_.address_.SetAllocated(address, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.address_.IsDefault()) {
    _impl_.address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:executor.v1.ContractV2.address)
}

// string caller = 2;
inline void ContractV2::clear_caller() {
  _impl_.caller_.ClearToEmpty();
}
inline const std::string& ContractV2::caller() const {
  // @@protoc_insertion_point(field_get:executor.v1.ContractV2.caller)
  return _internal_caller();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ContractV2::set_caller(ArgT0&& arg0, ArgT... args) {
 
 _impl_.caller_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:executor.v1.ContractV2.caller)
}
inline std::string* ContractV2::mutable_caller() {
  std::string* _s = _internal_mutable_caller();
  // @@protoc_insertion_point(field_mutable:executor.v1.ContractV2.caller)
  return _s;
}
inline const std::string& ContractV2::_internal_caller() const {
  return _impl_.caller_.Get();
}
inline void ContractV2::_internal_set_caller(const std::string& value) {
  
  _impl_.caller_.Set(value, GetArenaForAllocation());
}
inline std::string* ContractV2::_internal_mutable_caller() {
  
  return _impl_.caller_.Mutable(GetArenaForAllocation());
}
inline std::string* ContractV2::release_caller() {
  // @@protoc_insertion_point(field_release:executor.v1.ContractV2.caller)
  return _impl_.caller_.Release();
}
inline void ContractV2::set_allocated_caller(std::string* caller) {
  if (caller != nullptr) {
    
  } else {
    
  }
  _impl_.caller_.SetAllocated(caller, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.caller_.IsDefault()) {
    _impl_.caller_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:executor.v1.ContractV2.caller)
}

// string value = 3;
inline void ContractV2::clear_value() {
  _impl_.value_.ClearToEmpty();
}
inline const std::string& ContractV2::value() const {
  // @@protoc_insertion_point(field_get:executor.v1.ContractV2.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ContractV2::set_value(ArgT0&& arg0, ArgT... args) {
 
 _impl_.value_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:executor.v1.ContractV2.value)
}
inline std::string* ContractV2::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:executor.v1.ContractV2.value)
  return _s;
}
inline const std::string& ContractV2::_internal_value() const {
  return _impl_.value_.Get();
}
inline void ContractV2::_internal_set_value(const std::string& value) {
  
  _impl_.value_.Set(value, GetArenaForAllocation());
}
inline std::string* ContractV2::_internal_mutable_value() {
  
  return _impl_.value_.Mutable(GetArenaForAllocation());
}
inline std::string* ContractV2::release_value() {
  // @@protoc_insertion_point(field_release:executor.v1.ContractV2.value)
  return _impl_.value_.Release();
}
inline void ContractV2::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  _impl_.value_.SetAllocated(value, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.value_.IsDefault()) {
    _impl_.value_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:executor.v1.ContractV2.value)
}

// bytes data = 4;
inline void ContractV2::clear_data() {
  _impl_.data_.ClearToEmpty();
}
inline const std::string& ContractV2::data() const {
  // @@protoc_insertion_point(field_get:executor.v1.ContractV2.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ContractV2::set_data(ArgT0&& arg0, ArgT... args) {
 
 _impl_.data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:executor.v1.ContractV2.data)
}
inline std::string* ContractV2::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:executor.v1.ContractV2.data)
  return _s;
}
inline const std::string& ContractV2::_internal_data() const {
  return _impl_.data_.Get();
}
inline void ContractV2::_internal_set_data(const std::string& value) {
  
  _impl_.data_.Set(value, GetArenaForAllocation());
}
inline std::string* ContractV2::_internal_mutable_data() {
  
  return _impl_.data_.Mutable(GetArenaForAllocation());
}
inline std::string* ContractV2::release_data() {
  // @@protoc_insertion_point(field_release:executor.v1.ContractV2.data)
  return _impl_.data_.Release();
}
inline void ContractV2::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  _impl_.data_.SetAllocated(data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data_.IsDefault()) {
    _impl_.data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:executor.v1.ContractV2.data)
}

// uint64 gas = 5;
inline void ContractV2::clear_gas() {
  _impl_.gas_ = uint64_t{0u};
}
inline uint64_t ContractV2::_internal_gas() const {
  return _impl_.gas_;
}
inline uint64_t ContractV2::gas() const {
  // @@protoc_insertion_point(field_get:executor.v1.ContractV2.gas)
  return _internal_gas();
}
inline void ContractV2::_internal_set_gas(uint64_t value) {
  
  _impl_.gas_ = value;
}
inline void ContractV2::set_gas(uint64_t value) {
  _internal_set_gas(value);
  // @@protoc_insertion_point(field_set:executor.v1.ContractV2.gas)
}

// string type = 6;
inline void ContractV2::clear_type() {
  _impl_.type_.ClearToEmpty();
}
inline const std::string& ContractV2::type() const {
  // @@protoc_insertion_point(field_get:executor.v1.ContractV2.type)
  return _internal_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ContractV2::set_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:executor.v1.ContractV2.type)
}
inline std::string* ContractV2::mutable_type() {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:executor.v1.ContractV2.type)
  return _s;
}
inline const std::string& ContractV2::_internal_type() const {
  return _impl_.type_.Get();
}
inline void ContractV2::_internal_set_type(const std::string& value) {
  
  _impl_.type_.Set(value, GetArenaForAllocation());
}
inline std::string* ContractV2::_internal_mutable_type() {
  
  return _impl_.type_.Mutable(GetArenaForAllocation());
}
inline std::string* ContractV2::release_type() {
  // @@protoc_insertion_point(field_release:executor.v1.ContractV2.type)
  return _impl_.type_.Release();
}
inline void ContractV2::set_allocated_type(std::string* type) {
  if (type != nullptr) {
    
  } else {
    
  }
  _impl_.type_.SetAllocated(type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.type_.IsDefault()) {
    _impl_.type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:executor.v1.ContractV2.type)
}

// -------------------------------------------------------------------

// ProcessBlockResponseV2

// bytes parent_hash = 1;
inline void ProcessBlockResponseV2::clear_parent_hash() {
  _impl_.parent_hash_.ClearToEmpty();
}
inline const std::string& ProcessBlockResponseV2::parent_hash() const {
  // @@protoc_insertion_point(field_get:executor.v1.ProcessBlockResponseV2.parent_hash)
  return _internal_parent_hash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProcessBlockResponseV2::set_parent_hash(ArgT0&& arg0, ArgT... args) {
 
 _impl_.parent_hash_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:executor.v1.ProcessBlockResponseV2.parent_hash)
}
inline std::string* ProcessBlockResponseV2::mutable_parent_hash() {
  std::string* _s = _internal_mutable_parent_hash();
  // @@protoc_insertion_point(field_mutable:executor.v1.ProcessBlockResponseV2.parent_hash)
  return _s;
}
inline const std::string& ProcessBlockResponseV2::_internal_parent_hash() const {
  return _impl_.parent_hash_.Get();
}
inline void ProcessBlockResponseV2::_internal_set_parent_hash(const std::string& value) {
  
  _impl_.parent_hash_.Set(value, GetArenaForAllocation());
}
inline std::string* ProcessBlockResponseV2::_internal_mutable_parent_hash() {
  
  return _impl_.parent_hash_.Mutable(GetArenaForAllocation());
}
inline std::string* ProcessBlockResponseV2::release_parent_hash() {
  // @@protoc_insertion_point(field_release:executor.v1.ProcessBlockResponseV2.parent_hash)
  return _impl_.parent_hash_.Release();
}
inline void ProcessBlockResponseV2::set_allocated_parent_hash(std::string* parent_hash) {
  if (parent_hash != nullptr) {
    
  } else {
    
  }
  _impl_.parent_hash_.SetAllocated(parent_hash, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.parent_hash_.IsDefault()) {
    _impl_.parent_hash_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:executor.v1.ProcessBlockResponseV2.parent_hash)
}

// string coinbase = 2;
inline void ProcessBlockResponseV2::clear_coinbase() {
  _impl_.coinbase_.ClearToEmpty();
}
inline const std::string& ProcessBlockResponseV2::coinbase() const {
  // @@protoc_insertion_point(field_get:executor.v1.ProcessBlockResponseV2.coinbase)
  return _internal_coinbase();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProcessBlockResponseV2::set_coinbase(ArgT0&& arg0, ArgT... args) {
 
 _impl_.coinbase_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:executor.v1.ProcessBlockResponseV2.coinbase)
}
inline std::string* ProcessBlockResponseV2::mutable_coinbase() {
  std::string* _s = _internal_mutable_coinbase();
  // @@protoc_insertion_point(field_mutable:executor.v1.ProcessBlockResponseV2.coinbase)
  return _s;
}
inline const std::string& ProcessBlockResponseV2::_internal_coinbase() const {
  return _impl_.coinbase_.Get();
}
inline void ProcessBlockResponseV2::_internal_set_coinbase(const std::string& value) {
  
  _impl_.coinbase_.Set(value, GetArenaForAllocation());
}
inline std::string* ProcessBlockResponseV2::_internal_mutable_coinbase() {
  
  return _impl_.coinbase_.Mutable(GetArenaForAllocation());
}
inline std::string* ProcessBlockResponseV2::release_coinbase() {
  // @@protoc_insertion_point(field_release:executor.v1.ProcessBlockResponseV2.coinbase)
  return _impl_.coinbase_.Release();
}
inline void ProcessBlockResponseV2::set_allocated_coinbase(std::string* coinbase) {
  if (coinbase != nullptr) {
    
  } else {
    
  }
  _impl_.coinbase_.SetAllocated(coinbase, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.coinbase_.IsDefault()) {
    _impl_.coinbase_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:executor.v1.ProcessBlockResponseV2.coinbase)
}

// uint64 gas_limit = 3;
inline void ProcessBlockResponseV2::clear_gas_limit() {
  _impl_.gas_limit_ = uint64_t{0u};
}
inline uint64_t ProcessBlockResponseV2::_internal_gas_limit() const {
  return _impl_.gas_limit_;
}
inline uint64_t ProcessBlockResponseV2::gas_limit() const {
  // @@protoc_insertion_point(field_get:executor.v1.ProcessBlockResponseV2.gas_limit)
  return _internal_gas_limit();
}
inline void ProcessBlockResponseV2::_internal_set_gas_limit(uint64_t value) {
  
  _impl_.gas_limit_ = value;
}
inline void ProcessBlockResponseV2::set_gas_limit(uint64_t value) {
  _internal_set_gas_limit(value);
  // @@protoc_insertion_point(field_set:executor.v1.ProcessBlockResponseV2.gas_limit)
}

// uint64 block_number = 4;
inline void ProcessBlockResponseV2::clear_block_number() {
  _impl_.block_number_ = uint64_t{0u};
}
inline uint64_t ProcessBlockResponseV2::_internal_block_number() const {
  return _impl_.block_number_;
}
inline uint64_t ProcessBlockResponseV2::block_number() const {
  // @@protoc_insertion_point(field_get:executor.v1.ProcessBlockResponseV2.block_number)
  return _internal_block_number();
}
inline void ProcessBlockResponseV2::_internal_set_block_number(uint64_t value) {
  
  _impl_.block_number_ = value;
}
inline void ProcessBlockResponseV2::set_block_number(uint64_t value) {
  _internal_set_block_number(value);
  // @@protoc_insertion_point(field_set:executor.v1.ProcessBlockResponseV2.block_number)
}

// uint64 timestamp = 5;
inline void ProcessBlockResponseV2::clear_timestamp() {
  _impl_.timestamp_ = uint64_t{0u};
}
inline uint64_t ProcessBlockResponseV2::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline uint64_t ProcessBlockResponseV2::timestamp() const {
  // @@protoc_insertion_point(field_get:executor.v1.ProcessBlockResponseV2.timestamp)
  return _internal_timestamp();
}
inline void ProcessBlockResponseV2::_internal_set_timestamp(uint64_t value) {
  
  _impl_.timestamp_ = value;
}
inline void ProcessBlockResponseV2::set_timestamp(uint64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:executor.v1.ProcessBlockResponseV2.timestamp)
}

// bytes ger = 6;
inline void ProcessBlockResponseV2::clear_ger() {
  _impl_.ger_.ClearToEmpty();
}
inline const std::string& ProcessBlockResponseV2::ger() const {
  // @@protoc_insertion_point(field_get:executor.v1.ProcessBlockResponseV2.ger)
  return _internal_ger();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProcessBlockResponseV2::set_ger(ArgT0&& arg0, ArgT... args) {
 
 _impl_.ger_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:executor.v1.ProcessBlockResponseV2.ger)
}
inline std::string* ProcessBlockResponseV2::mutable_ger() {
  std::string* _s = _internal_mutable_ger();
  // @@protoc_insertion_point(field_mutable:executor.v1.ProcessBlockResponseV2.ger)
  return _s;
}
inline const std::string& ProcessBlockResponseV2::_internal_ger() const {
  return _impl_.ger_.Get();
}
inline void ProcessBlockResponseV2::_internal_set_ger(const std::string& value) {
  
  _impl_.ger_.Set(value, GetArenaForAllocation());
}
inline std::string* ProcessBlockResponseV2::_internal_mutable_ger() {
  
  return _impl_.ger_.Mutable(GetArenaForAllocation());
}
inline std::string* ProcessBlockResponseV2::release_ger() {
  // @@protoc_insertion_point(field_release:executor.v1.ProcessBlockResponseV2.ger)
  return _impl_.ger_.Release();
}
inline void ProcessBlockResponseV2::set_allocated_ger(std::string* ger) {
  if (ger != nullptr) {
    
  } else {
    
  }
  _impl_.ger_.SetAllocated(ger, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.ger_.IsDefault()) {
    _impl_.ger_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:executor.v1.ProcessBlockResponseV2.ger)
}

// bytes block_hash_l1 = 7;
inline void ProcessBlockResponseV2::clear_block_hash_l1() {
  _impl_.block_hash_l1_.ClearToEmpty();
}
inline const std::string& ProcessBlockResponseV2::block_hash_l1() const {
  // @@protoc_insertion_point(field_get:executor.v1.ProcessBlockResponseV2.block_hash_l1)
  return _internal_block_hash_l1();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProcessBlockResponseV2::set_block_hash_l1(ArgT0&& arg0, ArgT... args) {
 
 _impl_.block_hash_l1_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:executor.v1.ProcessBlockResponseV2.block_hash_l1)
}
inline std::string* ProcessBlockResponseV2::mutable_block_hash_l1() {
  std::string* _s = _internal_mutable_block_hash_l1();
  // @@protoc_insertion_point(field_mutable:executor.v1.ProcessBlockResponseV2.block_hash_l1)
  return _s;
}
inline const std::string& ProcessBlockResponseV2::_internal_block_hash_l1() const {
  return _impl_.block_hash_l1_.Get();
}
inline void ProcessBlockResponseV2::_internal_set_block_hash_l1(const std::string& value) {
  
  _impl_.block_hash_l1_.Set(value, GetArenaForAllocation());
}
inline std::string* ProcessBlockResponseV2::_internal_mutable_block_hash_l1() {
  
  return _impl_.block_hash_l1_.Mutable(GetArenaForAllocation());
}
inline std::string* ProcessBlockResponseV2::release_block_hash_l1() {
  // @@protoc_insertion_point(field_release:executor.v1.ProcessBlockResponseV2.block_hash_l1)
  return _impl_.block_hash_l1_.Release();
}
inline void ProcessBlockResponseV2::set_allocated_block_hash_l1(std::string* block_hash_l1) {
  if (block_hash_l1 != nullptr) {
    
  } else {
    
  }
  _impl_.block_hash_l1_.SetAllocated(block_hash_l1, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.block_hash_l1_.IsDefault()) {
    _impl_.block_hash_l1_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:executor.v1.ProcessBlockResponseV2.block_hash_l1)
}

// uint64 gas_used = 8;
inline void ProcessBlockResponseV2::clear_gas_used() {
  _impl_.gas_used_ = uint64_t{0u};
}
inline uint64_t ProcessBlockResponseV2::_internal_gas_used() const {
  return _impl_.gas_used_;
}
inline uint64_t ProcessBlockResponseV2::gas_used() const {
  // @@protoc_insertion_point(field_get:executor.v1.ProcessBlockResponseV2.gas_used)
  return _internal_gas_used();
}
inline void ProcessBlockResponseV2::_internal_set_gas_used(uint64_t value) {
  
  _impl_.gas_used_ = value;
}
inline void ProcessBlockResponseV2::set_gas_used(uint64_t value) {
  _internal_set_gas_used(value);
  // @@protoc_insertion_point(field_set:executor.v1.ProcessBlockResponseV2.gas_used)
}

// bytes block_info_root = 9;
inline void ProcessBlockResponseV2::clear_block_info_root() {
  _impl_.block_info_root_.ClearToEmpty();
}
inline const std::string& ProcessBlockResponseV2::block_info_root() const {
  // @@protoc_insertion_point(field_get:executor.v1.ProcessBlockResponseV2.block_info_root)
  return _internal_block_info_root();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProcessBlockResponseV2::set_block_info_root(ArgT0&& arg0, ArgT... args) {
 
 _impl_.block_info_root_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:executor.v1.ProcessBlockResponseV2.block_info_root)
}
inline std::string* ProcessBlockResponseV2::mutable_block_info_root() {
  std::string* _s = _internal_mutable_block_info_root();
  // @@protoc_insertion_point(field_mutable:executor.v1.ProcessBlockResponseV2.block_info_root)
  return _s;
}
inline const std::string& ProcessBlockResponseV2::_internal_block_info_root() const {
  return _impl_.block_info_root_.Get();
}
inline void ProcessBlockResponseV2::_internal_set_block_info_root(const std::string& value) {
  
  _impl_.block_info_root_.Set(value, GetArenaForAllocation());
}
inline std::string* ProcessBlockResponseV2::_internal_mutable_block_info_root() {
  
  return _impl_.block_info_root_.Mutable(GetArenaForAllocation());
}
inline std::string* ProcessBlockResponseV2::release_block_info_root() {
  // @@protoc_insertion_point(field_release:executor.v1.ProcessBlockResponseV2.block_info_root)
  return _impl_.block_info_root_.Release();
}
inline void ProcessBlockResponseV2::set_allocated_block_info_root(std::string* block_info_root) {
  if (block_info_root != nullptr) {
    
  } else {
    
  }
  _impl_.block_info_root_.SetAllocated(block_info_root, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.block_info_root_.IsDefault()) {
    _impl_.block_info_root_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:executor.v1.ProcessBlockResponseV2.block_info_root)
}

// bytes block_hash = 10;
inline void ProcessBlockResponseV2::clear_block_hash() {
  _impl_.block_hash_.ClearToEmpty();
}
inline const std::string& ProcessBlockResponseV2::block_hash() const {
  // @@protoc_insertion_point(field_get:executor.v1.ProcessBlockResponseV2.block_hash)
  return _internal_block_hash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProcessBlockResponseV2::set_block_hash(ArgT0&& arg0, ArgT... args) {
 
 _impl_.block_hash_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:executor.v1.ProcessBlockResponseV2.block_hash)
}
inline std::string* ProcessBlockResponseV2::mutable_block_hash() {
  std::string* _s = _internal_mutable_block_hash();
  // @@protoc_insertion_point(field_mutable:executor.v1.ProcessBlockResponseV2.block_hash)
  return _s;
}
inline const std::string& ProcessBlockResponseV2::_internal_block_hash() const {
  return _impl_.block_hash_.Get();
}
inline void ProcessBlockResponseV2::_internal_set_block_hash(const std::string& value) {
  
  _impl_.block_hash_.Set(value, GetArenaForAllocation());
}
inline std::string* ProcessBlockResponseV2::_internal_mutable_block_hash() {
  
  return _impl_.block_hash_.Mutable(GetArenaForAllocation());
}
inline std::string* ProcessBlockResponseV2::release_block_hash() {
  // @@protoc_insertion_point(field_release:executor.v1.ProcessBlockResponseV2.block_hash)
  return _impl_.block_hash_.Release();
}
inline void ProcessBlockResponseV2::set_allocated_block_hash(std::string* block_hash) {
  if (block_hash != nullptr) {
    
  } else {
    
  }
  _impl_.block_hash_.SetAllocated(block_hash, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.block_hash_.IsDefault()) {
    _impl_.block_hash_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:executor.v1.ProcessBlockResponseV2.block_hash)
}

// repeated .executor.v1.ProcessTransactionResponseV2 responses = 11;
inline int ProcessBlockResponseV2::_internal_responses_size() const {
  return _impl_.responses_.size();
}
inline int ProcessBlockResponseV2::responses_size() const {
  return _internal_responses_size();
}
inline void ProcessBlockResponseV2::clear_responses() {
  _impl_.responses_.Clear();
}
inline ::executor::v1::ProcessTransactionResponseV2* ProcessBlockResponseV2::mutable_responses(int index) {
  // @@protoc_insertion_point(field_mutable:executor.v1.ProcessBlockResponseV2.responses)
  return _impl_.responses_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::executor::v1::ProcessTransactionResponseV2 >*
ProcessBlockResponseV2::mutable_responses() {
  // @@protoc_insertion_point(field_mutable_list:executor.v1.ProcessBlockResponseV2.responses)
  return &_impl_.responses_;
}
inline const ::executor::v1::ProcessTransactionResponseV2& ProcessBlockResponseV2::_internal_responses(int index) const {
  return _impl_.responses_.Get(index);
}
inline const ::executor::v1::ProcessTransactionResponseV2& ProcessBlockResponseV2::responses(int index) const {
  // @@protoc_insertion_point(field_get:executor.v1.ProcessBlockResponseV2.responses)
  return _internal_responses(index);
}
inline ::executor::v1::ProcessTransactionResponseV2* ProcessBlockResponseV2::_internal_add_responses() {
  return _impl_.responses_.Add();
}
inline ::executor::v1::ProcessTransactionResponseV2* ProcessBlockResponseV2::add_responses() {
  ::executor::v1::ProcessTransactionResponseV2* _add = _internal_add_responses();
  // @@protoc_insertion_point(field_add:executor.v1.ProcessBlockResponseV2.responses)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::executor::v1::ProcessTransactionResponseV2 >&
ProcessBlockResponseV2::responses() const {
  // @@protoc_insertion_point(field_list:executor.v1.ProcessBlockResponseV2.responses)
  return _impl_.responses_;
}

// repeated .executor.v1.LogV2 logs = 12;
inline int ProcessBlockResponseV2::_internal_logs_size() const {
  return _impl_.logs_.size();
}
inline int ProcessBlockResponseV2::logs_size() const {
  return _internal_logs_size();
}
inline void ProcessBlockResponseV2::clear_logs() {
  _impl_.logs_.Clear();
}
inline ::executor::v1::LogV2* ProcessBlockResponseV2::mutable_logs(int index) {
  // @@protoc_insertion_point(field_mutable:executor.v1.ProcessBlockResponseV2.logs)
  return _impl_.logs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::executor::v1::LogV2 >*
ProcessBlockResponseV2::mutable_logs() {
  // @@protoc_insertion_point(field_mutable_list:executor.v1.ProcessBlockResponseV2.logs)
  return &_impl_.logs_;
}
inline const ::executor::v1::LogV2& ProcessBlockResponseV2::_internal_logs(int index) const {
  return _impl_.logs_.Get(index);
}
inline const ::executor::v1::LogV2& ProcessBlockResponseV2::logs(int index) const {
  // @@protoc_insertion_point(field_get:executor.v1.ProcessBlockResponseV2.logs)
  return _internal_logs(index);
}
inline ::executor::v1::LogV2* ProcessBlockResponseV2::_internal_add_logs() {
  return _impl_.logs_.Add();
}
inline ::executor::v1::LogV2* ProcessBlockResponseV2::add_logs() {
  ::executor::v1::LogV2* _add = _internal_add_logs();
  // @@protoc_insertion_point(field_add:executor.v1.ProcessBlockResponseV2.logs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::executor::v1::LogV2 >&
ProcessBlockResponseV2::logs() const {
  // @@protoc_insertion_point(field_list:executor.v1.ProcessBlockResponseV2.logs)
  return _impl_.logs_;
}

// -------------------------------------------------------------------

// ProcessTransactionResponseV2

// bytes tx_hash = 1;
inline void ProcessTransactionResponseV2::clear_tx_hash() {
  _impl_.tx_hash_.ClearToEmpty();
}
inline const std::string& ProcessTransactionResponseV2::tx_hash() const {
  // @@protoc_insertion_point(field_get:executor.v1.ProcessTransactionResponseV2.tx_hash)
  return _internal_tx_hash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProcessTransactionResponseV2::set_tx_hash(ArgT0&& arg0, ArgT... args) {
 
 _impl_.tx_hash_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:executor.v1.ProcessTransactionResponseV2.tx_hash)
}
inline std::string* ProcessTransactionResponseV2::mutable_tx_hash() {
  std::string* _s = _internal_mutable_tx_hash();
  // @@protoc_insertion_point(field_mutable:executor.v1.ProcessTransactionResponseV2.tx_hash)
  return _s;
}
inline const std::string& ProcessTransactionResponseV2::_internal_tx_hash() const {
  return _impl_.tx_hash_.Get();
}
inline void ProcessTransactionResponseV2::_internal_set_tx_hash(const std::string& value) {
  
  _impl_.tx_hash_.Set(value, GetArenaForAllocation());
}
inline std::string* ProcessTransactionResponseV2::_internal_mutable_tx_hash() {
  
  return _impl_.tx_hash_.Mutable(GetArenaForAllocation());
}
inline std::string* ProcessTransactionResponseV2::release_tx_hash() {
  // @@protoc_insertion_point(field_release:executor.v1.ProcessTransactionResponseV2.tx_hash)
  return _impl_.tx_hash_.Release();
}
inline void ProcessTransactionResponseV2::set_allocated_tx_hash(std::string* tx_hash) {
  if (tx_hash != nullptr) {
    
  } else {
    
  }
  _impl_.tx_hash_.SetAllocated(tx_hash, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.tx_hash_.IsDefault()) {
    _impl_.tx_hash_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:executor.v1.ProcessTransactionResponseV2.tx_hash)
}

// bytes tx_hash_l2 = 2;
inline void ProcessTransactionResponseV2::clear_tx_hash_l2() {
  _impl_.tx_hash_l2_.ClearToEmpty();
}
inline const std::string& ProcessTransactionResponseV2::tx_hash_l2() const {
  // @@protoc_insertion_point(field_get:executor.v1.ProcessTransactionResponseV2.tx_hash_l2)
  return _internal_tx_hash_l2();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProcessTransactionResponseV2::set_tx_hash_l2(ArgT0&& arg0, ArgT... args) {
 
 _impl_.tx_hash_l2_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:executor.v1.ProcessTransactionResponseV2.tx_hash_l2)
}
inline std::string* ProcessTransactionResponseV2::mutable_tx_hash_l2() {
  std::string* _s = _internal_mutable_tx_hash_l2();
  // @@protoc_insertion_point(field_mutable:executor.v1.ProcessTransactionResponseV2.tx_hash_l2)
  return _s;
}
inline const std::string& ProcessTransactionResponseV2::_internal_tx_hash_l2() const {
  return _impl_.tx_hash_l2_.Get();
}
inline void ProcessTransactionResponseV2::_internal_set_tx_hash_l2(const std::string& value) {
  
  _impl_.tx_hash_l2_.Set(value, GetArenaForAllocation());
}
inline std::string* ProcessTransactionResponseV2::_internal_mutable_tx_hash_l2() {
  
  return _impl_.tx_hash_l2_.Mutable(GetArenaForAllocation());
}
inline std::string* ProcessTransactionResponseV2::release_tx_hash_l2() {
  // @@protoc_insertion_point(field_release:executor.v1.ProcessTransactionResponseV2.tx_hash_l2)
  return _impl_.tx_hash_l2_.Release();
}
inline void ProcessTransactionResponseV2::set_allocated_tx_hash_l2(std::string* tx_hash_l2) {
  if (tx_hash_l2 != nullptr) {
    
  } else {
    
  }
  _impl_.tx_hash_l2_.SetAllocated(tx_hash_l2, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.tx_hash_l2_.IsDefault()) {
    _impl_.tx_hash_l2_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:executor.v1.ProcessTransactionResponseV2.tx_hash_l2)
}

// bytes rlp_tx = 3;
inline void ProcessTransactionResponseV2::clear_rlp_tx() {
  _impl_.rlp_tx_.ClearToEmpty();
}
inline const std::string& ProcessTransactionResponseV2::rlp_tx() const {
  // @@protoc_insertion_point(field_get:executor.v1.ProcessTransactionResponseV2.rlp_tx)
  return _internal_rlp_tx();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProcessTransactionResponseV2::set_rlp_tx(ArgT0&& arg0, ArgT... args) {
 
 _impl_.rlp_tx_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:executor.v1.ProcessTransactionResponseV2.rlp_tx)
}
inline std::string* ProcessTransactionResponseV2::mutable_rlp_tx() {
  std::string* _s = _internal_mutable_rlp_tx();
  // @@protoc_insertion_point(field_mutable:executor.v1.ProcessTransactionResponseV2.rlp_tx)
  return _s;
}
inline const std::string& ProcessTransactionResponseV2::_internal_rlp_tx() const {
  return _impl_.rlp_tx_.Get();
}
inline void ProcessTransactionResponseV2::_internal_set_rlp_tx(const std::string& value) {
  
  _impl_.rlp_tx_.Set(value, GetArenaForAllocation());
}
inline std::string* ProcessTransactionResponseV2::_internal_mutable_rlp_tx() {
  
  return _impl_.rlp_tx_.Mutable(GetArenaForAllocation());
}
inline std::string* ProcessTransactionResponseV2::release_rlp_tx() {
  // @@protoc_insertion_point(field_release:executor.v1.ProcessTransactionResponseV2.rlp_tx)
  return _impl_.rlp_tx_.Release();
}
inline void ProcessTransactionResponseV2::set_allocated_rlp_tx(std::string* rlp_tx) {
  if (rlp_tx != nullptr) {
    
  } else {
    
  }
  _impl_.rlp_tx_.SetAllocated(rlp_tx, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.rlp_tx_.IsDefault()) {
    _impl_.rlp_tx_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:executor.v1.ProcessTransactionResponseV2.rlp_tx)
}

// bytes block_hash = 4;
inline void ProcessTransactionResponseV2::clear_block_hash() {
  _impl_.block_hash_.ClearToEmpty();
}
inline const std::string& ProcessTransactionResponseV2::block_hash() const {
  // @@protoc_insertion_point(field_get:executor.v1.ProcessTransactionResponseV2.block_hash)
  return _internal_block_hash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProcessTransactionResponseV2::set_block_hash(ArgT0&& arg0, ArgT... args) {
 
 _impl_.block_hash_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:executor.v1.ProcessTransactionResponseV2.block_hash)
}
inline std::string* ProcessTransactionResponseV2::mutable_block_hash() {
  std::string* _s = _internal_mutable_block_hash();
  // @@protoc_insertion_point(field_mutable:executor.v1.ProcessTransactionResponseV2.block_hash)
  return _s;
}
inline const std::string& ProcessTransactionResponseV2::_internal_block_hash() const {
  return _impl_.block_hash_.Get();
}
inline void ProcessTransactionResponseV2::_internal_set_block_hash(const std::string& value) {
  
  _impl_.block_hash_.Set(value, GetArenaForAllocation());
}
inline std::string* ProcessTransactionResponseV2::_internal_mutable_block_hash() {
  
  return _impl_.block_hash_.Mutable(GetArenaForAllocation());
}
inline std::string* ProcessTransactionResponseV2::release_block_hash() {
  // @@protoc_insertion_point(field_release:executor.v1.ProcessTransactionResponseV2.block_hash)
  return _impl_.block_hash_.Release();
}
inline void ProcessTransactionResponseV2::set_allocated_block_hash(std::string* block_hash) {
  if (block_hash != nullptr) {
    
  } else {
    
  }
  _impl_.block_hash_.SetAllocated(block_hash, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.block_hash_.IsDefault()) {
    _impl_.block_hash_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:executor.v1.ProcessTransactionResponseV2.block_hash)
}

// uint64 block_number = 5;
inline void ProcessTransactionResponseV2::clear_block_number() {
  _impl_.block_number_ = uint64_t{0u};
}
inline uint64_t ProcessTransactionResponseV2::_internal_block_number() const {
  return _impl_.block_number_;
}
inline uint64_t ProcessTransactionResponseV2::block_number() const {
  // @@protoc_insertion_point(field_get:executor.v1.ProcessTransactionResponseV2.block_number)
  return _internal_block_number();
}
inline void ProcessTransactionResponseV2::_internal_set_block_number(uint64_t value) {
  
  _impl_.block_number_ = value;
}
inline void ProcessTransactionResponseV2::set_block_number(uint64_t value) {
  _internal_set_block_number(value);
  // @@protoc_insertion_point(field_set:executor.v1.ProcessTransactionResponseV2.block_number)
}

// uint32 type = 6;
inline void ProcessTransactionResponseV2::clear_type() {
  _impl_.type_ = 0u;
}
inline uint32_t ProcessTransactionResponseV2::_internal_type() const {
  return _impl_.type_;
}
inline uint32_t ProcessTransactionResponseV2::type() const {
  // @@protoc_insertion_point(field_get:executor.v1.ProcessTransactionResponseV2.type)
  return _internal_type();
}
inline void ProcessTransactionResponseV2::_internal_set_type(uint32_t value) {
  
  _impl_.type_ = value;
}
inline void ProcessTransactionResponseV2::set_type(uint32_t value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:executor.v1.ProcessTransactionResponseV2.type)
}

// bytes return_value = 7;
inline void ProcessTransactionResponseV2::clear_return_value() {
  _impl_.return_value_.ClearToEmpty();
}
inline const std::string& ProcessTransactionResponseV2::return_value() const {
  // @@protoc_insertion_point(field_get:executor.v1.ProcessTransactionResponseV2.return_value)
  return _internal_return_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProcessTransactionResponseV2::set_return_value(ArgT0&& arg0, ArgT... args) {
 
 _impl_.return_value_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:executor.v1.ProcessTransactionResponseV2.return_value)
}
inline std::string* ProcessTransactionResponseV2::mutable_return_value() {
  std::string* _s = _internal_mutable_return_value();
  // @@protoc_insertion_point(field_mutable:executor.v1.ProcessTransactionResponseV2.return_value)
  return _s;
}
inline const std::string& ProcessTransactionResponseV2::_internal_return_value() const {
  return _impl_.return_value_.Get();
}
inline void ProcessTransactionResponseV2::_internal_set_return_value(const std::string& value) {
  
  _impl_.return_value_.Set(value, GetArenaForAllocation());
}
inline std::string* ProcessTransactionResponseV2::_internal_mutable_return_value() {
  
  return _impl_.return_value_.Mutable(GetArenaForAllocation());
}
inline std::string* ProcessTransactionResponseV2::release_return_value() {
  // @@protoc_insertion_point(field_release:executor.v1.ProcessTransactionResponseV2.return_value)
  return _impl_.return_value_.Release();
}
inline void ProcessTransactionResponseV2::set_allocated_return_value(std::string* return_value) {
  if (return_value != nullptr) {
    
  } else {
    
  }
  _impl_.return_value_.SetAllocated(return_value, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.return_value_.IsDefault()) {
    _impl_.return_value_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:executor.v1.ProcessTransactionResponseV2.return_value)
}

// uint64 gas_left = 8;
inline void ProcessTransactionResponseV2::clear_gas_left() {
  _impl_.gas_left_ = uint64_t{0u};
}
inline uint64_t ProcessTransactionResponseV2::_internal_gas_left() const {
  return _impl_.gas_left_;
}
inline uint64_t ProcessTransactionResponseV2::gas_left() const {
  // @@protoc_insertion_point(field_get:executor.v1.ProcessTransactionResponseV2.gas_left)
  return _internal_gas_left();
}
inline void ProcessTransactionResponseV2::_internal_set_gas_left(uint64_t value) {
  
  _impl_.gas_left_ = value;
}
inline void ProcessTransactionResponseV2::set_gas_left(uint64_t value) {
  _internal_set_gas_left(value);
  // @@protoc_insertion_point(field_set:executor.v1.ProcessTransactionResponseV2.gas_left)
}

// uint64 gas_used = 9;
inline void ProcessTransactionResponseV2::clear_gas_used() {
  _impl_.gas_used_ = uint64_t{0u};
}
inline uint64_t ProcessTransactionResponseV2::_internal_gas_used() const {
  return _impl_.gas_used_;
}
inline uint64_t ProcessTransactionResponseV2::gas_used() const {
  // @@protoc_insertion_point(field_get:executor.v1.ProcessTransactionResponseV2.gas_used)
  return _internal_gas_used();
}
inline void ProcessTransactionResponseV2::_internal_set_gas_used(uint64_t value) {
  
  _impl_.gas_used_ = value;
}
inline void ProcessTransactionResponseV2::set_gas_used(uint64_t value) {
  _internal_set_gas_used(value);
  // @@protoc_insertion_point(field_set:executor.v1.ProcessTransactionResponseV2.gas_used)
}

// uint64 cumulative_gas_used = 10;
inline void ProcessTransactionResponseV2::clear_cumulative_gas_used() {
  _impl_.cumulative_gas_used_ = uint64_t{0u};
}
inline uint64_t ProcessTransactionResponseV2::_internal_cumulative_gas_used() const {
  return _impl_.cumulative_gas_used_;
}
inline uint64_t ProcessTransactionResponseV2::cumulative_gas_used() const {
  // @@protoc_insertion_point(field_get:executor.v1.ProcessTransactionResponseV2.cumulative_gas_used)
  return _internal_cumulative_gas_used();
}
inline void ProcessTransactionResponseV2::_internal_set_cumulative_gas_used(uint64_t value) {
  
  _impl_.cumulative_gas_used_ = value;
}
inline void ProcessTransactionResponseV2::set_cumulative_gas_used(uint64_t value) {
  _internal_set_cumulative_gas_used(value);
  // @@protoc_insertion_point(field_set:executor.v1.ProcessTransactionResponseV2.cumulative_gas_used)
}

// uint64 gas_refunded = 11;
inline void ProcessTransactionResponseV2::clear_gas_refunded() {
  _impl_.gas_refunded_ = uint64_t{0u};
}
inline uint64_t ProcessTransactionResponseV2::_internal_gas_refunded() const {
  return _impl_.gas_refunded_;
}
inline uint64_t ProcessTransactionResponseV2::gas_refunded() const {
  // @@protoc_insertion_point(field_get:executor.v1.ProcessTransactionResponseV2.gas_refunded)
  return _internal_gas_refunded();
}
inline void ProcessTransactionResponseV2::_internal_set_gas_refunded(uint64_t value) {
  
  _impl_.gas_refunded_ = value;
}
inline void ProcessTransactionResponseV2::set_gas_refunded(uint64_t value) {
  _internal_set_gas_refunded(value);
  // @@protoc_insertion_point(field_set:executor.v1.ProcessTransactionResponseV2.gas_refunded)
}

// .executor.v1.RomError error = 12;
inline void ProcessTransactionResponseV2::clear_error() {
  _impl_.error_ = 0;
}
inline ::executor::v1::RomError ProcessTransactionResponseV2::_internal_error() const {
  return static_cast< ::executor::v1::RomError >(_impl_.error_);
}
inline ::executor::v1::RomError ProcessTransactionResponseV2::error() const {
  // @@protoc_insertion_point(field_get:executor.v1.ProcessTransactionResponseV2.error)
  return _internal_error();
}
inline void ProcessTransactionResponseV2::_internal_set_error(::executor::v1::RomError value) {
  
  _impl_.error_ = value;
}
inline void ProcessTransactionResponseV2::set_error(::executor::v1::RomError value) {
  _internal_set_error(value);
  // @@protoc_insertion_point(field_set:executor.v1.ProcessTransactionResponseV2.error)
}

// string create_address = 13;
inline void ProcessTransactionResponseV2::clear_create_address() {
  _impl_.create_address_.ClearToEmpty();
}
inline const std::string& ProcessTransactionResponseV2::create_address() const {
  // @@protoc_insertion_point(field_get:executor.v1.ProcessTransactionResponseV2.create_address)
  return _internal_create_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProcessTransactionResponseV2::set_create_address(ArgT0&& arg0, ArgT... args) {
 
 _impl_.create_address_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:executor.v1.ProcessTransactionResponseV2.create_address)
}
inline std::string* ProcessTransactionResponseV2::mutable_create_address() {
  std::string* _s = _internal_mutable_create_address();
  // @@protoc_insertion_point(field_mutable:executor.v1.ProcessTransactionResponseV2.create_address)
  return _s;
}
inline const std::string& ProcessTransactionResponseV2::_internal_create_address() const {
  return _impl_.create_address_.Get();
}
inline void ProcessTransactionResponseV2::_internal_set_create_address(const std::string& value) {
  
  _impl_.create_address_.Set(value, GetArenaForAllocation());
}
inline std::string* ProcessTransactionResponseV2::_internal_mutable_create_address() {
  
  return _impl_.create_address_.Mutable(GetArenaForAllocation());
}
inline std::string* ProcessTransactionResponseV2::release_create_address() {
  // @@protoc_insertion_point(field_release:executor.v1.ProcessTransactionResponseV2.create_address)
  return _impl_.create_address_.Release();
}
inline void ProcessTransactionResponseV2::set_allocated_create_address(std::string* create_address) {
  if (create_address != nullptr) {
    
  } else {
    
  }
  _impl_.create_address_.SetAllocated(create_address, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.create_address_.IsDefault()) {
    _impl_.create_address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:executor.v1.ProcessTransactionResponseV2.create_address)
}

// bytes state_root = 14;
inline void ProcessTransactionResponseV2::clear_state_root() {
  _impl_.state_root_.ClearToEmpty();
}
inline const std::string& ProcessTransactionResponseV2::state_root() const {
  // @@protoc_insertion_point(field_get:executor.v1.ProcessTransactionResponseV2.state_root)
  return _internal_state_root();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProcessTransactionResponseV2::set_state_root(ArgT0&& arg0, ArgT... args) {
 
 _impl_.state_root_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:executor.v1.ProcessTransactionResponseV2.state_root)
}
inline std::string* ProcessTransactionResponseV2::mutable_state_root() {
  std::string* _s = _internal_mutable_state_root();
  // @@protoc_insertion_point(field_mutable:executor.v1.ProcessTransactionResponseV2.state_root)
  return _s;
}
inline const std::string& ProcessTransactionResponseV2::_internal_state_root() const {
  return _impl_.state_root_.Get();
}
inline void ProcessTransactionResponseV2::_internal_set_state_root(const std::string& value) {
  
  _impl_.state_root_.Set(value, GetArenaForAllocation());
}
inline std::string* ProcessTransactionResponseV2::_internal_mutable_state_root() {
  
  return _impl_.state_root_.Mutable(GetArenaForAllocation());
}
inline std::string* ProcessTransactionResponseV2::release_state_root() {
  // @@protoc_insertion_point(field_release:executor.v1.ProcessTransactionResponseV2.state_root)
  return _impl_.state_root_.Release();
}
inline void ProcessTransactionResponseV2::set_allocated_state_root(std::string* state_root) {
  if (state_root != nullptr) {
    
  } else {
    
  }
  _impl_.state_root_.SetAllocated(state_root, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.state_root_.IsDefault()) {
    _impl_.state_root_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:executor.v1.ProcessTransactionResponseV2.state_root)
}

// repeated .executor.v1.LogV2 logs = 15;
inline int ProcessTransactionResponseV2::_internal_logs_size() const {
  return _impl_.logs_.size();
}
inline int ProcessTransactionResponseV2::logs_size() const {
  return _internal_logs_size();
}
inline void ProcessTransactionResponseV2::clear_logs() {
  _impl_.logs_.Clear();
}
inline ::executor::v1::LogV2* ProcessTransactionResponseV2::mutable_logs(int index) {
  // @@protoc_insertion_point(field_mutable:executor.v1.ProcessTransactionResponseV2.logs)
  return _impl_.logs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::executor::v1::LogV2 >*
ProcessTransactionResponseV2::mutable_logs() {
  // @@protoc_insertion_point(field_mutable_list:executor.v1.ProcessTransactionResponseV2.logs)
  return &_impl_.logs_;
}
inline const ::executor::v1::LogV2& ProcessTransactionResponseV2::_internal_logs(int index) const {
  return _impl_.logs_.Get(index);
}
inline const ::executor::v1::LogV2& ProcessTransactionResponseV2::logs(int index) const {
  // @@protoc_insertion_point(field_get:executor.v1.ProcessTransactionResponseV2.logs)
  return _internal_logs(index);
}
inline ::executor::v1::LogV2* ProcessTransactionResponseV2::_internal_add_logs() {
  return _impl_.logs_.Add();
}
inline ::executor::v1::LogV2* ProcessTransactionResponseV2::add_logs() {
  ::executor::v1::LogV2* _add = _internal_add_logs();
  // @@protoc_insertion_point(field_add:executor.v1.ProcessTransactionResponseV2.logs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::executor::v1::LogV2 >&
ProcessTransactionResponseV2::logs() const {
  // @@protoc_insertion_point(field_list:executor.v1.ProcessTransactionResponseV2.logs)
  return _impl_.logs_;
}

// .executor.v1.FullTraceV2 full_trace = 16;
inline bool ProcessTransactionResponseV2::_internal_has_full_trace() const {
  return this != internal_default_instance() && _impl_.full_trace_ != nullptr;
}
inline bool ProcessTransactionResponseV2::has_full_trace() const {
  return _internal_has_full_trace();
}
inline void ProcessTransactionResponseV2::clear_full_trace() {
  if (GetArenaForAllocation() == nullptr && _impl_.full_trace_ != nullptr) {
    delete _impl_.full_trace_;
  }
  _impl_.full_trace_ = nullptr;
}
inline const ::executor::v1::FullTraceV2& ProcessTransactionResponseV2::_internal_full_trace() const {
  const ::executor::v1::FullTraceV2* p = _impl_.full_trace_;
  return p != nullptr ? *p : reinterpret_cast<const ::executor::v1::FullTraceV2&>(
      ::executor::v1::_FullTraceV2_default_instance_);
}
inline const ::executor::v1::FullTraceV2& ProcessTransactionResponseV2::full_trace() const {
  // @@protoc_insertion_point(field_get:executor.v1.ProcessTransactionResponseV2.full_trace)
  return _internal_full_trace();
}
inline void ProcessTransactionResponseV2::unsafe_arena_set_allocated_full_trace(
    ::executor::v1::FullTraceV2* full_trace) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.full_trace_);
  }
  _impl_.full_trace_ = full_trace;
  if (full_trace) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:executor.v1.ProcessTransactionResponseV2.full_trace)
}
inline ::executor::v1::FullTraceV2* ProcessTransactionResponseV2::release_full_trace() {
  
  ::executor::v1::FullTraceV2* temp = _impl_.full_trace_;
  _impl_.full_trace_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::executor::v1::FullTraceV2* ProcessTransactionResponseV2::unsafe_arena_release_full_trace() {
  // @@protoc_insertion_point(field_release:executor.v1.ProcessTransactionResponseV2.full_trace)
  
  ::executor::v1::FullTraceV2* temp = _impl_.full_trace_;
  _impl_.full_trace_ = nullptr;
  return temp;
}
inline ::executor::v1::FullTraceV2* ProcessTransactionResponseV2::_internal_mutable_full_trace() {
  
  if (_impl_.full_trace_ == nullptr) {
    auto* p = CreateMaybeMessage<::executor::v1::FullTraceV2>(GetArenaForAllocation());
    _impl_.full_trace_ = p;
  }
  return _impl_.full_trace_;
}
inline ::executor::v1::FullTraceV2* ProcessTransactionResponseV2::mutable_full_trace() {
  ::executor::v1::FullTraceV2* _msg = _internal_mutable_full_trace();
  // @@protoc_insertion_point(field_mutable:executor.v1.ProcessTransactionResponseV2.full_trace)
  return _msg;
}
inline void ProcessTransactionResponseV2::set_allocated_full_trace(::executor::v1::FullTraceV2* full_trace) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.full_trace_;
  }
  if (full_trace) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(full_trace);
    if (message_arena != submessage_arena) {
      full_trace = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, full_trace, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.full_trace_ = full_trace;
  // @@protoc_insertion_point(field_set_allocated:executor.v1.ProcessTransactionResponseV2.full_trace)
}

// string effective_gas_price = 17;
inline void ProcessTransactionResponseV2::clear_effective_gas_price() {
  _impl_.effective_gas_price_.ClearToEmpty();
}
inline const std::string& ProcessTransactionResponseV2::effective_gas_price() const {
  // @@protoc_insertion_point(field_get:executor.v1.ProcessTransactionResponseV2.effective_gas_price)
  return _internal_effective_gas_price();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProcessTransactionResponseV2::set_effective_gas_price(ArgT0&& arg0, ArgT... args) {
 
 _impl_.effective_gas_price_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:executor.v1.ProcessTransactionResponseV2.effective_gas_price)
}
inline std::string* ProcessTransactionResponseV2::mutable_effective_gas_price() {
  std::string* _s = _internal_mutable_effective_gas_price();
  // @@protoc_insertion_point(field_mutable:executor.v1.ProcessTransactionResponseV2.effective_gas_price)
  return _s;
}
inline const std::string& ProcessTransactionResponseV2::_internal_effective_gas_price() const {
  return _impl_.effective_gas_price_.Get();
}
inline void ProcessTransactionResponseV2::_internal_set_effective_gas_price(const std::string& value) {
  
  _impl_.effective_gas_price_.Set(value, GetArenaForAllocation());
}
inline std::string* ProcessTransactionResponseV2::_internal_mutable_effective_gas_price() {
  
  return _impl_.effective_gas_price_.Mutable(GetArenaForAllocation());
}
inline std::string* ProcessTransactionResponseV2::release_effective_gas_price() {
  // @@protoc_insertion_point(field_release:executor.v1.ProcessTransactionResponseV2.effective_gas_price)
  return _impl_.effective_gas_price_.Release();
}
inline void ProcessTransactionResponseV2::set_allocated_effective_gas_price(std::string* effective_gas_price) {
  if (effective_gas_price != nullptr) {
    
  } else {
    
  }
  _impl_.effective_gas_price_.SetAllocated(effective_gas_price, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.effective_gas_price_.IsDefault()) {
    _impl_.effective_gas_price_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:executor.v1.ProcessTransactionResponseV2.effective_gas_price)
}

// uint32 effective_percentage = 18;
inline void ProcessTransactionResponseV2::clear_effective_percentage() {
  _impl_.effective_percentage_ = 0u;
}
inline uint32_t ProcessTransactionResponseV2::_internal_effective_percentage() const {
  return _impl_.effective_percentage_;
}
inline uint32_t ProcessTransactionResponseV2::effective_percentage() const {
  // @@protoc_insertion_point(field_get:executor.v1.ProcessTransactionResponseV2.effective_percentage)
  return _internal_effective_percentage();
}
inline void ProcessTransactionResponseV2::_internal_set_effective_percentage(uint32_t value) {
  
  _impl_.effective_percentage_ = value;
}
inline void ProcessTransactionResponseV2::set_effective_percentage(uint32_t value) {
  _internal_set_effective_percentage(value);
  // @@protoc_insertion_point(field_set:executor.v1.ProcessTransactionResponseV2.effective_percentage)
}

// uint32 has_gasprice_opcode = 19;
inline void ProcessTransactionResponseV2::clear_has_gasprice_opcode() {
  _impl_.has_gasprice_opcode_ = 0u;
}
inline uint32_t ProcessTransactionResponseV2::_internal_has_gasprice_opcode() const {
  return _impl_.has_gasprice_opcode_;
}
inline uint32_t ProcessTransactionResponseV2::has_gasprice_opcode() const {
  // @@protoc_insertion_point(field_get:executor.v1.ProcessTransactionResponseV2.has_gasprice_opcode)
  return _internal_has_gasprice_opcode();
}
inline void ProcessTransactionResponseV2::_internal_set_has_gasprice_opcode(uint32_t value) {
  
  _impl_.has_gasprice_opcode_ = value;
}
inline void ProcessTransactionResponseV2::set_has_gasprice_opcode(uint32_t value) {
  _internal_set_has_gasprice_opcode(value);
  // @@protoc_insertion_point(field_set:executor.v1.ProcessTransactionResponseV2.has_gasprice_opcode)
}

// uint32 has_balance_opcode = 20;
inline void ProcessTransactionResponseV2::clear_has_balance_opcode() {
  _impl_.has_balance_opcode_ = 0u;
}
inline uint32_t ProcessTransactionResponseV2::_internal_has_balance_opcode() const {
  return _impl_.has_balance_opcode_;
}
inline uint32_t ProcessTransactionResponseV2::has_balance_opcode() const {
  // @@protoc_insertion_point(field_get:executor.v1.ProcessTransactionResponseV2.has_balance_opcode)
  return _internal_has_balance_opcode();
}
inline void ProcessTransactionResponseV2::_internal_set_has_balance_opcode(uint32_t value) {
  
  _impl_.has_balance_opcode_ = value;
}
inline void ProcessTransactionResponseV2::set_has_balance_opcode(uint32_t value) {
  _internal_set_has_balance_opcode(value);
  // @@protoc_insertion_point(field_set:executor.v1.ProcessTransactionResponseV2.has_balance_opcode)
}

// -------------------------------------------------------------------

// LogV2

// string address = 1;
inline void LogV2::clear_address() {
  _impl_.address_.ClearToEmpty();
}
inline const std::string& LogV2::address() const {
  // @@protoc_insertion_point(field_get:executor.v1.LogV2.address)
  return _internal_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LogV2::set_address(ArgT0&& arg0, ArgT... args) {
 
 _impl_.address_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:executor.v1.LogV2.address)
}
inline std::string* LogV2::mutable_address() {
  std::string* _s = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:executor.v1.LogV2.address)
  return _s;
}
inline const std::string& LogV2::_internal_address() const {
  return _impl_.address_.Get();
}
inline void LogV2::_internal_set_address(const std::string& value) {
  
  _impl_.address_.Set(value, GetArenaForAllocation());
}
inline std::string* LogV2::_internal_mutable_address() {
  
  return _impl_.address_.Mutable(GetArenaForAllocation());
}
inline std::string* LogV2::release_address() {
  // @@protoc_insertion_point(field_release:executor.v1.LogV2.address)
  return _impl_.address_.Release();
}
inline void LogV2::set_allocated_address(std::string* address) {
  if (address != nullptr) {
    
  } else {
    
  }
  _impl_.address_.SetAllocated(address, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.address_.IsDefault()) {
    _impl_.address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:executor.v1.LogV2.address)
}

// repeated bytes topics = 2;
inline int LogV2::_internal_topics_size() const {
  return _impl_.topics_.size();
}
inline int LogV2::topics_size() const {
  return _internal_topics_size();
}
inline void LogV2::clear_topics() {
  _impl_.topics_.Clear();
}
inline std::string* LogV2::add_topics() {
  std::string* _s = _internal_add_topics();
  // @@protoc_insertion_point(field_add_mutable:executor.v1.LogV2.topics)
  return _s;
}
inline const std::string& LogV2::_internal_topics(int index) const {
  return _impl_.topics_.Get(index);
}
inline const std::string& LogV2::topics(int index) const {
  // @@protoc_insertion_point(field_get:executor.v1.LogV2.topics)
  return _internal_topics(index);
}
inline std::string* LogV2::mutable_topics(int index) {
  // @@protoc_insertion_point(field_mutable:executor.v1.LogV2.topics)
  return _impl_.topics_.Mutable(index);
}
inline void LogV2::set_topics(int index, const std::string& value) {
  _impl_.topics_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:executor.v1.LogV2.topics)
}
inline void LogV2::set_topics(int index, std::string&& value) {
  _impl_.topics_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:executor.v1.LogV2.topics)
}
inline void LogV2::set_topics(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.topics_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:executor.v1.LogV2.topics)
}
inline void LogV2::set_topics(int index, const void* value, size_t size) {
  _impl_.topics_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:executor.v1.LogV2.topics)
}
inline std::string* LogV2::_internal_add_topics() {
  return _impl_.topics_.Add();
}
inline void LogV2::add_topics(const std::string& value) {
  _impl_.topics_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:executor.v1.LogV2.topics)
}
inline void LogV2::add_topics(std::string&& value) {
  _impl_.topics_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:executor.v1.LogV2.topics)
}
inline void LogV2::add_topics(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.topics_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:executor.v1.LogV2.topics)
}
inline void LogV2::add_topics(const void* value, size_t size) {
  _impl_.topics_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:executor.v1.LogV2.topics)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
LogV2::topics() const {
  // @@protoc_insertion_point(field_list:executor.v1.LogV2.topics)
  return _impl_.topics_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
LogV2::mutable_topics() {
  // @@protoc_insertion_point(field_mutable_list:executor.v1.LogV2.topics)
  return &_impl_.topics_;
}

// bytes data = 3;
inline void LogV2::clear_data() {
  _impl_.data_.ClearToEmpty();
}
inline const std::string& LogV2::data() const {
  // @@protoc_insertion_point(field_get:executor.v1.LogV2.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LogV2::set_data(ArgT0&& arg0, ArgT... args) {
 
 _impl_.data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:executor.v1.LogV2.data)
}
inline std::string* LogV2::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:executor.v1.LogV2.data)
  return _s;
}
inline const std::string& LogV2::_internal_data() const {
  return _impl_.data_.Get();
}
inline void LogV2::_internal_set_data(const std::string& value) {
  
  _impl_.data_.Set(value, GetArenaForAllocation());
}
inline std::string* LogV2::_internal_mutable_data() {
  
  return _impl_.data_.Mutable(GetArenaForAllocation());
}
inline std::string* LogV2::release_data() {
  // @@protoc_insertion_point(field_release:executor.v1.LogV2.data)
  return _impl_.data_.Release();
}
inline void LogV2::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  _impl_.data_.SetAllocated(data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data_.IsDefault()) {
    _impl_.data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:executor.v1.LogV2.data)
}

// uint64 block_number = 4;
inline void LogV2::clear_block_number() {
  _impl_.block_number_ = uint64_t{0u};
}
inline uint64_t LogV2::_internal_block_number() const {
  return _impl_.block_number_;
}
inline uint64_t LogV2::block_number() const {
  // @@protoc_insertion_point(field_get:executor.v1.LogV2.block_number)
  return _internal_block_number();
}
inline void LogV2::_internal_set_block_number(uint64_t value) {
  
  _impl_.block_number_ = value;
}
inline void LogV2::set_block_number(uint64_t value) {
  _internal_set_block_number(value);
  // @@protoc_insertion_point(field_set:executor.v1.LogV2.block_number)
}

// bytes tx_hash = 5;
inline void LogV2::clear_tx_hash() {
  _impl_.tx_hash_.ClearToEmpty();
}
inline const std::string& LogV2::tx_hash() const {
  // @@protoc_insertion_point(field_get:executor.v1.LogV2.tx_hash)
  return _internal_tx_hash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LogV2::set_tx_hash(ArgT0&& arg0, ArgT... args) {
 
 _impl_.tx_hash_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:executor.v1.LogV2.tx_hash)
}
inline std::string* LogV2::mutable_tx_hash() {
  std::string* _s = _internal_mutable_tx_hash();
  // @@protoc_insertion_point(field_mutable:executor.v1.LogV2.tx_hash)
  return _s;
}
inline const std::string& LogV2::_internal_tx_hash() const {
  return _impl_.tx_hash_.Get();
}
inline void LogV2::_internal_set_tx_hash(const std::string& value) {
  
  _impl_.tx_hash_.Set(value, GetArenaForAllocation());
}
inline std::string* LogV2::_internal_mutable_tx_hash() {
  
  return _impl_.tx_hash_.Mutable(GetArenaForAllocation());
}
inline std::string* LogV2::release_tx_hash() {
  // @@protoc_insertion_point(field_release:executor.v1.LogV2.tx_hash)
  return _impl_.tx_hash_.Release();
}
inline void LogV2::set_allocated_tx_hash(std::string* tx_hash) {
  if (tx_hash != nullptr) {
    
  } else {
    
  }
  _impl_.tx_hash_.SetAllocated(tx_hash, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.tx_hash_.IsDefault()) {
    _impl_.tx_hash_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:executor.v1.LogV2.tx_hash)
}

// bytes tx_hash_l2 = 6;
inline void LogV2::clear_tx_hash_l2() {
  _impl_.tx_hash_l2_.ClearToEmpty();
}
inline const std::string& LogV2::tx_hash_l2() const {
  // @@protoc_insertion_point(field_get:executor.v1.LogV2.tx_hash_l2)
  return _internal_tx_hash_l2();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LogV2::set_tx_hash_l2(ArgT0&& arg0, ArgT... args) {
 
 _impl_.tx_hash_l2_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:executor.v1.LogV2.tx_hash_l2)
}
inline std::string* LogV2::mutable_tx_hash_l2() {
  std::string* _s = _internal_mutable_tx_hash_l2();
  // @@protoc_insertion_point(field_mutable:executor.v1.LogV2.tx_hash_l2)
  return _s;
}
inline const std::string& LogV2::_internal_tx_hash_l2() const {
  return _impl_.tx_hash_l2_.Get();
}
inline void LogV2::_internal_set_tx_hash_l2(const std::string& value) {
  
  _impl_.tx_hash_l2_.Set(value, GetArenaForAllocation());
}
inline std::string* LogV2::_internal_mutable_tx_hash_l2() {
  
  return _impl_.tx_hash_l2_.Mutable(GetArenaForAllocation());
}
inline std::string* LogV2::release_tx_hash_l2() {
  // @@protoc_insertion_point(field_release:executor.v1.LogV2.tx_hash_l2)
  return _impl_.tx_hash_l2_.Release();
}
inline void LogV2::set_allocated_tx_hash_l2(std::string* tx_hash_l2) {
  if (tx_hash_l2 != nullptr) {
    
  } else {
    
  }
  _impl_.tx_hash_l2_.SetAllocated(tx_hash_l2, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.tx_hash_l2_.IsDefault()) {
    _impl_.tx_hash_l2_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:executor.v1.LogV2.tx_hash_l2)
}

// uint32 tx_index = 7;
inline void LogV2::clear_tx_index() {
  _impl_.tx_index_ = 0u;
}
inline uint32_t LogV2::_internal_tx_index() const {
  return _impl_.tx_index_;
}
inline uint32_t LogV2::tx_index() const {
  // @@protoc_insertion_point(field_get:executor.v1.LogV2.tx_index)
  return _internal_tx_index();
}
inline void LogV2::_internal_set_tx_index(uint32_t value) {
  
  _impl_.tx_index_ = value;
}
inline void LogV2::set_tx_index(uint32_t value) {
  _internal_set_tx_index(value);
  // @@protoc_insertion_point(field_set:executor.v1.LogV2.tx_index)
}

// bytes block_hash = 8;
inline void LogV2::clear_block_hash() {
  _impl_.block_hash_.ClearToEmpty();
}
inline const std::string& LogV2::block_hash() const {
  // @@protoc_insertion_point(field_get:executor.v1.LogV2.block_hash)
  return _internal_block_hash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LogV2::set_block_hash(ArgT0&& arg0, ArgT... args) {
 
 _impl_.block_hash_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:executor.v1.LogV2.block_hash)
}
inline std::string* LogV2::mutable_block_hash() {
  std::string* _s = _internal_mutable_block_hash();
  // @@protoc_insertion_point(field_mutable:executor.v1.LogV2.block_hash)
  return _s;
}
inline const std::string& LogV2::_internal_block_hash() const {
  return _impl_.block_hash_.Get();
}
inline void LogV2::_internal_set_block_hash(const std::string& value) {
  
  _impl_.block_hash_.Set(value, GetArenaForAllocation());
}
inline std::string* LogV2::_internal_mutable_block_hash() {
  
  return _impl_.block_hash_.Mutable(GetArenaForAllocation());
}
inline std::string* LogV2::release_block_hash() {
  // @@protoc_insertion_point(field_release:executor.v1.LogV2.block_hash)
  return _impl_.block_hash_.Release();
}
inline void LogV2::set_allocated_block_hash(std::string* block_hash) {
  if (block_hash != nullptr) {
    
  } else {
    
  }
  _impl_.block_hash_.SetAllocated(block_hash, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.block_hash_.IsDefault()) {
    _impl_.block_hash_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:executor.v1.LogV2.block_hash)
}

// uint32 index = 9;
inline void LogV2::clear_index() {
  _impl_.index_ = 0u;
}
inline uint32_t LogV2::_internal_index() const {
  return _impl_.index_;
}
inline uint32_t LogV2::index() const {
  // @@protoc_insertion_point(field_get:executor.v1.LogV2.index)
  return _internal_index();
}
inline void LogV2::_internal_set_index(uint32_t value) {
  
  _impl_.index_ = value;
}
inline void LogV2::set_index(uint32_t value) {
  _internal_set_index(value);
  // @@protoc_insertion_point(field_set:executor.v1.LogV2.index)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace v1
}  // namespace executor

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::executor::v1::RomError> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::executor::v1::RomError>() {
  return ::executor::v1::RomError_descriptor();
}
template <> struct is_proto_enum< ::executor::v1::ExecutorError> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::executor::v1::ExecutorError>() {
  return ::executor::v1::ExecutorError_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_executor_2eproto
