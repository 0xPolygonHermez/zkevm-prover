Set_WithSibling:

    ${GetRKey()} => RKEY                                    ; LOAD FREE ${GetRKey()} -> RKEY;
    ${GetSiblingRKey()} => SIBLING_RKEY                     ; LOAD FREE ${GetSiblingRKey()} -> SIBLING_RKEY

    ; NewRoot = LeafNodeHash = Hash( 1 | 0 | 0 | 0, Hash( Key, Hash( Value[0-3], Value[4-7] ) ) );
    ${GetValueLow()} => VALUE_LOW                           ; LOAD FREE ${GetValueLow()} -> VALUE_LOW;
    VALUE_LOW => HASH_LEFT                                  ; LOAD VALUE_LOW -> HASH_LEFT;
    ${GetValueHigh()} => VALUE_HIGH                         ; LOAD FREE ${GetValueHigh()} -> VALUE_HIGH;
    VALUE_HIGH => HASH_RIGHT                                ; LOAD VALUE_HIGH -> HASH_RIGHT;
                                    :HASH(HASH_RIGHT)       ; HASH -> HASH_RIGHT;
    RKEY => HASH_LEFT                                       ; LOAD RKEY -> HASH_LEFT;
                                    :HASH(HASH_RIGHT)       ; HASH -> HASH_RIGHT;
    0x1=> HASH_LEFT                                         ; LOAD FREE ${GetConstant(1,0,0,0)} -> HASH_LEFT;
                                    :HASH(NEW_ROOT)         ; HASH -> NEW_ROOT;

    ; OldRoot = LeafNodeHash = Hash( 1 | 0 | 0 | 0, Hash( Key, Hash( SiblingValue[0-3], SiblingValue[4-7] ) ) );
    ${GetSiblingValueLow()} => HASH_LEFT                    ; LOAD FREE ${GetSiblingValueLow()} -> HASH_LEFT;
    ${GetSiblingValueHigh()} => HASH_RIGHT                  ; LOAD FREE ${GetSiblingValueHigh()} -> HASH_RIGHT;
                                    :HASH(SIBLING_HASH_VALUE) ; HASH -> SIBLING_HASH_VALUE;
    SIBLING_HASH_VALUE => HASH_RIGHT                        ; LOAD SIBLING_HASH_VALUE -> HASH_RIGHT;
    RKEY => HASH_LEFT                                       ; LOAD RKEY -> HASH_LEFT;
                                    :HASH(HASH_RIGHT)       ; HASH -> HASH_RIGHT;
    0x1 => HASH_LEFT                                        ; LOAD FREE ${GetConstant(1,0,0,0)} -> HASH_LEFT;
                                    :HASH(NEW_ROOT)         ; HASH -> NEW_ROOT;

    ; Init LEVEL, and rotate as per key level
    0x1 => LEVEL                                            ; LOAD FREE ${GetConstant(1,0,0,0)} -> LEVEL;
    {GetLevelBit(0)}                :JMPZ(SWS_LevelBit1)    ; JMPZ FREE ${GetLevelBit(0)} -> SWS_LevelBit1; // If level bit 0 is zero, then skip the next 1 rotation
                                    :ROTATE_LEVEL           ; ROTATE_LEVEL;

SWS_LevelBit1:

    ${GetLevelBit(1)}               :JMPZ(SWS_SiblingHash)  ; JMPZ FREE ${GetLevelBit(1)} -> SWS_SiblingHash; // If level bit 1 is zero, then skip the next 2 rotations
                                    :ROTATE_LEVEL           ; ROTATE_LEVEL;
                                    :ROTATE_LEVEL           ; ROTATE_LEVEL;

SWS_SiblingHash:

    ${GetNextKeyBit()} => RKEY_BIT                          ; LOAD FREE ${GetNextKeyBit()} -> RKEY_BIT;
    RKEY_BIT                        :JMPZ(SWS_SiblingIsRight1) ; JMPZ RKEY_BIT -> SWS_SiblingIsRight1; // If next key bit is zero, then sibling is right (sibling's next key bit is 1)

SWS_SiblingIsLeft1:

    ; NewRoot = Hash( SiblingHash, LeafNodeHash )
    OLD_ROOT => HASH_LEFT                                   ; LOAD OLD_ROOT -> HASH_LEFT;
    NEW_ROOT => HASH_RIGHT                                  ; LOAD NEW_ROOT -> HASH_RIGHT;
                                    :HASH(NEW_ROOT)         ; HASH -> NEW_ROOT;

                                    :JMP(SWS_ClimbBranch)   ; JMP SWS_ClimbBranch;

SWS_SiblingIsRight1:

    ; NewRoot = Hash( LeafNodeHash, SiblingHash )
    NEW_ROOT => HASH_LEFT                                   ; LOAD NEW_ROOT -> HASH_LEFT;
    OLD_ROOT => HASH_RIGHT                                  ; LOAD OLD_ROOT -> HASH_RIGHT;
                                    :HASH(NEW_ROOT)         ; HASH -> NEW_ROOT;

SWS_ClimbBranch:

    ${GetTopOfBranch()}             :JMPZ(SWS_StartOldRoot) ; JMPZ FREE ${GetTopOfBranch()} -> SWS_StartOldRoot; // If we are at the top of the branch, then go to SWS_StartOldRoot

                                    :CLIMB_RKEY             ; CLIMB_RKEY;
                                    :CLIMB_SIBLING_RKEY     ; CLIMB_SIBLING_RKEY;
                                    :ROTATE_LEVEL           ; ROTATE_LEVEL;

    ${GetNextKeyBit()} => RKEY_BIT                          ; LOAD FREE ${GetNextKeyBit()} -> RKEY_BIT;
    RKEY_BIT                        :JMPZ(SWS_SiblingIsRight2) ; JMPZ RKEY_BIT -> SWS_SiblingIsRight2;

SWS_SiblingIsLeft2:

    ; NewRoot = Hash ( SiblingHash, NewRoot )
    ${GetSiblingHash) => HASH_LEFT                          ; LOAD FREE ${GetSiblingHash) -> HASH_LEFT;
    NEW_ROOT => HASH_RIGHT                                  ; LOAD NEW_ROOT -> HASH_RIGHT;
                                    :HASH(NEW_ROOT)         ; HASH -> NEW_ROOT

                                    :JMP(SWS_ClimbBranch)   ; JMP SWS_ClimbBranch;

SWS_SiblingIsRight2:

    ; NewRoot = Hash ( NewRoot, SiblingHash )
    NEW_ROOT => HASH_LEFT                                   ; LOAD NEW_ROOT -> HASH_LEFT;
    ${GetSiblingHash()} => HASH_RIGHT                       ; LOAD FREE ${GetSiblingHash()} -> HASH_RIGHT;
                                    :HASH(NEW_ROOT)         ; HASH -> NEW_ROOT

                                    :JMP(SWS_ClimbBranch)   ; JMP SWS_ClimbBranch;

StartOldRoot:
    ; OldRoot = Hash( 1 | 0 | 0 | 0, Hash( SiblingKey, Hash( SiblingValue[0-3], SiblingValue[4-7] ) ) );
    HASH_SIBLING_VALUE => HASH_RIGHT                        ; LOAD HASH_SIBLING_VALUE -> HASH_RIGHT;
    SIBLING_RKEY => HASH_LEFT                               ; LOAD SIBLING_RKEY -> HASH_LEFT // Remaining sibling key
                                    :HASH(HASH_RIGHT)       ; HASH -> HASH_RIGHT
    0x1 => HASH_LEFT                                        ; LOAD FREE ${GetConstant(1,0,0,0)} -> HASH_LEFT;
                                    :HASH(OLD_ROOT)         ; HASH -> OLD_ROOT

SWS_ClimbTree:
    ${GetTopOfTree()}               :JMPZ(SWS_Latch)        ; JMPZ FREE ${GetTopOfTree()} -> SWS_Latch; // If we are at the top of the tree, then go to SWS_Latch

    ${GetNextKeyBit()} => RKEY_BIT                          ; LOAD FREE ${GetNextKeyBit()} -> RKEY_BIT;
    RKEY_BIT                        :JMPZ(SWS_SiblingIsRight2) ; JMPZ RKEY_BIT -> SWS_SiblingIsRight2;

SWS_SiblingIsLeft3:

    ; NewRoot = Hash ( SiblingHash, NewRoot )
    NEW_ROOT => HASH_RIGHT                                  ; LOAD NEW_ROOT -> HASH_RIGHT;
    ${GetSiblingHash()} => HASH_LEFT                        ; LOAD FREE ${GetSiblingHash()} -> HASH_LEFT;
                                    :HASH(NEW_ROOT)         ; HASH -> NEW_ROOT;

    ; OldRoot = Hash ( SiblingHash, OldRoot )
    OLD_ROOT => HASH_RIGHT                                  ; LOAD OLD_ROOT -> HASH_RIGHT;
                                    :HASH(OLD_ROOT)         ; HASH -> OLD_ROOT

    ; Update remaining key
                                    :CLIMB_RKEY             ; CLIMB_RKEY;
                                    :ROTATE_LEVEL           ; ROTATE_LEVEL;

                                    :JMP(SWS_ClimbTree)     ; JMP SWS_ClimbTree;

SWS_SiblingIsRight3:

    ; NewRoot = Hash ( NewRoot, SiblingHash )
    NEW_ROOT => HASH_LEFT                                   ; LOAD NEW_ROOT -> HASH_LEFT;
    ${GetSiblingHash()} => HASH_RIGHT                       ; LOAD FREE ${GetSiblingHash()} -> HASH_RIGHT;
                                    :HASH(NEW_ROOT)         ; HASH -> NEW_ROOT;

    ; OldRoot = Hash ( OldRoot, SiblingHash )
    OLD_ROOT => HASH_LEFT                                   ; LOAD OLD_ROOT -> HASH_LEFT;
                                    :HASH(OLD_ROOT)         ; HASH -> OLD_ROOT

    ; Update remaining key
                                    :CLIMB_RKEY             ; CLIMB_RKEY;
                                    :ROTATE_LEVEL           ; ROTATE_LEVEL;

                                    :JMP(SWS_ClimbTree)     ; JMP SWS_ClimbTree;

SWS_Latch:
                                    :LATCH_SET              ; At this point consistency is granted: OLD_ROOT, NEW_ROOT, RKEY (complete key), VALUE_LOW, VALUE_HIGH, LEVEL